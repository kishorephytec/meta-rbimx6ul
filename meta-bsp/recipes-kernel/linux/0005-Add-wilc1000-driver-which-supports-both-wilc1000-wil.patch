From c964a8c5964b7e5ce32bd857312548aa58600ba5 Mon Sep 17 00:00:00 2001
From: khaleel <khaleel.s@phytec.in>
Date: Thu, 29 Dec 2022 20:14:12 +0530
Subject: [PATCH 5/6] Add wilc1000 driver which supports both wilc1000 &
 wilc3000 from linux4microchip kernel source

Delete existing wilc1000 driver from drivers/net/wireless/microchip
and adds latest wilc1000 from linux4microchip

Signed-off-by: khaleel <khaleel.s@phytec.in>
---
 arch/arm/configs/imx6_Rb_defconfig                 |    1 +
 drivers/net/wireless/microchip/Makefile            |    2 +-
 drivers/net/wireless/microchip/wilc1000/Kconfig    |   36 +-
 drivers/net/wireless/microchip/wilc1000/Makefile   |   16 +-
 drivers/net/wireless/microchip/wilc1000/bt.c       |  697 +++++++++++
 drivers/net/wireless/microchip/wilc1000/cfg80211.c | 1043 +++++++++++++---
 drivers/net/wireless/microchip/wilc1000/cfg80211.h |   12 +-
 drivers/net/wireless/microchip/wilc1000/debugfs.c  |  426 +++++++
 drivers/net/wireless/microchip/wilc1000/debugfs.h  |   60 +
 drivers/net/wireless/microchip/wilc1000/fw.h       |   29 +-
 drivers/net/wireless/microchip/wilc1000/hif.c      | 1127 ++++++++++++++----
 drivers/net/wireless/microchip/wilc1000/hif.h      |   42 +-
 drivers/net/wireless/microchip/wilc1000/mon.c      |  164 ++-
 drivers/net/wireless/microchip/wilc1000/netdev.c   |  795 ++++++++++---
 drivers/net/wireless/microchip/wilc1000/netdev.h   |  254 +++-
 drivers/net/wireless/microchip/wilc1000/power.c    |   76 ++
 drivers/net/wireless/microchip/wilc1000/sdio.c     |  430 ++++---
 drivers/net/wireless/microchip/wilc1000/spi.c      |  709 +++++++++--
 drivers/net/wireless/microchip/wilc1000/sysfs.c    |  107 ++
 drivers/net/wireless/microchip/wilc1000/wlan.c     | 1242 +++++++++++++++-----
 drivers/net/wireless/microchip/wilc1000/wlan.h     |  172 ++-
 drivers/net/wireless/microchip/wilc1000/wlan_cfg.c |  100 +-
 drivers/net/wireless/microchip/wilc1000/wlan_cfg.h |   11 +
 drivers/net/wireless/microchip/wilc1000/wlan_if.h  |   38 +-
 24 files changed, 6264 insertions(+), 1325 deletions(-)
 create mode 100644 drivers/net/wireless/microchip/wilc1000/bt.c
 create mode 100644 drivers/net/wireless/microchip/wilc1000/debugfs.c
 create mode 100644 drivers/net/wireless/microchip/wilc1000/debugfs.h
 create mode 100644 drivers/net/wireless/microchip/wilc1000/power.c
 create mode 100644 drivers/net/wireless/microchip/wilc1000/sysfs.c

diff --git a/arch/arm/configs/imx6_Rb_defconfig b/arch/arm/configs/imx6_Rb_defconfig
index 2211418..79a14f5 100644
--- a/arch/arm/configs/imx6_Rb_defconfig
+++ b/arch/arm/configs/imx6_Rb_defconfig
@@ -148,6 +148,7 @@ CONFIG_BRCMFMAC=m
 CONFIG_MWIFIEX=m
 CONFIG_MWIFIEX_SDIO=m
 CONFIG_MWIFIEX_PCIE=m
+CONFIG_WILC_SDIO=m
 CONFIG_WL12XX=m
 CONFIG_WL18XX=m
 CONFIG_WLCORE_SDIO=m
diff --git a/drivers/net/wireless/microchip/Makefile b/drivers/net/wireless/microchip/Makefile
index 73b763c..a1866854 100644
--- a/drivers/net/wireless/microchip/Makefile
+++ b/drivers/net/wireless/microchip/Makefile
@@ -1,2 +1,2 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000)		+= wilc1000/
+obj-$(CONFIG_WILC)		+= wilc1000/
diff --git a/drivers/net/wireless/microchip/wilc1000/Kconfig b/drivers/net/wireless/microchip/wilc1000/Kconfig
index 80c92e8..2bfa808 100644
--- a/drivers/net/wireless/microchip/wilc1000/Kconfig
+++ b/drivers/net/wireless/microchip/wilc1000/Kconfig
@@ -1,47 +1,45 @@
 # SPDX-License-Identifier: GPL-2.0
-config WILC1000
+config WILC
 	tristate
-	help
-	  Add support for the Atmel WILC1000 802.11 b/g/n SoC.
-	  This provides Wi-FI over an SDIO or SPI interface, and
-	  is usually found in IoT devices.
-
-	  This module only support IEEE 802.11n WiFi.
 
-config WILC1000_SDIO
-	tristate "Atmel WILC1000 SDIO (WiFi only)"
+config WILC_SDIO
+	tristate "WILC SDIO"
 	depends on CFG80211 && INET && MMC
-	select WILC1000
+	select WILC
 	help
 	  This module adds support for the SDIO interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
 	  It meets SDIO card specification version 2.0. The interface supports
 	  the 1-bit/4-bit SD transfer mode at the clock range of 0-50 MHz.
 	  The host can use this interface to read and write from any register
 	  within the chip as well as configure the WILC1000 for data DMA.
 	  To use this interface, pin9 (SDIO_SPI_CFG) must be grounded. Select
 	  this if your platform is using the SDIO bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_SPI
-	tristate "Atmel WILC1000 SPI (WiFi only)"
+config WILC_SPI
+	tristate "WILC SPI"
 	depends on CFG80211 && INET && SPI
-	select WILC1000
+	select WILC
 	select CRC7
+	select CRC_ITU_T
 	help
 	  This module adds support for the SPI interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 has a Serial Peripheral
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 has a Serial Peripheral
 	  Interface (SPI) that operates as a SPI slave. This SPI interface can
 	  be used for control and for serial I/O of 802.11 data. The SPI is a
 	  full-duplex slave synchronous serial interface that is available
 	  immediately following reset when pin 9 (SDIO_SPI_CFG) is tied to
 	  VDDIO. Select this if your platform is using the SPI bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_HW_OOB_INTR
-	bool "WILC1000 out of band interrupt"
-	depends on WILC1000_SDIO
+config WILC_HW_OOB_INTR
+	bool "WILC out of band interrupt"
+	depends on WILC_SDIO
+	default n
 	help
 	  This option enables out-of-band interrupt support for the WILC1000
 	  chipset. This OOB interrupt is intended to provide a faster interrupt
 	  mechanism for SDIO host controllers that don't support SDIO interrupt.
 	  Select this option If the SDIO host controller in your platform
-	  doesn't support SDIO time devision interrupt.
+	  doesn't support SDIO time division interrupt.
diff --git a/drivers/net/wireless/microchip/wilc1000/Makefile b/drivers/net/wireless/microchip/wilc1000/Makefile
index c3c9e34..64c39aa 100644
--- a/drivers/net/wireless/microchip/wilc1000/Makefile
+++ b/drivers/net/wireless/microchip/wilc1000/Makefile
@@ -1,11 +1,13 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000) += wilc1000.o
+ccflags-y += -I$(src)/ -DWILC_DEBUGFS
 
-wilc1000-objs := cfg80211.o netdev.o mon.o \
-			hif.o wlan_cfg.o wlan.o
+wilc-objs := cfg80211.o netdev.o mon.o \
+			hif.o wlan_cfg.o wlan.o sysfs.o power.o bt.o debugfs.o
 
-obj-$(CONFIG_WILC1000_SDIO) += wilc1000-sdio.o
-wilc1000-sdio-objs += sdio.o
+obj-$(CONFIG_WILC_SDIO) += wilc-sdio.o
+wilc-sdio-objs += $(wilc-objs)
+wilc-sdio-objs += sdio.o
 
-obj-$(CONFIG_WILC1000_SPI) += wilc1000-spi.o
-wilc1000-spi-objs += spi.o
+obj-$(CONFIG_WILC_SPI) += wilc-spi.o
+wilc-spi-objs += $(wilc-objs)
+wilc-spi-objs += spi.o
diff --git a/drivers/net/wireless/microchip/wilc1000/bt.c b/drivers/net/wireless/microchip/wilc1000/bt.c
new file mode 100644
index 00000000..48a5302
--- /dev/null
+++ b/drivers/net/wireless/microchip/wilc1000/bt.c
@@ -0,0 +1,697 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/firmware.h>
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+
+#include "netdev.h"
+
+static struct wilc *wilc_bt;
+static dev_t chc_dev_no; /* Global variable for the first device number */
+static struct cdev str_chc_dev; /* Global variable for the character */
+static struct device *dev;
+static struct class *chc_dev_class; /* Global variable for the device class */
+static bool device_created;
+static int bt_init_done;
+
+typedef void (wilc_cmd_handler)(char *);
+
+static void handle_cmd_bt_enable(char *param);
+static void handle_cmd_pwr_up(char *param);
+static void handle_cmd_pwr_down(char *param);
+static void handle_cmd_chip_wake_up(char *param);
+static void handle_cmd_chip_allow_sleep(char *param);
+static void handle_cmd_download_fw(char *param);
+static void handle_cmd_cca_thrshld(char *param);
+
+static void wilc_bt_firmware_download(struct wilc *);
+static void wilc_bt_start(struct wilc *);
+static int wilc_bt_dev_open(struct inode *i, struct file *f);
+static int wilc_bt_dev_close(struct inode *i, struct file *f);
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off);
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off);
+
+static const struct file_operations pugs_fops = {
+	.owner = THIS_MODULE,
+	.open = wilc_bt_dev_open,
+	.release = wilc_bt_dev_close,
+	.read = wilc_bt_dev_read,
+	.write = wilc_bt_dev_write
+};
+
+struct cmd_entry {
+	const char *str;
+	wilc_cmd_handler *wilc_handle_cmd;
+};
+
+static const struct cmd_entry cmd_table[] = {
+	{"BT_DOWNLOAD_FW", handle_cmd_download_fw},
+	{"BT_POWER_UP", handle_cmd_pwr_up},
+	{"BT_POWER_DOWN", handle_cmd_pwr_down},
+	{"BT_FW_CHIP_WAKEUP", handle_cmd_chip_wake_up},
+	{"BT_FW_CHIP_ALLOW_SLEEP", handle_cmd_chip_allow_sleep},
+	{"BT_ENABLE", handle_cmd_bt_enable},
+	{"CCA_THRESHOLD", handle_cmd_cca_thrshld},
+	/* Keep the NULL handler at the end of the table */
+	{(const char *)NULL, NULL},
+};
+
+static int wilc_bt_dev_open(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: open()\n");
+	return 0;
+}
+
+static int wilc_bt_dev_close(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: close()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off)
+{
+	pr_debug("at_pwr_dev: read()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off)
+{
+	struct cmd_entry *cmd;
+	char *usr_str;
+
+
+	if (len == 0) {
+		pr_debug("received invalid size <=0: %d\n", len);
+		return len;
+	}
+
+	usr_str = kmalloc(len, GFP_KERNEL);
+
+	if (copy_from_user(usr_str, buff, len))
+		return -EIO;
+
+	pr_debug("received %s, len %d\n", usr_str, len);
+	/* call the appropriate command handler */
+	cmd = (struct cmd_entry *)cmd_table;
+	while (cmd->wilc_handle_cmd != NULL) {
+		if (strncmp(cmd->str, usr_str, strlen(cmd->str)) == 0) {
+			pr_debug("param len: %d, string: %s\n",
+				 len - strlen(cmd->str), usr_str);
+			cmd->wilc_handle_cmd(usr_str + strlen(cmd->str));
+			break;
+		}
+		cmd++;
+	}
+
+	kfree(usr_str);
+	return len;
+}
+
+static void wilc_bt_create_device(void)
+{
+	int ret = 0;
+
+	if (device_created)
+		return;
+
+	ret = alloc_chrdev_region(&chc_dev_no, 0, 1, "atmel");
+	if (ret < 0)
+		return;
+	chc_dev_class = class_create(THIS_MODULE, "atmel");
+	if (IS_ERR(chc_dev_class)) {
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	dev = device_create(chc_dev_class, NULL, chc_dev_no, NULL,
+			    "wilc_bt");
+	if (IS_ERR(dev)) {
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+
+	cdev_init(&str_chc_dev, &pugs_fops);
+	ret = cdev_add(&str_chc_dev, chc_dev_no, 1);
+	if (ret < 0) {
+		device_destroy(chc_dev_class, chc_dev_no);
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	mutex_init(&wilc_bt->cs);
+	device_created = 1;
+}
+
+static void handle_cmd_cca_thrshld(char *param)
+{
+	int carrier_thrshld, noise_thrshld;
+	unsigned int carr_thrshld_frac, noise_thrshld_frac, carr_thrshld_int,
+		noise_thrshld_int, reg;
+
+	if (param == NULL) {
+		pr_err("Invalid parameter\n");
+		return;
+	}
+
+	if (sscanf(param, " %d %d", &noise_thrshld, &carrier_thrshld) != 2) {
+		pr_err("Failed to parse input parameters. Usage:\n");
+		pr_err("echo CCA_THRESHOLD NOISE_THRESHOLD CARRIER_THRESHOLD > /dev/at_pwr_dev\n");
+		pr_err("where threshold values are in dB * 10\n");
+		pr_err("e.g. echo CCA_THRESHOLD -625 -826 > /dev/at_pwr_dev to set thresholds to -62.5 and -82.6\n\n");
+		return;
+	}
+
+	pr_info("Changing CCA noise threshold to %d and carrier thresholds to %d\n",
+		noise_thrshld, carrier_thrshld);
+
+	carr_thrshld_int = carrier_thrshld/10;
+	if (carrier_thrshld < 0)
+		carr_thrshld_frac = (carr_thrshld_int * 10) - carrier_thrshld;
+	else
+		carr_thrshld_frac = carrier_thrshld - (carr_thrshld_int * 10);
+
+	noise_thrshld_int = noise_thrshld/10;
+	if (noise_thrshld < 0)
+		noise_thrshld_frac = (noise_thrshld_int * 10) - noise_thrshld;
+	else
+		noise_thrshld_frac = noise_thrshld - (noise_thrshld_int * 10);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_2, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((noise_thrshld_frac & 0x7) | ((noise_thrshld_int & 0x1FF)
+					      << 3)) << 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_2, reg);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_7, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((carr_thrshld_frac & 0x7) | ((carr_thrshld_int & 0x1FF) << 3))
+		<< 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_7, reg);
+}
+
+int wilc_bt_power_down(struct wilc *wilc, int source)
+{
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+	int ret;
+
+	if (source == DEV_BT) {
+		u32 reg;
+
+		pr_info("AT PWR: bt_power_down\n");
+
+		/* Adjust coexistence module. This should be done from the FW
+		 * in the future
+		 */
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Clear BT mode*/
+		reg &= ~BIT(1);
+		ret = hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       GLOBAL_MODE_CONTROL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+
+		/*TicketId1115*/
+		/*Disable awake coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_ON_NULL_PKT,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		/*TicketId1115*/
+		/*Disable doze coex null frames*/
+		ret = hif_func->hif_read_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = hif_func->hif_write_reg(wilc, COE_AUTO_PS_OFF_NULL_PKT,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		/* Disable BT wakeup */
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+		reg &= ~BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x\n",
+			       PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+			return ret;
+		}
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		bt_init_done = 0;
+	}
+
+	mutex_lock(&wilc->cs);
+
+	pr_info("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power.status[DEV_WIFI],
+		 wilc->power.status[DEV_BT]);
+
+	if (wilc->power.status[source] == false) {
+		pr_err("power down request for already powered down source %s\n",
+		       (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else if (((source == DEV_WIFI) &&
+		  (wilc->power.status[DEV_BT] == true)) ||
+		  ((source == DEV_BT) &&
+		  (wilc->power.status[DEV_WIFI] == true))) {
+		pr_warn("Another device is preventing power down. request source is %s\n",
+			(source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+		ret = wilc->hif_func->hif_deinit(wilc);
+		release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
+		if (ret) {
+			mutex_unlock(&wilc->cs);
+			return ret;
+		}
+	}
+	wilc->power.status[source] = false;
+
+	mutex_unlock(&wilc->cs);
+
+	return 0;
+}
+
+int wilc_bt_power_up(struct wilc *wilc, int source)
+{
+	int count = 0;
+	int ret;
+	int reg;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	mutex_lock(&wilc->cs);
+
+	pr_debug("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == DEV_WIFI ? "Wifi" : "BT"),
+		 wilc->power.status[DEV_WIFI],
+		 wilc->power.status[DEV_BT]);
+
+	if (wilc->power.status[source] == true) {
+		pr_err("power up request for already powered up source %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		/*Bug 215*/
+		/*Avoid overlapping between BT and Wifi intialization*/
+		if (wilc->power.status[DEV_WIFI] == true) {
+			while (!wilc->initialized) {
+				msleep(100);
+				if (++count > 20) {
+					pr_warn("Wifi initialize timeout\n");
+					break;
+				}
+			}
+		} else if (wilc->power.status[DEV_BT] == true) {
+			while (!bt_init_done) {
+				msleep(200);
+				if (++count > 30) {
+					pr_warn("BT initialize timeout\n");
+					break;
+				}
+			}
+			/* An additional wait to give BT firmware time to do
+			 * CPLL update as the time measured since the start of
+			 * BT Fw till the end of function "rf_nmi_init_tuner"
+			 * was 71.2 ms
+			 */
+			msleep(100);
+		}
+	}
+
+	if ((wilc->power.status[DEV_WIFI] == true) ||
+		   (wilc->power.status[DEV_BT] == true)) {
+		pr_info("Device already up. request source is %s\n",
+			 (source == DEV_WIFI ? "Wifi" : "BT"));
+	} else {
+		pr_info("WILC POWER UP\n");
+	}
+	wilc->power.status[source] = true;
+	mutex_unlock(&wilc->cs);
+
+	if (source == DEV_BT) {
+		/*TicketId1092*/
+		/*If WiFi is off, force BT*/
+		if (wilc->power.status[DEV_WIFI] == false) {
+			acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+			/*TicketId1115*/
+			/*Disable awake coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_ON_NULL_PKT,
+						     &reg);
+			if (ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_ON_NULL_PKT,
+						      reg);
+			if (ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+
+			/*TicketId1115*/
+			/*Disable doze coex null frames*/
+			ret = hif_func->hif_read_reg(wilc,
+						     COE_AUTO_PS_OFF_NULL_PKT,
+						     &reg);
+			if (ret) {
+				pr_err("[wilc start]: fail read reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = hif_func->hif_write_reg(wilc,
+						      COE_AUTO_PS_OFF_NULL_PKT,
+						      reg);
+			if (ret) {
+				pr_err("[wilc start]: fail write reg %x\n",
+				       COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+
+			release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		}
+
+		/* Enable BT wakeup */
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL,
+					     &reg);
+		if (ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+		reg |= BIT(29);
+		ret = hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL,
+					      reg);
+		if (ret) {
+			pr_err("[wilc start]: fail write reg %x ...\n",
+			       PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+	}
+
+	return 0;
+
+fail:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+	wilc_bt_power_down(wilc, DEV_BT);
+	return ret;
+}
+
+static void wilc_bt_firmware_download(struct wilc *wilc)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	const struct firmware *wilc_bt_firmware;
+	const u8 *buffer;
+	size_t buffer_size;
+	int ret = 0;
+	u32 reg;
+	const struct wilc_hif_func *hif_func;
+
+	hif_func = wilc->hif_func;
+
+	pr_info("Bluetooth firmware: %s\n", FW_WILC3000_BLE);
+	if (request_firmware(&wilc_bt_firmware, FW_WILC3000_BLE, dev) != 0) {
+		pr_err("%s - firmare not available. Skip!\n", FW_WILC3000_BLE);
+		ret = -1;
+		goto fail_1;
+	}
+
+	buffer = wilc_bt_firmware->data;
+	buffer_size = (size_t)wilc_bt_firmware->size;
+	if (buffer_size <= 0) {
+		pr_err("Firmware size = 0!\n");
+		ret = -1;
+		goto fail_1;
+	}
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	ret = hif_func->hif_write_reg(wilc, 0x4f0000, 0x71);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg 0x4f0000 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	/*
+	 * Avoid booting from BT boot ROM. Make sure that Drive IRQN
+	 * [SDIO platform] or SD_DAT3 [SPI platform] to ?1?
+	 */
+	/* Set cortus reset register to register control. */
+	ret = hif_func->hif_read_reg(wilc, 0x3b0090, &reg);
+	if (ret) {
+		pr_err("[wilc start]: fail read reg 0x3b0090 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	reg |= (1 << 0);
+	ret = hif_func->hif_write_reg(wilc, 0x3b0090, reg);
+	if (ret) {
+		pr_err("[wilc start]: fail write reg 0x3b0090 ...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+		goto fail_1;
+	}
+
+	hif_func->hif_read_reg(wilc, 0x3B0400, &reg);
+
+	if (reg & (1ul << 2)) {
+		reg &= ~(1ul << 2);
+	} else {
+		reg |= (1ul << 2);
+		hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+		reg &= ~(1ul << 2);
+	}
+	hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+	/* blocks of sizes > 512 causes the wifi to hang! */
+	blksz = (1ul << 9);
+	/* Allocate a DMA coherent  buffer. */
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (dma_buffer == NULL) {
+		ret = -5;
+		pr_err("Can't allocate buffer for BT firmware download IO error\n");
+		goto fail_1;
+	}
+	pr_info("Downloading BT firmware size = %d ...\n", buffer_size);
+
+	offset = 0;
+	addr = 0x400000;
+	size = buffer_size;
+	addr = cpu_to_le32(addr);
+	size = cpu_to_le32(size);
+	offset = 0;
+
+	while (((int)size) && (offset < buffer_size)) {
+		if (size <= blksz)
+			size2 = size;
+		else
+			size2 = blksz;
+
+		/* Copy firmware into a DMA coherent buffer */
+		memcpy(dma_buffer, &buffer[offset], size2);
+
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+		ret = hif_func->hif_block_tx(wilc, addr, dma_buffer, size2);
+
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+
+		if (ret)
+			break;
+
+		addr += size2;
+		offset += size2;
+		size -= size2;
+	}
+
+	if (ret) {
+		ret = -5;
+		pr_err("Can't download BT firmware IO error\n");
+		goto fail;
+	}
+
+fail:
+	kfree(dma_buffer);
+fail_1:
+	pr_debug("Freeing BT FW buffer ...\n");
+	pr_debug("Releasing BT firmware\n");
+	release_firmware(wilc_bt_firmware);
+}
+
+static void wilc_bt_start(struct wilc *wilc)
+{
+	u32 val32 = 0;
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_BT);
+
+	pr_info("Starting BT firmware\n");
+	/*
+	 * Write the firmware download complete magic value 0x10ADD09E at
+	 * location 0xFFFF000C (Cortus map) or C000C (AHB map).
+	 * This will let the boot-rom code execute from RAM.
+	 */
+	wilc->hif_func->hif_write_reg(wilc, 0x4F000c, 0x10add09e);
+
+	wilc->hif_func->hif_read_reg(wilc, 0x3B0400, &val32);
+	val32 &= ~((1ul << 2) | (1ul << 3));
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	msleep(100);
+
+	val32 |= ((1ul << 2) | (1ul << 3));
+
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	pr_info("BT Start Succeeded\n");
+
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_BT);
+}
+
+static void handle_cmd_pwr_up(char *param)
+{
+	pr_info("AT PWR: bt_power_up\n");
+	bt_init_done = 0;
+
+	if (!wilc_bt->initialized && !wilc_bt->hif_func->hif_is_init(wilc_bt)) {
+		acquire_bus(wilc_bt, WILC_BUS_ACQUIRE_ONLY, DEV_BT);
+		if (wilc_bt->hif_func->hif_init(wilc_bt, false)) {
+			release_bus(wilc_bt, WILC_BUS_RELEASE_ONLY, DEV_BT);
+			return;
+		}
+		release_bus(wilc_bt, WILC_BUS_RELEASE_ONLY, DEV_BT);
+	}
+
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_pwr_down(char *param)
+{
+	wilc_bt_power_down(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_wake_up(char *param)
+{
+	chip_wakeup(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_chip_allow_sleep(char *param)
+{
+	bt_init_done = 1;
+	chip_allow_sleep(wilc_bt, DEV_BT);
+}
+
+static void handle_cmd_download_fw(char *param)
+{
+	pr_info("AT PWR: bt_download_fw\n");
+
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+static void handle_cmd_bt_enable(char *param)
+{
+	wilc_bt_power_up(wilc_bt, DEV_BT);
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+void wilc_bt_init(struct wilc *wilc)
+{
+	wilc_bt = wilc;
+	pr_debug("at_pwr_dev: init\n");
+	wilc_bt_create_device();
+}
+
+void wilc_bt_deinit(void)
+{
+	pr_info("at_pwr_dev: deinit\n");
+
+	if (&wilc_bt->cs != NULL)
+		mutex_destroy(&wilc_bt->cs);
+
+	cdev_del(&str_chc_dev);
+	device_created = 0;
+	device_destroy(chc_dev_class, chc_dev_no);
+	class_destroy(chc_dev_class);
+	unregister_chrdev_region(chc_dev_no, 1);
+	pr_info("at_pwr_dev: unregistered\n");
+}
diff --git a/drivers/net/wireless/microchip/wilc1000/cfg80211.c b/drivers/net/wireless/microchip/wilc1000/cfg80211.c
index c1ac1d8..016aa06 100644
--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.c
+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.c
@@ -5,6 +5,7 @@
  */
 
 #include "cfg80211.h"
+#include "netdev.h"
 
 #define GO_NEG_REQ			0x00
 #define GO_NEG_RSP			0x01
@@ -20,9 +21,11 @@
 static const struct ieee80211_txrx_stypes
 	wilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = {
 	[NL80211_IFTYPE_STATION] = {
-		.tx = 0xffff,
+		.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		      BIT(IEEE80211_STYPE_AUTH >> 4),
 		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-			BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_AUTH >> 4),
 	},
 	[NL80211_IFTYPE_AP] = {
 		.tx = 0xffff,
@@ -43,7 +46,7 @@ static const struct ieee80211_txrx_stypes
 			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
 			BIT(IEEE80211_STYPE_AUTH >> 4) |
 			BIT(IEEE80211_STYPE_DEAUTH >> 4)
-	}
+	},
 };
 
 #ifdef CONFIG_PM
@@ -107,8 +110,10 @@ static void cfg_scan_result(enum scan_event scan_event,
 {
 	struct wilc_priv *priv = user_void;
 
-	if (!priv->cfg_scanning)
+	if (!priv || !priv->cfg_scanning) {
+		pr_err("%s is NULL\n", __func__);
 		return;
+	}
 
 	if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
 		s32 freq;
@@ -125,21 +130,30 @@ static void cfg_scan_result(enum scan_event scan_event,
 		if (!channel)
 			return;
 
+		PRINT_D(priv->dev, CFG80211_DBG,
+			"Network Info:: CHANNEL Frequency: %d, RSSI: %d,\n",
+			freq, ((s32)info->rssi * 100));
+
 		bss = cfg80211_inform_bss_frame(wiphy, channel, info->mgmt,
 						info->frame_len,
 						(s32)info->rssi * 100,
 						GFP_KERNEL);
-		if (!bss)
-			cfg80211_put_bss(wiphy, bss);
+		cfg80211_put_bss(wiphy, bss);
 	} else if (scan_event == SCAN_EVENT_DONE) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Done[%p]\n",
+			   priv->dev);
 		mutex_lock(&priv->scan_req_lock);
 
 		if (priv->scan_req) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 			struct cfg80211_scan_info info = {
 				.aborted = false,
 			};
 
 			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
 			priv->cfg_scanning = false;
 			priv->scan_req = NULL;
 		}
@@ -147,12 +161,18 @@ static void cfg_scan_result(enum scan_event scan_event,
 	} else if (scan_event == SCAN_EVENT_ABORTED) {
 		mutex_lock(&priv->scan_req_lock);
 
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Aborted\n");
 		if (priv->scan_req) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 			struct cfg80211_scan_info info = {
 				.aborted = false,
 			};
 
 			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
+
 			priv->cfg_scanning = false;
 			priv->scan_req = NULL;
 		}
@@ -169,13 +189,18 @@ static void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,
 	struct wilc *wl = vif->wilc;
 	struct host_if_drv *wfi_drv = priv->hif_drv;
 	struct wilc_conn_info *conn_info = &wfi_drv->conn_info;
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 	struct wiphy *wiphy = dev->ieee80211_ptr->wiphy;
+#endif
 
 	vif->connecting = false;
 
 	if (conn_disconn_evt == CONN_DISCONN_EVENT_CONN_RESP) {
 		u16 connect_status = conn_info->status;
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connection response received=%d connect_stat[%d]\n",
+			   mac_status, connect_status);
 		if (mac_status == WILC_MAC_STATUS_DISCONNECTED &&
 		    connect_status == WLAN_STATUS_SUCCESS) {
 			connect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;
@@ -187,10 +212,23 @@ static void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,
 			netdev_err(dev, "Unspecified failure\n");
 		}
 
-		if (connect_status == WLAN_STATUS_SUCCESS)
+		if (connect_status == WLAN_STATUS_SUCCESS) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Connection Successful: BSSID: %x%x%x%x%x%x\n",
+				   conn_info->bssid[0], conn_info->bssid[1],
+				   conn_info->bssid[2], conn_info->bssid[3],
+				   conn_info->bssid[4], conn_info->bssid[5]);
 			memcpy(priv->associated_bss, conn_info->bssid,
 			       ETH_ALEN);
+		}
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association request info elements length = %d\n",
+			   conn_info->req_ies_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association response info elements length = %d\n",
+			   conn_info->resp_ies_len);
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
 		cfg80211_ref_bss(wiphy, vif->bss);
 		cfg80211_connect_bss(dev, conn_info->bssid, vif->bss,
 				     conn_info->req_ies,
@@ -199,11 +237,29 @@ static void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,
 				     conn_info->resp_ies_len,
 				     connect_status, GFP_KERNEL,
 				     NL80211_TIMEOUT_UNSPECIFIED);
-
+#elif KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+		cfg80211_ref_bss(wiphy, vif->bss);
+		cfg80211_connect_bss(dev, conn_info->bssid, vif->bss,
+				     conn_info->req_ies,
+				     conn_info->req_ies_len,
+				     conn_info->resp_ies,
+				     conn_info->resp_ies_len,
+				     connect_status, GFP_KERNEL);
+#else
+		cfg80211_connect_result(dev, conn_info->bssid,
+					conn_info->req_ies,
+					conn_info->req_ies_len,
+					conn_info->resp_ies,
+					conn_info->resp_ies_len, connect_status,
+					GFP_KERNEL);
+#endif
 		vif->bss = NULL;
 	} else if (conn_disconn_evt == CONN_DISCONN_EVENT_DISCONN_NOTIF) {
 		u16 reason = 0;
 
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Received WILC_MAC_STATUS_DISCONNECTED dev [%p]\n",
+			   priv->dev);
 		eth_zero_addr(priv->associated_bss);
 		wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
@@ -215,8 +271,11 @@ static void cfg_connect_result(enum conn_event conn_disconn_evt, u8 mac_status,
 			else
 				reason = 1;
 		}
-
+#if KERNEL_VERSION(4, 2, 0) > LINUX_VERSION_CODE
+		cfg80211_disconnected(dev, reason, NULL, 0, GFP_KERNEL);
+#else
 		cfg80211_disconnected(dev, reason, NULL, 0, false, GFP_KERNEL);
+#endif
 	}
 }
 
@@ -248,11 +307,15 @@ static int set_channel(struct wiphy *wiphy,
 	}
 
 	channelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting channel %d with frequency %d\n",
+		   channelnum, chandef->chan->center_freq);
 
 	wl->op_ch = channelnum;
 	result = wilc_set_mac_chnl_num(vif, channelnum);
 	if (result)
-		netdev_err(vif->ndev, "Error in setting channel\n");
+		netdev_err(vif->ndev, "Error in setting channel %d\n",
+			   channelnum);
 
 	srcu_read_unlock(&wl->srcu, srcu_idx);
 	return result;
@@ -278,8 +341,21 @@ static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
 		u16 freq = request->channels[i]->center_freq;
 
 		scan_ch_list[i] = ieee80211_frequency_to_channel(freq);
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"ScanChannel List[%d] = %d",
+			i, scan_ch_list[i]);
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Requested num of channel %d\n",
+		   request->n_channels);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Scan Request IE len =  %d\n",
+		   request->ie_len);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Number of SSIDs %d\n",
+		   request->n_ssids);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Trigger Scan Request\n");
+
 	if (request->n_ssids)
 		scan_type = WILC_FW_ACTIVE_SCAN;
 	else
@@ -292,6 +368,8 @@ static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
 	if (ret) {
 		priv->scan_req = NULL;
 		priv->cfg_scanning = false;
+		PRINT_WRN(vif->ndev, CFG80211_DBG,
+			  "Device is busy: Error(%d)\n", ret);
 	}
 
 	return ret;
@@ -306,6 +384,7 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 	int ret;
 	u32 i;
 	u8 security = WILC_FW_SEC_NO;
+	enum mfptype mfp_type = WILC_FW_MFP_NONE;
 	enum authtype auth_type = WILC_FW_AUTH_ANY;
 	u32 cipher_group;
 	struct cfg80211_bss *bss;
@@ -314,32 +393,41 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 
 	vif->connecting = true;
 
-	memset(priv->wep_key, 0, sizeof(priv->wep_key));
-	memset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Connecting to SSID [%s] on netdev [%p] host if [%x]\n",
+		   sme->ssid, dev, (u32)priv->hif_drv);
+
+	if (sme->auth_type == NL80211_AUTHTYPE_SAE &&
+	    vif->wilc->chip == WILC_3000){
+		pr_err("WILC3000: WPA3 not supported\n");
+		ret = -ENOTSUPP;
+		goto out_error;
+	}
+
+	if (vif->iftype == WILC_CLIENT_MODE)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connected to Direct network,OBSS disabled\n");
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required SSID= %s\n, AuthType= %d\n",
+		sme->ssid, sme->auth_type);
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.wpa_versions=%x\n",
+		sme->crypto.wpa_versions);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.cipher_group=%x\n",
+		sme->crypto.cipher_group);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.n_ciphers_pairwise=%d\n",
+		sme->crypto.n_ciphers_pairwise);
+	for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)
+		PRINT_D(vif->ndev, CORECONFIG_DBG,
+			"sme->crypto.ciphers_pairwise[%d]=%x\n", i,
+			sme->crypto.ciphers_pairwise[i]);
 
 	cipher_group = sme->crypto.cipher_group;
 	if (cipher_group != 0) {
-		if (cipher_group == WLAN_CIPHER_SUITE_WEP40) {
-			security = WILC_FW_SEC_WEP;
-
-			priv->wep_key_len[sme->key_idx] = sme->key_len;
-			memcpy(priv->wep_key[sme->key_idx], sme->key,
-			       sme->key_len);
-
-			wilc_set_wep_default_keyid(vif, sme->key_idx);
-			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
-						 sme->key_idx);
-		} else if (cipher_group == WLAN_CIPHER_SUITE_WEP104) {
-			security = WILC_FW_SEC_WEP_EXTENDED;
-
-			priv->wep_key_len[sme->key_idx] = sme->key_len;
-			memcpy(priv->wep_key[sme->key_idx], sme->key,
-			       sme->key_len);
-
-			wilc_set_wep_default_keyid(vif, sme->key_idx);
-			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
-						 sme->key_idx);
-		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   ">> sme->crypto.wpa_versions: %x\n",
+			   sme->crypto.wpa_versions);
+		if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2) {
 			if (cipher_group == WLAN_CIPHER_SUITE_TKIP)
 				security = WILC_FW_SEC_WPA2_TKIP;
 			else
@@ -369,22 +457,49 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 		}
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding key with cipher group %x\n",
+		   cipher_group);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Authentication Type = %d\n",
+		   sme->auth_type);
 	switch (sme->auth_type) {
 	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In OPEN SYSTEM\n");
 		auth_type = WILC_FW_AUTH_OPEN_SYSTEM;
 		break;
 
-	case NL80211_AUTHTYPE_SHARED_KEY:
-		auth_type = WILC_FW_AUTH_SHARED_KEY;
+	case NL80211_AUTHTYPE_SAE:
+		auth_type = WILC_FW_AUTH_SAE;
+		if (sme->ssid_len) {
+			memcpy(vif->auth.ssid.ssid, sme->ssid, sme->ssid_len);
+			vif->auth.ssid.ssid_len = sme->ssid_len;
+		}
+		vif->auth.key_mgmt_suite = cpu_to_be32(sme->crypto.akm_suites[0]);
+		ether_addr_copy(vif->auth.bssid, sme->bssid);
+		pr_debug("%s: external SAE processing: bss=%pM action=%u akm=%u len[%d]\n",
+			 __func__, sme->bssid, vif->auth.action,
+			 vif->auth.key_mgmt_suite, sme->crypto.sae_pwd_len);
 		break;
-
 	default:
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Automatic Authentication type= %d\n",
+			   sme->auth_type);
 		break;
 	}
 
 	if (sme->crypto.n_akm_suites) {
-		if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X)
+		if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG, "AUTH IEEE802.1X\n");
 			auth_type = WILC_FW_AUTH_IEEE8021;
+		} else if (sme->crypto.akm_suites[0] ==
+			   WLAN_AKM_SUITE_PSK_SHA256) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG, "AUTH WPA-PSK-SHA256\n");
+			auth_type = WILC_FW_AUTH_OPEN_SYSTEM_SHA256;
+		} else if (sme->crypto.akm_suites[0] ==
+			   WLAN_AKM_SUITE_8021X_SHA256) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG, "AUTH IEEE802.1X-SHA256\n");
+			auth_type = WILC_FW_AUTH_IEE8021X_SHA256;
+		}
 	}
 
 	if (wfi_drv->usr_scan_req.scan_result) {
@@ -393,9 +508,15 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 		goto out_error;
 	}
 
+#if KERNEL_VERSION(4, 1, 0) > LINUX_VERSION_CODE
+	bss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid, sme->ssid,
+			       sme->ssid_len, WLAN_CAPABILITY_ESS,
+			       WLAN_CAPABILITY_ESS);
+#else
 	bss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid, sme->ssid,
 			       sme->ssid_len, IEEE80211_BSS_TYPE_ANY,
 			       IEEE80211_PRIVACY(sme->privacy));
+#endif
 	if (!bss) {
 		ret = -EINVAL;
 		goto out_error;
@@ -405,6 +526,15 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 		ret = -EALREADY;
 		goto out_put_bss;
 	}
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Set MFP Type %d", sme->mfp);
+
+	if (sme->mfp == NL80211_MFP_OPTIONAL) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "MFP Type Optional");
+		mfp_type = WILC_FW_MFP_OPTIONAL;
+	} else if (sme->mfp == NL80211_MFP_REQUIRED) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "MFP Type Required");
+		mfp_type = WILC_FW_MFP_REQUIRED;
+	}
 
 	join_params = wilc_parse_join_bss_param(bss, &sme->crypto);
 	if (!join_params) {
@@ -415,6 +545,7 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 	}
 
 	ch = ieee80211_frequency_to_channel(bss->channel->center_freq);
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required Channel = %d\n", ch);
 	vif->wilc->op_ch = ch;
 	if (vif->iftype != WILC_CLIENT_MODE)
 		vif->wilc->sta_ch = ch;
@@ -427,6 +558,7 @@ static int connect(struct wiphy *wiphy, struct net_device *dev,
 	wfi_drv->conn_info.conn_result = cfg_connect_result;
 	wfi_drv->conn_info.arg = priv;
 	wfi_drv->conn_info.param = join_params;
+	wfi_drv->conn_info.mfp_type = mfp_type;
 
 	ret = wilc_set_join_req(vif, bss->bssid, sme->ie, sme->ie_len);
 	if (ret) {
@@ -458,24 +590,21 @@ static int disconnect(struct wiphy *wiphy, struct net_device *dev,
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc *wilc = vif->wilc;
+	struct host_if_drv *wfi_drv;
 	int ret;
 
 	vif->connecting = false;
 
 	if (!wilc)
 		return -EIO;
-
-	if (wilc->close) {
-		/* already disconnected done */
-		cfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);
-		return 0;
-	}
-
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
 	if (vif->iftype != WILC_CLIENT_MODE)
 		wilc->sta_ch = WILC_INVALID_CHANNEL;
 	wilc_wlan_set_bssid(priv->dev, NULL, WILC_STATION_MODE);
 
-	priv->hif_drv->p2p_timeout = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Disconnecting with reason code(%d)\n", reason_code);
+	wfi_drv->p2p_timeout = 0;
 
 	ret = wilc_disconnect(vif);
 	if (ret != 0) {
@@ -488,14 +617,6 @@ static int disconnect(struct wiphy *wiphy, struct net_device *dev,
 	return ret;
 }
 
-static inline void wilc_wfi_cfg_copy_wep_info(struct wilc_priv *priv,
-					      u8 key_index,
-					      struct key_params *params)
-{
-	priv->wep_key_len[key_index] = params->key_len;
-	memcpy(priv->wep_key[key_index], params->key, params->key_len);
-}
-
 static int wilc_wfi_cfg_allocate_wpa_entry(struct wilc_priv *priv, u8 idx)
 {
 	if (!priv->wilc_gtk[idx]) {
@@ -515,6 +636,19 @@ static int wilc_wfi_cfg_allocate_wpa_entry(struct wilc_priv *priv, u8 idx)
 	return 0;
 }
 
+static int wilc_wfi_cfg_allocate_wpa_igtk_entry(struct wilc_priv *priv, u8 idx)
+{
+	idx -= 4;
+	if (!priv->wilc_igtk[idx]) {
+		priv->wilc_igtk[idx] = kzalloc(sizeof(*priv->wilc_igtk[idx]),
+					       GFP_KERNEL);
+		if (!priv->wilc_igtk[idx])
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
 static int wilc_wfi_cfg_copy_wpa_info(struct wilc_wfi_key *key_info,
 				      struct key_params *params)
 {
@@ -544,42 +678,23 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 		   bool pairwise, const u8 *mac_addr, struct key_params *params)
 
 {
-	int ret = 0, keylen = params->key_len;
+	int ret = 0, keylen = params->key_len, seqlen = params->seq_len;
 	const u8 *rx_mic = NULL;
 	const u8 *tx_mic = NULL;
 	u8 mode = WILC_FW_SEC_NO;
 	u8 op_mode;
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
-
+	struct wilc_wfi_key *key;
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Adding key with cipher suite = %x\n", params->cipher);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "%x %x %d\n", (u32)wiphy,
+		   (u32)netdev, key_index);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "key %x %x %x\n", params->key[0],
+		   params->key[1],
+		   params->key[2]);
 	switch (params->cipher) {
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		if (priv->wdev.iftype == NL80211_IFTYPE_AP) {
-			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
-
-			if (params->cipher == WLAN_CIPHER_SUITE_WEP40)
-				mode = WILC_FW_SEC_WEP;
-			else
-				mode = WILC_FW_SEC_WEP_EXTENDED;
-
-			ret = wilc_add_wep_key_bss_ap(vif, params->key,
-						      params->key_len,
-						      key_index, mode,
-						      WILC_FW_AUTH_OPEN_SYSTEM);
-			break;
-		}
-		if (memcmp(params->key, priv->wep_key[key_index],
-			   params->key_len)) {
-			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
-
-			ret = wilc_add_wep_key_bss_sta(vif, params->key,
-						       params->key_len,
-						       key_index);
-		}
-
-		break;
-
 	case WLAN_CIPHER_SUITE_TKIP:
 	case WLAN_CIPHER_SUITE_CCMP:
 		if (priv->wdev.iftype == NL80211_IFTYPE_AP ||
@@ -607,6 +722,10 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 
 				key = priv->wilc_gtk[key_index];
 			} else {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"STA Address: %x%x%x%x%x\n",
+					mac_addr[0], mac_addr[1], mac_addr[2],
+					mac_addr[3], mac_addr[4]);
 				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
 					mode = WILC_FW_SEC_WPA_TKIP;
 				else
@@ -642,6 +761,28 @@ static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 
 		break;
 
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		ret = wilc_wfi_cfg_allocate_wpa_igtk_entry(priv, key_index);
+		if (ret)
+			return -ENOMEM;
+
+		key = priv->wilc_igtk[key_index - 4];
+
+		ret = wilc_wfi_cfg_copy_wpa_info(key, params);
+		if (ret)
+			return -ENOMEM;
+
+		if (priv->wdev.iftype == NL80211_IFTYPE_AP ||
+		    priv->wdev.iftype == NL80211_IFTYPE_P2P_GO)
+			op_mode = WILC_AP_MODE;
+		else
+			op_mode = WILC_STATION_MODE;
+
+		ret = wilc_add_igtk(vif, params->key, keylen, params->seq,
+				    seqlen, mac_addr, op_mode, key_index);
+
+		break;
+
 	default:
 		netdev_err(netdev, "%s: Unsupported cipher\n", __func__);
 		ret = -ENOTSUPP;
@@ -655,36 +796,41 @@ static int del_key(struct wiphy *wiphy, struct net_device *netdev,
 		   bool pairwise,
 		   const u8 *mac_addr)
 {
+	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
 
-	if (priv->wilc_gtk[key_index]) {
-		kfree(priv->wilc_gtk[key_index]->key);
-		priv->wilc_gtk[key_index]->key = NULL;
-		kfree(priv->wilc_gtk[key_index]->seq);
-		priv->wilc_gtk[key_index]->seq = NULL;
-
-		kfree(priv->wilc_gtk[key_index]);
-		priv->wilc_gtk[key_index] = NULL;
-	}
-
-	if (priv->wilc_ptk[key_index]) {
-		kfree(priv->wilc_ptk[key_index]->key);
-		priv->wilc_ptk[key_index]->key = NULL;
-		kfree(priv->wilc_ptk[key_index]->seq);
-		priv->wilc_ptk[key_index]->seq = NULL;
-		kfree(priv->wilc_ptk[key_index]);
-		priv->wilc_ptk[key_index] = NULL;
-	}
+	if (!pairwise && (key_index == 4 || key_index == 5)) {
+		key_index -= 4;
+		if (priv->wilc_igtk[key_index]) {
+			kfree(priv->wilc_igtk[key_index]->key);
+			priv->wilc_igtk[key_index]->key = NULL;
+			kfree(priv->wilc_igtk[key_index]->seq);
+			priv->wilc_igtk[key_index]->seq = NULL;
+			kfree(priv->wilc_igtk[key_index]);
+			priv->wilc_igtk[key_index] = NULL;
+		}
+	} else {
+		if (priv->wilc_gtk[key_index]) {
+			kfree(priv->wilc_gtk[key_index]->key);
+			priv->wilc_gtk[key_index]->key = NULL;
+			kfree(priv->wilc_gtk[key_index]->seq);
+			priv->wilc_gtk[key_index]->seq = NULL;
+			kfree(priv->wilc_gtk[key_index]);
+			priv->wilc_gtk[key_index] = NULL;
+		}
 
-	if (key_index <= 3 && priv->wep_key_len[key_index]) {
-		memset(priv->wep_key[key_index], 0,
-		       priv->wep_key_len[key_index]);
-		priv->wep_key_len[key_index] = 0;
-		wilc_remove_wep_key(vif, key_index);
+		if (priv->wilc_ptk[key_index]) {
+			kfree(priv->wilc_ptk[key_index]->key);
+			priv->wilc_ptk[key_index]->key = NULL;
+			kfree(priv->wilc_ptk[key_index]->seq);
+			priv->wilc_ptk[key_index]->seq = NULL;
+			kfree(priv->wilc_ptk[key_index]);
+			priv->wilc_ptk[key_index] = NULL;
+		}
 	}
 
-	return 0;
+	return ret;
 }
 
 static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
@@ -696,12 +842,27 @@ static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 	struct  key_params key_params;
 
 	if (!pairwise) {
-		key_params.key = priv->wilc_gtk[key_index]->key;
-		key_params.cipher = priv->wilc_gtk[key_index]->cipher;
-		key_params.key_len = priv->wilc_gtk[key_index]->key_len;
-		key_params.seq = priv->wilc_gtk[key_index]->seq;
-		key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
+		if (key_index == 4 || key_index == 5) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Getting integrity group key idx: %x\n",
+				   key_index);
+			key_index -= 4;
+			key_params.key = priv->wilc_igtk[key_index]->key;
+			key_params.cipher = priv->wilc_igtk[key_index]->cipher;
+			key_params.key_len = priv->wilc_igtk[key_index]->key_len;
+			key_params.seq = priv->wilc_igtk[key_index]->seq;
+			key_params.seq_len = priv->wilc_igtk[key_index]->seq_len;
+		} else {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Getting group key idx: %x\n", key_index);
+			key_params.key = priv->wilc_gtk[key_index]->key;
+			key_params.cipher = priv->wilc_gtk[key_index]->cipher;
+			key_params.key_len = priv->wilc_gtk[key_index]->key_len;
+			key_params.seq = priv->wilc_gtk[key_index]->seq;
+			key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
+		}
 	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting pairwise key\n");
 		key_params.key = priv->wilc_ptk[key_index]->key;
 		key_params.cipher = priv->wilc_ptk[key_index]->cipher;
 		key_params.key_len = priv->wilc_ptk[key_index]->key_len;
@@ -714,26 +875,37 @@ static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
 	return 0;
 }
 
+/* wiphy_new() will WARN if not present*/
 static int set_default_key(struct wiphy *wiphy, struct net_device *netdev,
 			   u8 key_index, bool unicast, bool multicast)
 {
-	struct wilc_vif *vif = netdev_priv(netdev);
-
-	wilc_set_wep_default_keyid(vif, key_index);
-
 	return 0;
 }
 
+static int set_default_mgmt_key (struct wiphy *wiphy,struct net_device *netdev,
+				 u8 key_index)
+{
+    return 0;
+}
+
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int get_station(struct wiphy *wiphy, struct net_device *dev,
 		       const u8 *mac, struct station_info *sinfo)
+#else
+static int get_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_info *sinfo)
+#endif
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
+	struct wilc *wilc = vif->wilc;
 	u32 i = 0;
 	u32 associatedsta = ~0;
 	u32 inactive_time = 0;
 
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Getting station parameters\n");
 		for (i = 0; i < NUM_STA_ASSOCIATED; i++) {
 			if (!(memcmp(mac,
 				     priv->assoc_stainfo.sta_associated_bss[i],
@@ -748,21 +920,39 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 			return -ENOENT;
 		}
 
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME);
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+		sinfo->filled |= BIT(NL80211_STA_INFO_INACTIVE_TIME);
+#else
+		sinfo->filled |= STATION_INFO_INACTIVE_TIME;
+#endif
 
 		wilc_get_inactive_time(vif, mac, &inactive_time);
 		sinfo->inactive_time = 1000 * inactive_time;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Inactive time %d\n",
+			   sinfo->inactive_time);
 	} else if (vif->iftype == WILC_STATION_MODE) {
 		struct rf_info stats;
 
-		wilc_get_statistics(vif, &stats);
-
-		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL) |
-				 BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |
-				 BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |
-				 BIT_ULL(NL80211_STA_INFO_TX_FAILED) |
-				 BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+		if (!wilc->initialized) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "driver not initialized\n");
+			return -EBUSY;
+		}
 
+		wilc_get_statistics(vif, &stats);
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL) |
+			      BIT(NL80211_STA_INFO_RX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_FAILED) |
+			      BIT(NL80211_STA_INFO_TX_BITRATE);
+#else
+		sinfo->filled |= STATION_INFO_SIGNAL |
+			      STATION_INFO_RX_PACKETS |
+			      STATION_INFO_TX_PACKETS |
+			      STATION_INFO_TX_FAILED |
+			      STATION_INFO_TX_BITRATE;
+#endif
 		sinfo->signal = stats.rssi;
 		sinfo->rx_packets = stats.rx_cnt;
 		sinfo->tx_packets = stats.tx_cnt + stats.tx_fail_cnt;
@@ -774,6 +964,11 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 			wilc_enable_tcp_ack_filter(vif, true);
 		else if (stats.link_speed != DEFAULT_LINK_SPEED)
 			wilc_enable_tcp_ack_filter(vif, false);
+
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "*** stats[%d][%d][%d][%d][%d]\n", sinfo->signal,
+			   sinfo->rx_packets, sinfo->tx_packets,
+			   sinfo->tx_failed, sinfo->txrate.legacy);
 	}
 	return 0;
 }
@@ -781,6 +976,7 @@ static int get_station(struct wiphy *wiphy, struct net_device *dev,
 static int change_bss(struct wiphy *wiphy, struct net_device *dev,
 		      struct bss_parameters *params)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Changing Bss parametrs\n");
 	return 0;
 }
 
@@ -799,7 +995,9 @@ static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
 		goto out;
 
 	priv = &vif->priv;
+
 	cfg_param_val.flag = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting Wiphy params\n");
 
 	if (changed & WIPHY_PARAM_RETRY_SHORT) {
 		netdev_dbg(vif->ndev,
@@ -843,6 +1041,8 @@ static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
 		}
 	}
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting CFG params in the host interface\n");
 	ret = wilc_hif_set_cfg(vif, &cfg_param_val);
 	if (ret)
 		netdev_err(priv->dev, "Error in setting WIPHY PARAMS\n");
@@ -861,14 +1061,20 @@ static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 	int ret = 0;
 	u8 flag = 0;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting PMKSA\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
 			flag = PMKID_FOUND;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "PMKID already exists\n");
 			break;
 		}
 	}
 	if (i < WILC_MAX_NUM_PMKIDS) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting PMKID in private structure\n");
 		memcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,
 		       ETH_ALEN);
 		memcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,
@@ -880,9 +1086,11 @@ static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 		ret = -EINVAL;
 	}
 
-	if (!ret)
+	if (!ret) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting pmkid in the host interface\n");
 		ret = wilc_set_pmkid_info(vif, &priv->pmkid_list);
-
+	}
 	return ret;
 }
 
@@ -893,9 +1101,13 @@ static int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
 	struct wilc_vif *vif = netdev_priv(netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Deleting PMKSA keys\n");
+
 	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
 		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
 			    ETH_ALEN)) {
+			PRINT_INFO(netdev, CFG80211_DBG,
+				   "Resetting PMKID values\n");
 			memset(&priv->pmkid_list.pmkidlist[i], 0,
 			       sizeof(struct wilc_pmkid));
 			break;
@@ -922,11 +1134,31 @@ static int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)
 {
 	struct wilc_vif *vif = netdev_priv(netdev);
 
+	PRINT_INFO(netdev, CFG80211_DBG, "Flushing  PMKID key values\n");
 	memset(&vif->priv.pmkid_list, 0, sizeof(struct wilc_pmkid_attr));
 
 	return 0;
 }
 
+static inline void wilc_wfi_cfg_parse_p2p_intent_attr(u8 *buf, u32 len,
+						      bool p2p_mode)
+{
+	struct wilc_attr_entry *e;
+	u32 index = 0;
+
+	while (index + sizeof(*e) <= len) {
+		e = (struct wilc_attr_entry *)&buf[index];
+		if (e->attr_type == IEEE80211_P2P_ATTR_GO_INTENT) {
+			if (p2p_mode == WILC_P2P_ROLE_GO)
+				e->val[0] = (e->val[0]  & 0x01) | (0x0f << 1);
+			else
+				e->val[0] = (e->val[0]  & 0x01) | (0x00 << 1);
+			return;
+		}
+		index += le16_to_cpu(e->attr_len) + sizeof(*e);
+	}
+}
+
 static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32 len, u8 sta_ch)
 {
 	struct wilc_attr_entry *e;
@@ -974,7 +1206,25 @@ static inline void wilc_wfi_cfg_parse_ch_attr(u8 *buf, u32 len, u8 sta_ch)
 	}
 }
 
-void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
+bool wilc_wfi_mgmt_frame_rx(struct wilc_vif *vif, u8 *buff, u32 size)
+{
+	struct wilc *wl = vif->wilc;
+	struct wilc_priv *priv = &vif->priv;
+	int freq, ret;
+
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+	freq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);
+ #else
+	freq = ieee80211_channel_to_frequency(wl->op_ch, IEEE80211_BAND_2GHZ);
+ #endif
+	PRINT_D(vif->ndev, GENERIC_DBG, "%s Frame Type:%x\n", __func__,
+		((struct ieee80211_mgmt *)buff)->frame_control);
+
+	ret = cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
+	return ret;
+}
+
+bool wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 {
 	struct wilc *wl = vif->wilc;
 	struct wilc_priv *priv = &vif->priv;
@@ -986,6 +1236,7 @@ void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 	const u8 *vendor_ie;
 	u32 header, pkt_offset;
 	s32 freq;
+	int ret;
 
 	header = get_unaligned_le32(buff - HOST_HDR_OFFSET);
 	pkt_offset = FIELD_GET(WILC_PKT_HDR_OFFSET_FIELD, header);
@@ -1000,25 +1251,34 @@ void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 
 		cfg80211_mgmt_tx_status(&priv->wdev, priv->tx_cookie, buff,
 					size, ack, GFP_KERNEL);
-		return;
+		return true;
 	}
 
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 	freq = ieee80211_channel_to_frequency(wl->op_ch, NL80211_BAND_2GHZ);
-
+ #else
+	freq = ieee80211_channel_to_frequency(wl->op_ch, IEEE80211_BAND_2GHZ);
+ #endif
 	mgmt = (struct ieee80211_mgmt *)buff;
+	PRINT_D(vif->ndev, GENERIC_DBG, "Rx Frame Type:%x\n",
+		mgmt->frame_control);
 	if (!ieee80211_is_action(mgmt->frame_control))
 		goto out_rx_mgmt;
 
 	if (priv->cfg_scanning &&
 	    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {
 		netdev_dbg(vif->ndev, "Receiving action wrong ch\n");
-		return;
+		return false;
 	}
 
 	if (!ieee80211_is_public_action((struct ieee80211_hdr *)buff, size))
 		goto out_rx_mgmt;
 
 	d = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		"Rx Action action: %x category %x oui type %x sub_type[%d]\n",
+		d->action, d->category, d->oui_type, d->oui_subtype);
+
 	if (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&
 	    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
 		goto out_rx_mgmt;
@@ -1029,10 +1289,16 @@ void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 		goto out_rx_mgmt;
 
 	p = (struct wilc_vendor_specific_ie *)vendor_ie;
+	/* use p2p mode invert value to treat other p2p device
+	 * opposite of mode set on this device.
+	 */
+	wilc_wfi_cfg_parse_p2p_intent_attr(p->attr, p->tag_len - 4,
+					   !vif->wilc->attr_sysfs.p2p_mode);
 	wilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);
 
 out_rx_mgmt:
-	cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
+	ret = cfg80211_rx_mgmt(&priv->wdev, freq, 0, buff, size, 0);
+	return ret;
 }
 
 static void wilc_wfi_mgmt_tx_complete(void *priv, int status)
@@ -1049,12 +1315,16 @@ static void wilc_wfi_remain_on_channel_expired(void *data, u64 cookie)
 	struct wilc_priv *priv = &vif->priv;
 	struct wilc_wfi_p2p_listen_params *params = &priv->remain_on_ch_params;
 
-	if (cookie != params->listen_cookie)
+	if (cookie != priv->remain_on_ch_params.listen_cookie) {
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "Received cookies didn't match received[%llu] Expected[%llu]\n",
+			   cookie, priv->remain_on_ch_params.listen_cookie);
 		return;
+	}
 
-	priv->p2p_listen_state = false;
+	vif->p2p_listen_state = false;
 
-	cfg80211_remain_on_channel_expired(&priv->wdev, params->listen_cookie,
+	cfg80211_remain_on_channel_expired(&vif->priv.wdev, cookie,
 					   params->listen_ch, GFP_KERNEL);
 }
 
@@ -1088,13 +1358,21 @@ static int remain_on_channel(struct wiphy *wiphy,
 	priv->remain_on_ch_params.listen_ch = chan;
 	priv->remain_on_ch_params.listen_cookie = id;
 	*cookie = id;
-	priv->p2p_listen_state = true;
+	vif->p2p_listen_state = true;
 	priv->remain_on_ch_params.listen_duration = duration;
 
 	cfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);
+
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	vif->hif_drv->remain_on_ch_timer.data = (unsigned long)vif->hif_drv;
+#endif
 	mod_timer(&vif->hif_drv->remain_on_ch_timer,
 		  jiffies + msecs_to_jiffies(duration + 1000));
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Remaining on duration [%d] [%llu] op_ch[%d]\n",
+		   duration, priv->remain_on_ch_params.listen_cookie,
+		   vif->wilc->op_ch);
 	return ret;
 }
 
@@ -1105,21 +1383,34 @@ static int cancel_remain_on_channel(struct wiphy *wiphy,
 	struct wilc_vif *vif = netdev_priv(wdev->netdev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "cookie received[%llu] expected[%llu]\n",
+		   cookie, priv->remain_on_ch_params.listen_cookie);
 	if (cookie != priv->remain_on_ch_params.listen_cookie)
 		return -ENOENT;
 
 	return wilc_listen_state_expired(vif, cookie);
 }
 
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 static int mgmt_tx(struct wiphy *wiphy,
 		   struct wireless_dev *wdev,
 		   struct cfg80211_mgmt_tx_params *params,
 		   u64 *cookie)
+#else
+static int mgmt_tx(struct wiphy *wiphy,
+		   struct wireless_dev *wdev,
+		   struct ieee80211_channel *chan, bool offchan,
+		   unsigned int wait, const u8 *buf, size_t len,
+		   bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#endif
 {
+#if KERNEL_VERSION(3, 14, 0) <= LINUX_VERSION_CODE
 	struct ieee80211_channel *chan = params->chan;
 	unsigned int wait = params->wait;
 	const u8 *buf = params->buf;
 	size_t len = params->len;
+#endif
 	const struct ieee80211_mgmt *mgmt;
 	struct wilc_p2p_mgmt_data *mgmt_tx;
 	struct wilc_vif *vif = netdev_priv(wdev->netdev);
@@ -1135,18 +1426,26 @@ static int mgmt_tx(struct wiphy *wiphy,
 	priv->tx_cookie = *cookie;
 	mgmt = (const struct ieee80211_mgmt *)buf;
 
-	if (!ieee80211_is_mgmt(mgmt->frame_control))
+	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "This function transmits only management frames\n");
 		goto out;
+	}
 
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_KERNEL);
 	if (!mgmt_tx) {
-		ret = -ENOMEM;
-		goto out;
+		PRINT_ER(vif->ndev,
+			 "%s failed to allocate memory for structure\n",
+			 __func__);
+		return -ENOMEM;
 	}
 
 	mgmt_tx->buff = kmemdup(buf, len, GFP_KERNEL);
 	if (!mgmt_tx->buff) {
 		ret = -ENOMEM;
+		PRINT_ER(vif->ndev,
+			 "%s Failed to allocate memory buff\n",
+			 __func__);
 		kfree(mgmt_tx);
 		goto out;
 	}
@@ -1154,22 +1453,37 @@ static int mgmt_tx(struct wiphy *wiphy,
 	mgmt_tx->size = len;
 
 	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "TX: Probe Response\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
 		wilc_set_mac_chnl_num(vif, chan->hw_value);
 		vif->wilc->op_ch = chan->hw_value;
 		goto out_txq_add_pkt;
 	}
 
-	if (!ieee80211_is_public_action((struct ieee80211_hdr *)buf, len))
+	if (!ieee80211_is_public_action((struct ieee80211_hdr *)buf, len)) {
+		if (chan)
+			wilc_set_mac_chnl_num(vif, chan->hw_value);
+		else
+			wilc_set_mac_chnl_num(vif, vif->wilc->op_ch);
+
 		goto out_set_timeout;
+	}
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "ACTION FRAME:%x\n",
+		   (u16)mgmt->frame_control);
 
 	d = (struct wilc_p2p_pub_act_frame *)(&mgmt->u.action);
 	if (d->oui_type != WLAN_OUI_TYPE_WFA_P2P ||
 	    d->oui_subtype != GO_NEG_CONF) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
 		wilc_set_mac_chnl_num(vif, chan->hw_value);
 		vif->wilc->op_ch = chan->hw_value;
 	}
 
-	if (d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
+	if (d->oui_subtype != GO_NEG_REQ && d->oui_subtype != GO_NEG_RSP &&
+	    d->oui_subtype != P2P_INV_REQ && d->oui_subtype != P2P_INV_RSP)
 		goto out_set_timeout;
 
 	vendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,
@@ -1179,14 +1493,27 @@ static int mgmt_tx(struct wiphy *wiphy,
 		goto out_set_timeout;
 
 	p = (struct wilc_vendor_specific_ie *)vendor_ie;
-	wilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4, vif->wilc->sta_ch);
-
+	wilc_wfi_cfg_parse_p2p_intent_attr(p->attr, p->tag_len - 4,
+					   vif->wilc->attr_sysfs.p2p_mode);
+	/*
+	 * Update only the go_intent value and don't modify the channel list
+	 * attributes values for GO_REQ and GO_Response to retain
+	 * previous logic.  For mgmt_tx only INVITATION_REQ and INVITATION_RES
+	 * frame update the channel list attribute.
+	 */
+
+	if (d->oui_subtype == P2P_INV_REQ && d->oui_subtype == P2P_INV_RSP)
+		wilc_wfi_cfg_parse_ch_attr(p->attr, p->tag_len - 4,
+					   vif->wilc->sta_ch);
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "TX: ACTION FRAME Type:%x : Chan:%d\n", d->action,
+		   chan->hw_value);
 out_set_timeout:
 	wfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
 
 out_txq_add_pkt:
-
-	wilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,
+	wilc_wlan_txq_add_mgmt_pkt(priv->wdev.netdev, mgmt_tx,
 				   mgmt_tx->buff, mgmt_tx->size,
 				   wilc_wfi_mgmt_tx_complete);
 
@@ -1205,7 +1532,7 @@ static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
 
 	wfi_drv->p2p_timeout = jiffies;
 
-	if (!priv->p2p_listen_state) {
+	if (!vif->p2p_listen_state) {
 		struct wilc_wfi_p2p_listen_params *params;
 
 		params = &priv->remain_on_ch_params;
@@ -1219,6 +1546,7 @@ static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
 	return 0;
 }
 
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 void wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
 					  struct mgmt_frame_regs *upd)
@@ -1227,6 +1555,7 @@ void wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,
 	struct wilc_vif *vif = netdev_priv(wdev->netdev);
 	u32 presp_bit = BIT(IEEE80211_STYPE_PROBE_REQ >> 4);
 	u32 action_bit = BIT(IEEE80211_STYPE_ACTION >> 4);
+	u32 pauth_bit = BIT(IEEE80211_STYPE_AUTH >> 4);
 
 	if (wl->initialized) {
 		bool prev = vif->mgmt_reg_stypes & presp_bit;
@@ -1240,15 +1569,63 @@ void wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,
 
 		if (now != prev)
 			wilc_frame_register(vif, IEEE80211_STYPE_ACTION, now);
+		prev = vif->mgmt_reg_stypes & pauth_bit;
+		now = upd->interface_stypes & pauth_bit;
+		if (now != prev) {
+			pr_err("%s setup authframe\n", __func__);
+			wilc_frame_register(vif, IEEE80211_STYPE_AUTH, now);
+		}
 	}
 
 	vif->mgmt_reg_stypes =
-		upd->interface_stypes & (presp_bit | action_bit);
+		upd->interface_stypes & (presp_bit | action_bit | pauth_bit);
 }
+#else
+void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
+			      u16 frame_type, bool reg)
+{
+	struct wilc *wl = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(wdev->netdev);
+
+	if (!frame_type)
+		return;
+
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		"Frame registering Frame Type: %x: Boolean: %d\n", frame_type,
+		reg);
+
+	switch (frame_type) {
+	case IEEE80211_STYPE_PROBE_REQ:
+		vif->frame_reg[0].type = frame_type;
+		vif->frame_reg[0].reg = reg;
+		break;
+
+	case IEEE80211_STYPE_ACTION:
+		vif->frame_reg[1].type = frame_type;
+		vif->frame_reg[1].reg = reg;
+		break;
+	case IEEE80211_STYPE_AUTH:
+		vif->frame_reg[2].type = frame_type;
+		vif->frame_reg[2].reg = reg;
+		break;
+
+	default:
+		break;
+	}
+
+	if (!wl->initialized) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Return since mac is closed\n");
+		return;
+	}
+	wilc_frame_register(vif, frame_type, reg);
+}
+#endif
 
 static int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,
 			       s32 rssi_thold, u32 rssi_hyst)
 {
+	PRINT_INFO(dev, CFG80211_DBG, "Setting CQM RSSi Function\n");
 	return 0;
 }
 
@@ -1261,13 +1638,18 @@ static int dump_station(struct wiphy *wiphy, struct net_device *dev,
 	if (idx != 0)
 		return -ENOENT;
 
-	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Dumping station information\n");
 
 	ret = wilc_get_rssi(vif, &sinfo->signal);
 	if (ret)
 		return ret;
 
-	memcpy(mac, vif->priv.associated_bss, ETH_ALEN);
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
+	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+#else
+	sinfo->filled |= STATION_INFO_SIGNAL;
+#endif
+
 	return 0;
 }
 
@@ -1277,25 +1659,45 @@ static int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 
-	if (!priv->hif_drv)
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "dev [%s]\n", dev->name);
+	if (!priv->hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -EIO;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   " Power save Enabled= %d , TimeOut = %d\n", enabled,
+		   timeout);
 
 	wilc_set_power_mgmt(vif, enabled, timeout);
 
 	return 0;
 }
 
+#if KERNEL_VERSION(4, 11, 0) <= LINUX_VERSION_CODE
 static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 			       enum nl80211_iftype type,
 			       struct vif_params *params)
+#else
+static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
+			       enum nl80211_iftype type, u32 *flags,
+			       struct vif_params *params)
+#endif
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
 
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "In Change virtual interface function\n");
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "Wireless interface name =%s\n", dev->name);
+
 	switch (type) {
 	case NL80211_IFTYPE_STATION:
 		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_STATION\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->monitor_flag = 0;
@@ -1313,6 +1715,8 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 
 	case NL80211_IFTYPE_P2P_CLIENT:
 		vif->connecting = false;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_P2P_CLIENT\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->monitor_flag = 0;
@@ -1324,6 +1728,8 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 		break;
 
 	case NL80211_IFTYPE_AP:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_AP\n");
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->iftype = WILC_AP_MODE;
@@ -1334,6 +1740,10 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 		break;
 
 	case NL80211_IFTYPE_P2P_GO:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_GO\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "start duringIP timer\n");
+
 		dev->ieee80211_ptr->iftype = type;
 		priv->wdev.iftype = type;
 		vif->iftype = WILC_GO_MODE;
@@ -1342,6 +1752,18 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
 						WILC_AP_MODE, vif->idx);
 		break;
+	case NL80211_IFTYPE_MONITOR:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_MONITOR\n");
+		dev->ieee80211_ptr->iftype = type;
+		dev->type = ARPHRD_IEEE80211_RADIOTAP;
+		priv->wdev.iftype = type;
+		vif->iftype = WILC_MONITOR_MODE;
+
+		if (wl->initialized)
+			wilc_set_operation_mode(vif, wilc_get_vif_idx(vif),
+						WILC_MONITOR_MODE, vif->idx);
+		break;
 
 	default:
 		netdev_err(dev, "Unknown interface type= %d\n", type);
@@ -1354,10 +1776,21 @@ static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
 static int start_ap(struct wiphy *wiphy, struct net_device *dev,
 		    struct cfg80211_ap_settings *settings)
 {
-	struct wilc_vif *vif = netdev_priv(dev);
 	int ret;
+	struct wilc_vif *vif = netdev_priv(dev);
+	int freq = settings->chandef.chan->center_freq;
+	int channelnum = ieee80211_frequency_to_channel(freq);
+
+	pr_info("%s,dev[%s]\n", __func__, dev->name);
+
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Starting ap\n");
 
-	ret = set_channel(wiphy, &settings->chandef);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Interval= %d\n DTIM period= %d\n Head length= %d Tail length= %d channelnum[%d]\n",
+		   settings->beacon_interval, settings->dtim_period,
+		   settings->beacon.head_len, settings->beacon.tail_len,
+		   channelnum);
+	ret = wilc_set_mac_chnl_num(vif, channelnum);
 	if (ret != 0)
 		netdev_err(dev, "Error in setting channel\n");
 
@@ -1372,6 +1805,8 @@ static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Setting beacon\n");
+
 	return wilc_add_beacon(vif, 0, 0, beacon);
 }
 
@@ -1380,6 +1815,8 @@ static int stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	int ret;
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting beacon\n");
+
 	wilc_wlan_set_bssid(dev, NULL, WILC_AP_MODE);
 
 	ret = wilc_del_beacon(vif);
@@ -1390,18 +1827,59 @@ static int stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int add_station(struct wiphy *wiphy, struct net_device *dev,
 		       const u8 *mac, struct station_parameters *params)
+#else
+static int add_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_parameters *params)
+#endif
 {
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
+	u8 *assoc_bss = priv->assoc_stainfo.sta_associated_bss[params->aid];
 
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
-		memcpy(priv->assoc_stainfo.sta_associated_bss[params->aid], mac,
-		       ETH_ALEN);
+		memcpy(assoc_bss, mac, ETH_ALEN);
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding station parameters %d\n", params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			   assoc_bss[0], assoc_bss[1], assoc_bss[2],
+			   assoc_bss[3], assoc_bss[4], assoc_bss[5]);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG, "ASSOC ID = %d\n",
+			   params->aid);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Number of supported rates = %d\n",
+			   params->supported_rates_len);
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   (!params->ht_capa) ? false : true);
+
+		if (params->ht_capa) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Capability Info = %d\n",
+				   params->ht_capa->cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "AMPDU Params = %d\n",
+				   params->ht_capa->ampdu_params_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "HT Extended params= %d\n",
+				   params->ht_capa->extended_ht_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Tx Beamforming Cap= %d\n",
+				   params->ht_capa->tx_BF_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Antenna selection info = %d\n",
+				   params->ht_capa->antenna_selection_info);
+		}
 
-		ret = wilc_add_station(vif, mac, params);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   params->sta_flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   params->sta_flags_set);
+		ret = wilc_add_station(vif, (const u8 *)mac, params);
 		if (ret)
 			netdev_err(dev, "Host add station fail\n");
 	}
@@ -1409,10 +1887,20 @@ static int add_station(struct wiphy *wiphy, struct net_device *dev,
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 static int del_station(struct wiphy *wiphy, struct net_device *dev,
 		       struct station_del_parameters *params)
+#elif KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       const u8 *mac)
+#else
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac)
+#endif
 {
+#if KERNEL_VERSION(3, 19, 0) <= LINUX_VERSION_CODE
 	const u8 *mac = params->mac;
+#endif
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc_priv *priv = &vif->priv;
@@ -1421,10 +1909,19 @@ static int del_station(struct wiphy *wiphy, struct net_device *dev,
 	if (!(vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE))
 		return ret;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting station\n");
+
 	info = &priv->assoc_stainfo;
 
-	if (!mac)
+	if (!mac) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "All associated stations\n");
 		ret = wilc_del_allstation(vif, info->sta_associated_bss);
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "With mac address: %x%x%x%x%x%x\n",
+			   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	}
 
 	ret = wilc_del_station(vif, mac);
 	if (ret)
@@ -1432,21 +1929,58 @@ static int del_station(struct wiphy *wiphy, struct net_device *dev,
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 16, 0) <= LINUX_VERSION_CODE
 static int change_station(struct wiphy *wiphy, struct net_device *dev,
 			  const u8 *mac, struct station_parameters *params)
+#else
+static int change_station(struct wiphy *wiphy, struct net_device *dev,
+			  u8 *mac, struct station_parameters *params)
+#endif
 {
 	int ret = 0;
 	struct wilc_vif *vif = netdev_priv(dev);
 
+	PRINT_D(vif->ndev, CFG80211_DBG, "Change station parameters\n");
+
 	if (vif->iftype == WILC_AP_MODE || vif->iftype == WILC_GO_MODE) {
-		ret = wilc_edit_station(vif, mac, params);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "ASSOC ID = %d\n",
+			   params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Number of supported rates = %d\n",
+			   params->supported_rates_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   (!params->ht_capa) ? false : true);
+		if (params->ht_capa) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Capability Info = %d\n",
+				   params->ht_capa->cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "AMPDU Params = %d\n",
+				   params->ht_capa->ampdu_params_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "HT Extended params= %d\n",
+				   params->ht_capa->extended_ht_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Tx Beamforming Cap= %d\n",
+				   params->ht_capa->tx_BF_cap_info);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Antenna selection info = %d\n",
+				   params->ht_capa->antenna_selection_info);
+		}
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   params->sta_flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   params->sta_flags_set);
+		ret = wilc_edit_station(vif, (const u8 *)mac, params);
 		if (ret)
 			netdev_err(dev, "Host edit station fail\n");
 	}
 	return ret;
 }
 
-static struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)
 {
 	struct wilc_vif *vif;
 
@@ -1458,17 +1992,43 @@ static struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type)
 	return NULL;
 }
 
+#if KERNEL_VERSION(4, 12, 0) <= LINUX_VERSION_CODE
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     unsigned char name_assign_type,
+					     enum nl80211_iftype type,
+					     struct vif_params *params)
+#elif KERNEL_VERSION(4, 1, 0) <= LINUX_VERSION_CODE
 static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 					     const char *name,
 					     unsigned char name_assign_type,
 					     enum nl80211_iftype type,
+					     u32 *flags,
 					     struct vif_params *params)
+#elif KERNEL_VERSION(3, 7, 0) <= LINUX_VERSION_CODE
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#else
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#endif
 {
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
 	struct wireless_dev *wdev;
-	int iftype;
+	u8 iftype;
 
+	/* check if interface type is mointor because AP mode is supported over
+	 * monitor interface. No need to increment interface count check if
+	 * monitor mode is associated with AP interface. The same approach is
+	 * applied with p2p_device interface
+	 */
 	if (type == NL80211_IFTYPE_MONITOR) {
 		struct net_device *ndev;
 		int srcu_idx;
@@ -1487,15 +2047,19 @@ static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 			srcu_read_unlock(&wl->srcu, srcu_idx);
 			goto validate_interface;
 		}
-
-		ndev = wilc_wfi_init_mon_interface(wl, name, vif->ndev);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Initializing mon ifc virtual device driver\n");
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding monitor interface[%p]\n", vif->ndev);
+		ndev = wilc_wfi_init_mon_interface(vif->wilc, name, vif->ndev);
 		if (ndev) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Setting monitor flag in private structure\n");
 			vif->monitor_flag = 1;
 		} else {
-			srcu_read_unlock(&wl->srcu, srcu_idx);
-			return ERR_PTR(-EINVAL);
+			PRINT_ER(vif->ndev,
+				 "Error in initializing monitor interface\n");
 		}
-
 		wdev = &vif->priv.wdev;
 		srcu_read_unlock(&wl->srcu, srcu_idx);
 		return wdev;
@@ -1510,6 +2074,9 @@ static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 	}
 	mutex_unlock(&wl->vif_mutex);
 
+	pr_info("add_interaface [%d] name[%s] type[%d]\n", wl->vif_num,
+		name, type);
+
 	switch (type) {
 	case NL80211_IFTYPE_STATION:
 		iftype = WILC_STATION_MODE;
@@ -1517,13 +2084,16 @@ static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
 	case NL80211_IFTYPE_AP:
 		iftype = WILC_AP_MODE;
 		break;
+	case NL80211_IFTYPE_MONITOR:
+		iftype = WILC_MONITOR_MODE;
+		break;
 	default:
 		return ERR_PTR(-EOPNOTSUPP);
 	}
 
 	vif = wilc_netdev_ifc_init(wl, name, iftype, type, true);
 	if (IS_ERR(vif))
-		return ERR_CAST(vif);
+		return ERR_PTR(-EINVAL);
 
 	return &vif->priv.wdev;
 }
@@ -1533,16 +2103,22 @@ static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
 	struct wilc *wl = wiphy_priv(wiphy);
 	struct wilc_vif *vif;
 
+	/* delete the monitor mode interface */
+	if (wdev->iftype == NL80211_IFTYPE_MONITOR) {
+		wilc_wfi_deinit_mon_interface(wl, true);
+		return 0;
+	}
+	/* delete the AP monitor mode interface */
 	if (wdev->iftype == NL80211_IFTYPE_AP ||
 	    wdev->iftype == NL80211_IFTYPE_P2P_GO)
 		wilc_wfi_deinit_mon_interface(wl, true);
 	vif = netdev_priv(wdev->netdev);
-	cfg80211_stop_iface(wiphy, wdev, GFP_KERNEL);
 	unregister_netdevice(vif->ndev);
 	vif->monitor_flag = 0;
 
-	wilc_set_operation_mode(vif, 0, 0, 0);
+	/* update the vif list */
 	mutex_lock(&wl->vif_mutex);
+	/* delete the interface from rcu list */
 	list_del_rcu(&vif->list);
 	wl->vif_num--;
 	mutex_unlock(&wl->vif_mutex);
@@ -1552,13 +2128,6 @@ static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
 
 static int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
 {
-	struct wilc *wl = wiphy_priv(wiphy);
-
-	if (!wow && wilc_wlan_get_num_conn_ifcs(wl))
-		wl->suspend_event = true;
-	else
-		wl->suspend_event = false;
-
 	return 0;
 }
 
@@ -1581,6 +2150,7 @@ static void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)
 	}
 
 	netdev_info(vif->ndev, "cfg set wake up = %d\n", enabled);
+	wilc_set_wowlan_trigger(vif, enabled);
 	srcu_read_unlock(&wl->srcu, srcu_idx);
 }
 
@@ -1603,7 +2173,7 @@ static int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
 		return -EINVAL;
 	}
 
-	netdev_info(vif->ndev, "Setting tx power %d\n", tx_power);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting tx power %d\n", tx_power);
 	if (tx_power < 0)
 		tx_power = 0;
 	else if (tx_power > 18)
@@ -1626,11 +2196,56 @@ static int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
 	/* If firmware is not started, return. */
 	if (!wl->initialized)
 		return -EIO;
-
+	*dbm = 0;
 	ret = wilc_get_tx_power(vif, (u8 *)dbm);
 	if (ret)
 		netdev_err(vif->ndev, "Failed to get tx power\n");
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Got tx power %d\n", *dbm);
+
+	return ret;
+}
+
+static int set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
+{
+	int ret;
+	struct wilc *wl = wiphy_priv(wiphy);
+	struct wilc_vif *vif;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&wl->srcu);
+	vif = wilc_get_wl_to_vif(wl);
+	if (IS_ERR(vif)) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Select antenna mode %d\n", tx_ant);
+	if (!tx_ant || !rx_ant) {
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		return -EINVAL;
+	}
+
+	ret = wilc_set_antenna(vif, (u8)(tx_ant-1));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set tx antenna\n");
+	srcu_read_unlock(&wl->srcu, srcu_idx);
+
+	return ret;
+}
+
+static int external_auth(struct wiphy *wiphy, struct net_device *dev,
+			 struct cfg80211_external_auth_params *auth)
+{
+	int ret = 0;
+	struct wilc_vif *vif = netdev_priv(dev);
+
+	pr_debug("%s bssid: %pM", __func__, auth->bssid);
+	if (auth->status == WLAN_STATUS_SUCCESS)
+		wilc_set_external_auth_param(vif, auth);
+	else
+		pr_err("%s failed [%d]\n", __func__, auth->status);
+
 	return ret;
 }
 
@@ -1643,6 +2258,7 @@ static const struct cfg80211_ops wilc_cfg80211_ops = {
 	.del_key = del_key,
 	.get_key = get_key,
 	.set_default_key = set_default_key,
+	.set_default_mgmt_key = set_default_mgmt_key,
 	.add_virtual_intf = add_virtual_intf,
 	.del_virtual_intf = del_virtual_intf,
 	.change_virtual_intf = change_virtual_intf,
@@ -1658,6 +2274,7 @@ static const struct cfg80211_ops wilc_cfg80211_ops = {
 	.change_bss = change_bss,
 	.set_wiphy_params = set_wiphy_params,
 
+	.external_auth = external_auth,
 	.set_pmksa = set_pmksa,
 	.del_pmksa = del_pmksa,
 	.flush_pmksa = flush_pmksa,
@@ -1665,7 +2282,11 @@ static const struct cfg80211_ops wilc_cfg80211_ops = {
 	.cancel_remain_on_channel = cancel_remain_on_channel,
 	.mgmt_tx_cancel_wait = mgmt_tx_cancel_wait,
 	.mgmt_tx = mgmt_tx,
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 	.update_mgmt_frame_registrations = wilc_update_mgmt_frame_registrations,
+#else
+	.mgmt_frame_register = wilc_mgmt_frame_register,
+#endif
 	.set_power_mgmt = set_power_mgmt,
 	.set_cqm_rssi_config = set_cqm_rssi_config,
 
@@ -1674,15 +2295,18 @@ static const struct cfg80211_ops wilc_cfg80211_ops = {
 	.set_wakeup = wilc_set_wakeup,
 	.set_tx_power = set_tx_power,
 	.get_tx_power = get_tx_power,
-
+	.set_antenna = set_antenna,
 };
 
 static void wlan_init_locks(struct wilc *wl)
 {
+	pr_info("Initializing Locks ...\n");
 	mutex_init(&wl->hif_cs);
 	mutex_init(&wl->rxq_cs);
 	mutex_init(&wl->cfg_cmd_lock);
 	mutex_init(&wl->vif_mutex);
+	mutex_init(&wl->deinit_lock);
+	mutex_init(&wl->cs);
 
 	spin_lock_init(&wl->txq_spinlock);
 	mutex_init(&wl->txq_add_to_head_cs);
@@ -1691,29 +2315,35 @@ static void wlan_init_locks(struct wilc *wl)
 	init_completion(&wl->cfg_event);
 	init_completion(&wl->sync_event);
 	init_completion(&wl->txq_thread_started);
+	init_completion(&wl->debug_thread_started);
 	init_srcu_struct(&wl->srcu);
 }
 
 void wlan_deinit_locks(struct wilc *wilc)
 {
+	pr_info("De-Initializing Locks\n");
 	mutex_destroy(&wilc->hif_cs);
 	mutex_destroy(&wilc->rxq_cs);
 	mutex_destroy(&wilc->cfg_cmd_lock);
 	mutex_destroy(&wilc->txq_add_to_head_cs);
 	mutex_destroy(&wilc->vif_mutex);
+	mutex_destroy(&wilc->cs);
+	mutex_destroy(&wilc->deinit_lock);
 	cleanup_srcu_struct(&wilc->srcu);
 }
 
 int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
 		       const struct wilc_hif_func *ops)
 {
+	int i, ret;
 	struct wilc *wl;
 	struct wilc_vif *vif;
-	int ret;
 
 	wl = wilc_create_wiphy(dev);
-	if (!wl)
+	if (!wl) {
+		pr_err("failed to create wiphy\n");
 		return -EINVAL;
+	}
 
 	wlan_init_locks(wl);
 
@@ -1721,41 +2351,46 @@ int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
 	if (ret)
 		goto free_wl;
 
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_init();
+#endif
 	*wilc = wl;
 	wl->io_type = io_type;
 	wl->hif_func = ops;
-	wl->chip_ps_state = WILC_CHIP_WAKEDUP;
-	INIT_LIST_HEAD(&wl->txq_head.list);
+	for (i = 0; i < NQUEUES; i++)
+		INIT_LIST_HEAD(&wl->txq[i].txq_head.list);
+
 	INIT_LIST_HEAD(&wl->rxq_head.list);
 	INIT_LIST_HEAD(&wl->vif_list);
 
 	wl->hif_workqueue = create_singlethread_workqueue("WILC_wq");
 	if (!wl->hif_workqueue) {
 		ret = -ENOMEM;
-		goto free_cfg;
+		goto free_debug_fs;
 	}
 	vif = wilc_netdev_ifc_init(wl, "wlan%d", WILC_STATION_MODE,
 				   NL80211_IFTYPE_STATION, false);
 	if (IS_ERR(vif)) {
 		ret = PTR_ERR(vif);
-		goto free_hq;
+		goto free_wq;
 	}
 
-	return 0;
+	wilc_sysfs_init(wl);
 
-free_hq:
+	return 0;
+free_wq:
 	destroy_workqueue(wl->hif_workqueue);
-
-free_cfg:
+free_debug_fs:
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_remove();
+#endif
 	wilc_wlan_cfg_deinit(wl);
-
 free_wl:
 	wlan_deinit_locks(wl);
 	wiphy_unregister(wl->wiphy);
 	wiphy_free(wl->wiphy);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(wilc_cfg80211_init);
 
 struct wilc *wilc_create_wiphy(struct device *dev)
 {
@@ -1764,10 +2399,13 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 	int ret;
 
 	wiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(*wl));
-	if (!wiphy)
+	if (!wiphy) {
+		pr_err("wiphy new allocate failed\n");
 		return NULL;
+	}
 
 	wl = wiphy_priv(wiphy);
+	pr_info("Registering wifi device\n");
 
 	memcpy(wl->bitrates, wilc_bitrates, sizeof(wilc_bitrates));
 	memcpy(wl->channels, wilc_2ghz_channels, sizeof(wilc_2ghz_channels));
@@ -1782,11 +2420,19 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 	wl->band.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;
 	wl->band.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
 
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
 	wiphy->bands[NL80211_BAND_2GHZ] = &wl->band;
+#else
+	wiphy->bands[IEEE80211_BAND_2GHZ] = &wl->band;
+#endif
 
 	wiphy->max_scan_ssids = WILC_MAX_NUM_PROBED_SSID;
 #ifdef CONFIG_PM
+#if KERNEL_VERSION(3, 11, 0) <= LINUX_VERSION_CODE
 	wiphy->wowlan = &wowlan_support;
+#else
+	wiphy->wowlan = wowlan_support;
+#endif
 #endif
 	wiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;
 	wiphy->max_scan_ie_len = 1000;
@@ -1795,6 +2441,8 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 	       sizeof(wilc_cipher_suites));
 	wiphy->cipher_suites = wl->cipher_suites;
 	wiphy->n_cipher_suites = ARRAY_SIZE(wilc_cipher_suites);
+	wiphy->available_antennas_tx = 0x3;
+	wiphy->available_antennas_rx = 0x3;
 	wiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;
 
 	wiphy->max_remain_on_channel_duration = 500;
@@ -1804,11 +2452,16 @@ struct wilc *wilc_create_wiphy(struct device *dev)
 				BIT(NL80211_IFTYPE_P2P_GO) |
 				BIT(NL80211_IFTYPE_P2P_CLIENT);
 	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->features |= NL80211_FEATURE_SAE;
+	pr_info("Max scan ids= %d,Max scan IE len= %d,Signal Type= %d,Interface Modes= %d\n",
+		wiphy->max_scan_ssids, wiphy->max_scan_ie_len,
+		wiphy->signal_type, wiphy->interface_modes);
 
 	set_wiphy_dev(wiphy, dev);
 	wl->wiphy = wiphy;
 	ret = wiphy_register(wiphy);
 	if (ret) {
+		pr_err("Cannot register wiphy device\n");
 		wiphy_free(wiphy);
 		return NULL;
 	}
@@ -1821,7 +2474,15 @@ int wilc_init_host_int(struct net_device *net)
 	struct wilc_vif *vif = netdev_priv(net);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p_listen_state = false;
+	PRINT_INFO(net, INIT_DBG, "Host[%p][%p]\n", net, net->ieee80211_ptr);
+
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	timer_setup(&priv->eap_buff_timer, eap_buff_timeout, 0);
+#else
+	setup_timer(&priv->eap_buff_timer, eap_buff_timeout, 0);
+#endif
+
+	vif->p2p_listen_state = false;
 
 	mutex_init(&priv->scan_req_lock);
 	ret = wilc_init(net, &priv->hif_drv);
@@ -1837,12 +2498,14 @@ void wilc_deinit_host_int(struct net_device *net)
 	struct wilc_vif *vif = netdev_priv(net);
 	struct wilc_priv *priv = &vif->priv;
 
-	priv->p2p_listen_state = false;
+	vif->p2p_listen_state = false;
 
 	flush_workqueue(vif->wilc->hif_workqueue);
 	mutex_destroy(&priv->scan_req_lock);
 	ret = wilc_deinit(vif);
 
+	del_timer_sync(&priv->eap_buff_timer);
+
 	if (ret)
 		netdev_err(net, "Error while deinitializing host interface\n");
 }
diff --git a/drivers/net/wireless/microchip/wilc1000/cfg80211.h b/drivers/net/wireless/microchip/wilc1000/cfg80211.h
index 37b294c..212a769 100644
--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.h
+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.h
@@ -8,23 +8,27 @@
 #define WILC_CFG80211_H
 #include "netdev.h"
 
-struct wiphy *wilc_cfg_alloc(void);
 int wilc_cfg80211_init(struct wilc **wilc, struct device *dev, int io_type,
 		       const struct wilc_hif_func *ops);
 struct wilc *wilc_create_wiphy(struct device *dev);
 void wilc_deinit_host_int(struct net_device *net);
 int wilc_init_host_int(struct net_device *net);
 void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size);
-struct wilc_vif *wilc_netdev_interface(struct wilc *wl, const char *name,
-				       enum nl80211_iftype type);
 void wilc_wfi_deinit_mon_interface(struct wilc *wl, bool rtnl_locked);
 struct net_device *wilc_wfi_init_mon_interface(struct wilc *wl,
 					       const char *name,
 					       struct net_device *real_dev);
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 void wilc_update_mgmt_frame_registrations(struct wiphy *wiphy,
 					  struct wireless_dev *wdev,
 					  struct mgmt_frame_regs *upd);
-struct wilc_vif *wilc_get_interface(struct wilc *wl);
+#else
+void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
+			      u16 frame_type, bool reg);
+#endif
+void wilc_sysfs_init(struct wilc *wilc);
+void wilc_sysfs_exit(void);
+struct wilc_vif *wilc_get_vif_from_type(struct wilc *wl, int type);
 struct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl);
 void wlan_deinit_locks(struct wilc *wilc);
 #endif
diff --git a/drivers/net/wireless/microchip/wilc1000/debugfs.c b/drivers/net/wireless/microchip/wilc1000/debugfs.c
new file mode 100644
index 00000000..132066f
--- /dev/null
+++ b/drivers/net/wireless/microchip/wilc1000/debugfs.c
@@ -0,0 +1,426 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include "debugfs.h"
+
+atomic_t WILC_DEBUG_REGION = ATOMIC_INIT(INIT_DBG | GENERIC_DBG |
+					 CFG80211_DBG | HOSTAPD_DBG |
+					 PWRDEV_DBG);
+#if KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
+/**
+ * of_irq_parse_raw - Low level interrupt tree parsing
+ * @parent:	the device interrupt parent
+ * @addr:	address specifier (start of "reg" property of the device)
+ *              in be32 format
+ * @out_irq:	structure of_irq updated by this function
+ *
+ * Returns 0 on success and a negative number on error
+ *
+ * This function is a low-level interrupt tree walking function. It
+ * can be used to do a partial walk with synthetized reg and interrupts
+ * properties, for example when resolving PCI interrupts when no device
+ * node exist for the parent. It takes an interrupt specifier structure as
+ * input, walks the tree looking for any interrupt-map properties, translates
+ * the specifier for each map, and then returns the translated map.
+ */
+int of_irq_parse_raw(const __be32 *addr, struct of_phandle_args *out_irq)
+{
+	struct device_node *ipar, *tnode, *old = NULL, *newpar = NULL;
+	__be32 initial_match_array[MAX_PHANDLE_ARGS];
+	const __be32 *match_array = initial_match_array;
+	const __be32 *tmp, *imap, *imask;
+	const __be32 dummy_imask[] = { [0 ... MAX_PHANDLE_ARGS] = ~0 };
+	u32 intsize = 1, addrsize, newintsize = 0, newaddrsize = 0;
+	int imaplen, match, i;
+
+#ifdef DEBUG
+	of_print_phandle_args("of_irq_parse_raw: ", out_irq);
+#endif
+
+	ipar = of_node_get(out_irq->np);
+
+	/* First get the #interrupt-cells property of the current cursor
+	 * that tells us how to interpret the passed-in intspec. If there
+	 * is none, we are nice and just walk up the tree
+	 */
+	do {
+		tmp = of_get_property(ipar, "#interrupt-cells", NULL);
+		if (tmp != NULL) {
+			intsize = be32_to_cpu(*tmp);
+			break;
+		}
+		tnode = ipar;
+		ipar = of_irq_find_parent(ipar);
+		of_node_put(tnode);
+	} while (ipar);
+	if (ipar == NULL) {
+		pr_debug(" -> no parent found !\n");
+		goto fail;
+	}
+
+	pr_debug("of_irq_parse_raw: ipar=%s, size=%d\n",
+		 of_node_full_name(ipar), intsize);
+
+	if (out_irq->args_count != intsize)
+		return -EINVAL;
+
+	/* Look for this #address-cells. We have to implement the old linux
+	 * trick of looking for the parent here as some device-trees rely on it
+	 */
+	old = of_node_get(ipar);
+	do {
+		tmp = of_get_property(old, "#address-cells", NULL);
+		tnode = of_get_parent(old);
+		of_node_put(old);
+		old = tnode;
+	} while (old && tmp == NULL);
+	of_node_put(old);
+	old = NULL;
+	addrsize = (tmp == NULL) ? 2 : be32_to_cpu(*tmp);
+
+	pr_debug(" -> addrsize=%d\n", addrsize);
+
+	/* Range check so that the temporary buffer doesn't overflow */
+	if (WARN_ON(addrsize + intsize > MAX_PHANDLE_ARGS))
+		goto fail;
+
+	/* Precalculate the match array - this simplifies match loop */
+	for (i = 0; i < addrsize; i++)
+		initial_match_array[i] = addr ? addr[i] : 0;
+	for (i = 0; i < intsize; i++)
+		initial_match_array[addrsize + i] =
+			cpu_to_be32(out_irq->args[i]);
+
+	/* Now start the actual "proper" walk of the interrupt tree */
+	while (ipar != NULL) {
+		/* Now check if cursor is an interrupt-controller and if it is
+		 * then we are done
+		 */
+		if (of_get_property(ipar, "interrupt-controller", NULL) !=
+				NULL) {
+			pr_debug(" -> got it !\n");
+			return 0;
+		}
+
+		/*
+		 * interrupt-map parsing does not work without a reg
+		 * property when #address-cells != 0
+		 */
+		if (addrsize && !addr) {
+			pr_debug(" -> no reg passed in when needed !\n");
+			goto fail;
+		}
+
+		/* Now look for an interrupt-map */
+		imap = of_get_property(ipar, "interrupt-map", &imaplen);
+		/* No interrupt map, check for an interrupt parent */
+		if (imap == NULL) {
+			pr_debug(" -> no map, getting parent\n");
+			newpar = of_irq_find_parent(ipar);
+			goto skiplevel;
+		}
+		imaplen /= sizeof(u32);
+
+		/* Look for a mask */
+		imask = of_get_property(ipar, "interrupt-map-mask", NULL);
+		if (!imask)
+			imask = dummy_imask;
+
+		/* Parse interrupt-map */
+		match = 0;
+		while (imaplen > (addrsize + intsize + 1) && !match) {
+			/* Compare specifiers */
+			match = 1;
+			for (i = 0; i < (addrsize + intsize); i++, imaplen--)
+				match &= !((match_array[i] ^ *imap++) &
+					   imask[i]);
+
+			pr_debug(" -> match=%d (imaplen=%d)\n", match, imaplen);
+
+			/* Get the interrupt parent */
+			if (of_irq_workarounds & OF_IMAP_NO_PHANDLE)
+				newpar = of_node_get(of_irq_dflt_pic);
+			else
+				newpar =
+				of_find_node_by_phandle(be32_to_cpup(imap));
+			imap++;
+			--imaplen;
+
+			/* Check if not found */
+			if (newpar == NULL) {
+				pr_debug(" -> imap parent not found !\n");
+				goto fail;
+			}
+
+			if (!of_device_is_available(newpar))
+				match = 0;
+
+			/* Get #interrupt-cells and #address-cells of new
+			 * parent
+			 */
+			tmp = of_get_property(newpar, "#interrupt-cells", NULL);
+			if (tmp == NULL) {
+				pr_debug(" -> parent lacks #interrupt-cells!\n");
+				goto fail;
+			}
+			newintsize = be32_to_cpu(*tmp);
+			tmp = of_get_property(newpar, "#address-cells", NULL);
+			newaddrsize = (tmp == NULL) ? 0 : be32_to_cpu(*tmp);
+
+			pr_debug(" -> newintsize=%d, newaddrsize=%d\n",
+			    newintsize, newaddrsize);
+
+			/* Check for malformed properties */
+			if (WARN_ON(newaddrsize + newintsize >
+				    MAX_PHANDLE_ARGS))
+				goto fail;
+			if (imaplen < (newaddrsize + newintsize))
+				goto fail;
+
+			imap += newaddrsize + newintsize;
+			imaplen -= newaddrsize + newintsize;
+
+			pr_debug(" -> imaplen=%d\n", imaplen);
+		}
+		if (!match)
+			goto fail;
+
+		/*
+		 * Successfully parsed an interrrupt-map translation; copy new
+		 * interrupt specifier into the out_irq structure
+		 */
+		out_irq->np = newpar;
+
+		match_array = imap - newaddrsize - newintsize;
+		for (i = 0; i < newintsize; i++)
+			out_irq->args[i] = be32_to_cpup(imap - newintsize + i);
+		out_irq->args_count = intsize = newintsize;
+		addrsize = newaddrsize;
+
+skiplevel:
+		/* Iterate again with new parent */
+		pr_debug(" -> new parent: %s\n", of_node_full_name(newpar));
+		of_node_put(ipar);
+		ipar = newpar;
+		newpar = NULL;
+	}
+ fail:
+	of_node_put(ipar);
+	of_node_put(newpar);
+
+	return -EINVAL;
+}
+
+static inline int of_irq_parse_oldworld(struct device_node *device, int index,
+				      struct of_phandle_args *out_irq)
+{
+	return -EINVAL;
+}
+/**
+ * of_irq_parse_one - Resolve an interrupt for a device
+ * @device: the device whose interrupt is to be resolved
+ * @index: index of the interrupt to resolve
+ * @out_irq: structure of_irq filled by this function
+ *
+ * This function resolves an interrupt for a node by walking the interrupt tree,
+ * finding which interrupt controller node it is attached to, and returning the
+ * interrupt specifier that can be used to retrieve a Linux IRQ number.
+ */
+int of_irq_parse_one(struct device_node *device, int index,
+		     struct of_phandle_args *out_irq)
+{
+	struct device_node *p;
+	const __be32 *intspec, *tmp, *addr;
+	u32 intsize, intlen;
+	int i, res;
+
+	pr_debug("of_irq_parse_one: dev=%s, index=%d\n",
+		 of_node_full_name(device), index);
+
+	/* OldWorld mac stuff is "special", handle out of line */
+	if (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)
+		return of_irq_parse_oldworld(device, index, out_irq);
+
+	/* Get the reg property (if any) */
+	addr = of_get_property(device, "reg", NULL);
+
+	/* Try the new-style interrupts-extended first */
+	res = of_parse_phandle_with_args(device, "interrupts-extended",
+					"#interrupt-cells", index, out_irq);
+	if (!res)
+		return of_irq_parse_raw(addr, out_irq);
+
+	/* Get the interrupts property */
+	intspec = of_get_property(device, "interrupts", &intlen);
+	if (intspec == NULL)
+		return -EINVAL;
+
+	intlen /= sizeof(*intspec);
+
+	pr_debug(" intspec=%d intlen=%d\n", be32_to_cpup(intspec), intlen);
+
+	/* Look for the interrupt parent. */
+	p = of_irq_find_parent(device);
+	if (p == NULL)
+		return -EINVAL;
+
+	/* Get size of interrupt specifier */
+	tmp = of_get_property(p, "#interrupt-cells", NULL);
+	if (tmp == NULL) {
+		res = -EINVAL;
+		goto out;
+	}
+	intsize = be32_to_cpu(*tmp);
+
+	pr_debug(" intsize=%d intlen=%d\n", intsize, intlen);
+
+	/* Check index */
+	if ((index + 1) * intsize > intlen) {
+		res = -EINVAL;
+		goto out;
+	}
+
+	/* Copy intspec into irq structure */
+	intspec += index * intsize;
+	out_irq->np = p;
+	out_irq->args_count = intsize;
+	for (i = 0; i < intsize; i++)
+		out_irq->args[i] = be32_to_cpup(intspec++);
+
+	/* Check if there are any interrupt-map translations to process */
+	res = of_irq_parse_raw(addr, out_irq);
+ out:
+	of_node_put(p);
+	return res;
+}
+
+/**
+ * of_irq_get - Decode a node's IRQ and return it as a Linux IRQ number
+ * @dev: pointer to device tree node
+ * @index: zero-based index of the IRQ
+ *
+ * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or
+ * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case
+ * of any other failure.
+ */
+int of_irq_get(struct device_node *dev, int index)
+{
+	int rc;
+	struct of_phandle_args oirq;
+	struct irq_domain *domain;
+
+	rc = of_irq_parse_one(dev, index, &oirq);
+	if (rc)
+		return rc;
+
+	domain = irq_find_host(oirq.np);
+	if (!domain)
+		return -EPROBE_DEFER;
+
+	return irq_create_of_mapping(oirq.np, (const u32 *)&oirq.args,
+				     oirq.args_count);
+}
+#endif
+
+#if defined(WILC_DEBUGFS)
+static struct dentry *wilc_dir;
+
+static ssize_t wilc_debug_region_read(struct file *file, char __user *userbuf,
+				     size_t count, loff_t *ppos)
+{
+	char buf[128];
+	int res = 0;
+
+	/* only allow read from start */
+	if (*ppos > 0)
+		return 0;
+
+	res = scnprintf(buf, sizeof(buf), "Debug Region: (0x%08x)\n",
+				    atomic_read(&WILC_DEBUG_REGION));
+
+	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
+}
+
+static ssize_t wilc_debug_region_write(struct file *filp,
+				      const char __user *buf, size_t count,
+				      loff_t *ppos)
+{
+	int flag = 0;
+	int ret;
+
+	ret = kstrtouint_from_user(buf, count, 16, &flag);
+	if (ret)
+		return ret;
+
+	if (flag > DBG_REGION_ALL) {
+		pr_err("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
+			   __func__, flag, atomic_read(&WILC_DEBUG_REGION));
+		pr_err("allowed bits are 0 to 15\n");
+		return -EINVAL;
+	}
+
+	atomic_set(&WILC_DEBUG_REGION, (int)flag);
+
+	pr_info("Debug region set to %x\n", atomic_read(&WILC_DEBUG_REGION));
+
+	return count;
+}
+
+#define FOPS(_open, _read, _write, _poll) { \
+		.owner	= THIS_MODULE, \
+		.open	= (_open), \
+		.read	= (_read), \
+		.write	= (_write), \
+		.poll		= (_poll), \
+}
+
+struct wilc_debugfs_info_t {
+	const char *name;
+	int perm;
+	unsigned int data;
+	const struct file_operations fops;
+};
+
+static struct wilc_debugfs_info_t debugfs_info[] = {
+	{
+		"wilc_debug_region",
+		0666,
+		0,
+		FOPS(NULL, wilc_debug_region_read, wilc_debug_region_write,
+		     NULL),
+	},
+};
+
+int wilc_debugfs_init(void)
+{
+	int i;
+	struct wilc_debugfs_info_t *info;
+
+	wilc_dir = debugfs_create_dir("wilc", NULL);
+	if (wilc_dir == NULL) {
+		pr_err("Error creating debugfs\n");
+		return -EFAULT;
+	}
+	for (i = 0; i < ARRAY_SIZE(debugfs_info); i++) {
+		info = &debugfs_info[i];
+		debugfs_create_file(info->name,
+				    info->perm,
+				    wilc_dir,
+				    &info->data,
+				    &info->fops);
+	}
+	return 0;
+}
+
+void wilc_debugfs_remove(void)
+{
+	debugfs_remove_recursive(wilc_dir);
+}
+
+#endif
diff --git a/drivers/net/wireless/microchip/wilc1000/debugfs.h b/drivers/net/wireless/microchip/wilc1000/debugfs.h
new file mode 100644
index 00000000..2de82a1
--- /dev/null
+++ b/drivers/net/wireless/microchip/wilc1000/debugfs.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#ifndef WILC_DEBUGFS_H
+#define WILC_DEBUGFS_H
+
+#include <linux/kern_levels.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
+#include <linux/of_irq.h>
+#endif
+
+#define GENERIC_DBG		BIT(0)
+#define HOSTAPD_DBG		BIT(1)
+#define HOSTINF_DBG		BIT(2)
+#define CORECONFIG_DBG		BIT(3)
+#define CFG80211_DBG		BIT(4)
+#define INT_DBG			BIT(5)
+#define TX_DBG			BIT(6)
+#define RX_DBG			BIT(7)
+#define TCP_ENH			BIT(8)
+#define INIT_DBG		BIT(9)
+#define PWRDEV_DBG		BIT(10)
+#define DBG_REGION_ALL		(BIT(11)-1)
+
+extern atomic_t WILC_DEBUG_REGION;
+
+#define PRINT_D(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_dbg(netdev, "DBG [%s: %d] "format, __func__, __LINE__,\
+		   ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_INFO(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_info(netdev, "INFO [%s]"format, __func__, \
+		##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_WRN(netdev, region, format, ...) do { \
+	if (atomic_read(&WILC_DEBUG_REGION)&(region))\
+		netdev_warn(netdev, "WRN [%s: %d]"format, __func__, __LINE__,\
+		    ##__VA_ARGS__); } \
+	while (0)
+
+#define PRINT_ER(netdev, format, ...) netdev_err(netdev, "ERR [%s:%d] "format,\
+	__func__, __LINE__, ##__VA_ARGS__)
+
+#ifdef WILC_DEBUGFS
+int wilc_debugfs_init(void);
+void wilc_debugfs_remove(void);
+#endif
+
+#if KERNEL_VERSION(3, 15, 0) > LINUX_VERSION_CODE
+int of_irq_get(struct device_node *dev, int index);
+#endif
+#endif /* WILC_DEBUGFS_H */
diff --git a/drivers/net/wireless/microchip/wilc1000/fw.h b/drivers/net/wireless/microchip/wilc1000/fw.h
index a76e1de..5c5cac4 100644
--- a/drivers/net/wireless/microchip/wilc1000/fw.h
+++ b/drivers/net/wireless/microchip/wilc1000/fw.h
@@ -41,23 +41,25 @@ struct wilc_drv_handler {
 	u8 mode;
 } __packed;
 
-struct wilc_wep_key {
-	u8 index;
-	u8 key_len;
-	u8 key[0];
-} __packed;
-
 struct wilc_sta_wpa_ptk {
 	u8 mac_addr[ETH_ALEN];
 	u8 key_len;
-	u8 key[0];
+	u8 key[];
 } __packed;
 
 struct wilc_ap_wpa_ptk {
 	u8 mac_addr[ETH_ALEN];
 	u8 index;
 	u8 key_len;
-	u8 key[0];
+	u8 key[];
+} __packed;
+
+struct wilc_wpa_igtk {
+	u8 index;
+	u8 pn_len;
+	u8 pn[6];
+	u8 key_len;
+	u8 key[];
 } __packed;
 
 struct wilc_gtk_key {
@@ -65,7 +67,7 @@ struct wilc_gtk_key {
 	u8 rsc[8];
 	u8 index;
 	u8 key_len;
-	u8 key[0];
+	u8 key[];
 } __packed;
 
 struct wilc_op_mode {
@@ -116,4 +118,13 @@ struct wilc_join_bss_param {
 		struct wilc_noa_opp_enable opp_en;
 	};
 } __packed;
+
+struct wilc_external_auth_param {
+	u8 action;
+	u8 bssid[ETH_ALEN];
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 ssid_len;
+	__le32 key_mgmt_suites;
+	__le16 status;
+} __packed;
 #endif
diff --git a/drivers/net/wireless/microchip/wilc1000/hif.c b/drivers/net/wireless/microchip/wilc1000/hif.c
index d025a30..3f672a0 100644
--- a/drivers/net/wireless/microchip/wilc1000/hif.c
+++ b/drivers/net/wireless/microchip/wilc1000/hif.c
@@ -9,7 +9,38 @@
 #define WILC_HIF_SCAN_TIMEOUT_MS                5000
 #define WILC_HIF_CONNECT_TIMEOUT_MS             9500
 
-#define WILC_FALSE_FRMWR_CHANNEL		100
+#define WILC_FALSE_FRMWR_CHANNEL		    100
+
+#if KERNEL_VERSION(3, 17, 0) > LINUX_VERSION_CODE
+struct ieee80211_wmm_ac_param {
+	u8 aci_aifsn; /* AIFSN, ACM, ACI */
+	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
+	__le16 txop_limit;
+} __packed;
+
+struct ieee80211_wmm_param_ie {
+	u8 element_id; /* Element ID: 221 (0xdd); */
+	u8 len; /* Length: 24 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 1 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+	u8 reserved; /* 0 */
+	/* AC_BE, AC_BK, AC_VI, AC_VO */
+	struct ieee80211_wmm_ac_param ac[4];
+} __packed;
+#endif
+
+struct send_buffered_eap {
+	void (*deliver_to_stack)(struct wilc_vif *vif, u8 *buff, u32 size,
+			      u32 pkt_offset, u8 status);
+	void (*eap_buf_param)(void *priv);
+	u8 *buff;
+	unsigned int size;
+	unsigned int pkt_offset;
+	void *user_arg;
+};
 
 #define WILC_SCAN_WID_LIST_SIZE		6
 
@@ -23,17 +54,55 @@ struct wilc_set_multicast {
 	u8 *mc_list;
 };
 
+struct host_if_wowlan_trigger {
+	u8 wowlan_trigger;
+};
+
+struct host_if_set_ant {
+	u8 mode;
+	u8 antenna1;
+	u8 antenna2;
+	u8 gpio_mode;
+};
+
+struct tx_power {
+	u8 tx_pwr;
+};
+
+struct power_mgmt_param {
+	bool enabled;
+	u32 timeout;
+};
+
 struct wilc_del_all_sta {
 	u8 assoc_sta;
 	u8 mac[WILC_MAX_NUM_STA][ETH_ALEN];
 };
 
+struct add_sta_param {
+	u8 bssid[ETH_ALEN];
+	u16 aid;
+	u8 supported_rates_len;
+	const u8 *supported_rates;
+	bool ht_supported;
+	struct ieee80211_ht_cap ht_capa;
+	u16 flags_mask;
+	u16 flags_set;
+};
+
 union wilc_message_body {
 	struct wilc_rcvd_net_info net_info;
 	struct wilc_rcvd_mac_info mac_info;
 	struct wilc_set_multicast mc_info;
 	struct wilc_remain_ch remain_on_ch;
 	char *data;
+	struct host_if_wowlan_trigger wow_trigger;
+	struct send_buffered_eap send_buff_eap;
+	struct host_if_set_ant set_ant;
+	struct tx_power tx_power;
+	struct power_mgmt_param pwr_mgmt_info;
+	struct add_sta_param add_sta_info;
+	struct add_sta_param edit_sta_info;
 };
 
 struct host_if_msg {
@@ -110,15 +179,29 @@ static struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)
 	return NULL;
 }
 
-static int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
+int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
 {
 	int result = 0;
 	u8 abort_running_scan;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	struct wilc_user_scan_req *scan_req;
+	u8 null_bssid[6] = {0};
 
-	if (evt == SCAN_EVENT_ABORTED) {
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "handling scan done\n");
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		return result;
+	}
+
+	if (evt == SCAN_EVENT_DONE) {
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
+	} else if (evt == SCAN_EVENT_ABORTED) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Abort running scan\n");
 		abort_running_scan = 1;
 		wid.id = WID_ABORT_RUNNING_SCAN;
 		wid.type = WID_CHAR;
@@ -127,16 +210,11 @@ static int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
 
 		result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 		if (result) {
-			netdev_err(vif->ndev, "Failed to set abort running\n");
+			PRINT_ER(vif->ndev, "Failed to set abort running\n");
 			result = -EFAULT;
 		}
 	}
 
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "%s: hif driver is NULL\n", __func__);
-		return result;
-	}
-
 	scan_req = &hif_drv->usr_scan_req;
 	if (scan_req->scan_result) {
 		scan_req->scan_result(evt, NULL, scan_req->arg);
@@ -146,6 +224,33 @@ static int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
 	return result;
 }
 
+static void handle_send_buffered_eap(struct work_struct *work)
+{
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct send_buffered_eap *hif_buff_eap = &msg->body.send_buff_eap;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending bufferd eapol to WPAS\n");
+	if (!hif_buff_eap->buff)
+		goto out;
+
+	if (hif_buff_eap->deliver_to_stack)
+		hif_buff_eap->deliver_to_stack(vif, hif_buff_eap->buff,
+					       hif_buff_eap->size,
+					       hif_buff_eap->pkt_offset,
+					       PKT_STATUS_BUFFERED);
+	if (hif_buff_eap->eap_buf_param)
+		hif_buff_eap->eap_buf_param(hif_buff_eap->user_arg);
+
+	if (hif_buff_eap->buff != NULL) {
+		kfree(hif_buff_eap->buff);
+		hif_buff_eap->buff = NULL;
+	}
+
+out:
+	kfree(msg);
+}
+
 int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	      u8 *ch_freq_list, u8 ch_list_len,
 	      void (*scan_result_fn)(enum scan_event,
@@ -160,20 +265,42 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	u8 valuesize = 0;
 	u8 *search_ssid_vals = NULL;
 	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (hif_drv->hif_state >= HOST_IF_SCANNING &&
-	    hif_drv->hif_state < HOST_IF_CONNECTED) {
-		netdev_err(vif->ndev, "Already scan\n");
-		result = -EBUSY;
-		goto error;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Scanning: In [%d] state\n",
+		   hif_drv->hif_state);
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state != HOST_IF_IDLE &&
+		    hif_drv_tmp->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort scan. In state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			result = -EBUSY;
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			goto error;
+		}
 	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	if (vif->connecting) {
-		netdev_err(vif->ndev, "Don't do obss scan\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
 		result = -EBUSY;
 		goto error;
 	}
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting SCAN params\n");
 	hif_drv->usr_scan_req.ch_cnt = 0;
 
 	if (request->n_ssids) {
@@ -188,6 +315,9 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 
 			*buffer++ = request->n_ssids;
 
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "In Handle_ProbeRequest number of ssid %d\n",
+			 request->n_ssids);
 			for (i = 0; i < request->n_ssids; i++) {
 				*buffer++ = request->ssids[i].ssid_len;
 				memcpy(buffer, request->ssids[i].ssid,
@@ -211,6 +341,9 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	wid_list[index].val = (s8 *)&scan_type;
 	index++;
 
+#if KERNEL_VERSION(4, 8, 0) > LINUX_VERSION_CODE
+	scan_timeout = WILC_HIF_SCAN_TIMEOUT_MS;
+#else
 	if (scan_type == WILC_FW_PASSIVE_SCAN && request->duration) {
 		wid_list[index].id = WID_PASSIVE_SCAN_TIME;
 		wid_list[index].type = WID_SHORT;
@@ -222,7 +355,7 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	} else {
 		scan_timeout = WILC_HIF_SCAN_TIMEOUT_MS;
 	}
-
+#endif
 	wid_list[index].id = WID_SCAN_CHANNEL_LIST;
 	wid_list[index].type = WID_BIN_DATA;
 
@@ -250,12 +383,17 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 	if (result) {
 		netdev_err(vif->ndev, "Failed to send scan parameters\n");
 		goto error;
+	} else {
+		hif_drv->scan_timer_vif = vif;
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   ">> Starting the SCAN timer\n");
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		hif_drv->scan_timer.data = (unsigned long)hif_drv;
+#endif
+		mod_timer(&hif_drv->scan_timer,
+			  jiffies + msecs_to_jiffies(scan_timeout));
 	}
 
-	hif_drv->scan_timer_vif = vif;
-	mod_timer(&hif_drv->scan_timer,
-		  jiffies + msecs_to_jiffies(scan_timeout));
-
 error:
 
 	kfree(search_ssid_vals);
@@ -266,11 +404,39 @@ int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
 static int wilc_send_connect_wid(struct wilc_vif *vif)
 {
 	int result = 0;
-	struct wid wid_list[4];
+	struct wid wid_list[5];
 	u32 wid_cnt = 0;
 	struct host_if_drv *hif_drv = vif->hif_drv;
 	struct wilc_conn_info *conn_attr = &hif_drv->conn_info;
 	struct wilc_join_bss_param *bss_param = conn_attr->param;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort connect in state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			result = -EBUSY;
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			goto error;
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+
+	wid_list[wid_cnt].id = WID_SET_MFP;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&conn_attr->mfp_type;
+	wid_cnt++;
 
 	wid_list[wid_cnt].id = WID_INFO_ELEMENT_ASSOCIATE;
 	wid_list[wid_cnt].type = WID_BIN_DATA;
@@ -284,24 +450,40 @@ static int wilc_send_connect_wid(struct wilc_vif *vif)
 	wid_list[wid_cnt].val = (s8 *)&conn_attr->security;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Encrypt Mode = %x\n",
+		conn_attr->security);
 	wid_list[wid_cnt].id = WID_AUTH_TYPE;
 	wid_list[wid_cnt].type = WID_CHAR;
 	wid_list[wid_cnt].size = sizeof(char);
 	wid_list[wid_cnt].val = (s8 *)&conn_attr->auth_type;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Authentication Type = %x\n",
+		conn_attr->auth_type);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Connecting to network on channel %d\n", conn_attr->ch);
+
 	wid_list[wid_cnt].id = WID_JOIN_REQ_EXTENDED;
 	wid_list[wid_cnt].type = WID_STR;
 	wid_list[wid_cnt].size = sizeof(*bss_param);
 	wid_list[wid_cnt].val = (u8 *)bss_param;
 	wid_cnt++;
 
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Management Frame Protection type = %x\n",
+		conn_attr->mfp_type);
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "send HOST_IF_WAITING_CONN_RESP\n");
+
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, wid_cnt);
 	if (result) {
 		netdev_err(vif->ndev, "failed to send config packet\n");
 		goto error;
 	} else {
-		hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
+		if (conn_attr->auth_type == WILC_FW_AUTH_SAE)
+			hif_drv->hif_state = HOST_IF_EXTERNAL_AUTH;
+		else
+			hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "set state [%d]\n", hif_drv->hif_state);
 	}
 
 	return 0;
@@ -314,6 +496,23 @@ static int wilc_send_connect_wid(struct wilc_vif *vif)
 	return result;
 }
 
+void handle_connect_cancel(struct wilc_vif *vif)
+{
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (hif_drv->conn_info.conn_result) {
+		hif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+					       0, hif_drv->conn_info.arg);
+	}
+
+	eth_zero_addr(hif_drv->assoc_bssid);
+
+	hif_drv->conn_info.req_ies_len = 0;
+	kfree(hif_drv->conn_info.req_ies);
+	hif_drv->conn_info.req_ies = NULL;
+	hif_drv->hif_state = HOST_IF_IDLE;
+}
+
 static void handle_connect_timeout(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
@@ -344,6 +543,7 @@ static void handle_connect_timeout(struct work_struct *work)
 	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
 		netdev_err(vif->ndev, "Failed to send disconnect\n");
@@ -501,6 +701,9 @@ static void handle_rcvd_ntwrk_info(struct work_struct *work)
 	int ies_len;
 	size_t offset;
 
+	PRINT_D(msg->vif->ndev, HOSTINF_DBG,
+		"Handling received network info\n");
+
 	if (ieee80211_is_probe_resp(rcvd_info->mgmt->frame_control))
 		offset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
 	else if (ieee80211_is_beacon(rcvd_info->mgmt->frame_control))
@@ -513,6 +716,8 @@ static void handle_rcvd_ntwrk_info(struct work_struct *work)
 	if (ies_len <= 0)
 		goto done;
 
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "New network found\n");
+	/* extract the channel from received mgmt frame */
 	ch_elm = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, ies_len);
 	if (ch_elm && ch_elm[1] > 0)
 		rcvd_info->ch = ch_elm[2];
@@ -586,9 +791,14 @@ static inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,
 					    WILC_MAX_ASSOC_RESP_FRAME_SIZE,
 					    &assoc_resp_info_len);
 
+		PRINT_D(vif->ndev, HOSTINF_DBG,
+			"Received association response = %d\n",
+			assoc_resp_info_len);
 		if (assoc_resp_info_len != 0) {
 			s32 err = 0;
 
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Parsing association response\n");
 			err = wilc_parse_assoc_resp_info(hif_drv->assoc_resp,
 							 assoc_resp_info_len,
 							 conn_info);
@@ -600,14 +810,18 @@ static inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,
 	}
 
 	del_timer(&hif_drv->connect_timer);
-	conn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP, mac_status,
-			       hif_drv->conn_info.arg);
+	conn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP, mac_status, conn_info->arg);
 
 	if (mac_status == WILC_MAC_STATUS_CONNECTED &&
 	    conn_info->status == WLAN_STATUS_SUCCESS) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : CONNECTED and Connect Status : Successful\n");
 		ether_addr_copy(hif_drv->assoc_bssid, conn_info->bssid);
 		hif_drv->hif_state = HOST_IF_CONNECTED;
 	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : %d and Connect Status : %d\n",
+			   mac_status, conn_info->status);
 		hif_drv->hif_state = HOST_IF_IDLE;
 	}
 
@@ -624,7 +838,11 @@ static inline void host_int_handle_disconnect(struct wilc_vif *vif)
 {
 	struct host_if_drv *hif_drv = vif->hif_drv;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received WILC_MAC_STATUS_DISCONNECTED from the FW\n");
 	if (hif_drv->usr_scan_req.scan_result) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "\n\n<< Abort the running OBSS Scan >>\n\n");
 		del_timer(&hif_drv->scan_timer);
 		handle_scan_done(vif, SCAN_EVENT_ABORTED);
 	}
@@ -655,17 +873,31 @@ static void handle_rcvd_gnrl_async_info(struct work_struct *work)
 		goto free_msg;
 	}
 
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Current State = %d,Received state = %d\n",
+		   hif_drv->hif_state, mac_info->status);
+
 	if (!hif_drv->conn_info.conn_result) {
 		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
 		goto free_msg;
 	}
 
-	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
+	if (hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH) {
+		int ret;
+
+		pr_debug("%s: external SAE processing: bss=%pM akm=%u\n",
+			 __func__, vif->auth.bssid, vif->auth.key_mgmt_suite);
+		ret = cfg80211_external_auth_request(vif->ndev, &vif->auth,
+						     GFP_KERNEL);
+		hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
+	} else if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
 		host_int_parse_assoc_resp_info(vif, mac_info->status);
 	} else if (mac_info->status == WILC_MAC_STATUS_DISCONNECTED) {
 		if (hif_drv->hif_state == HOST_IF_CONNECTED) {
 			host_int_handle_disconnect(vif);
 		} else if (hif_drv->usr_scan_req.scan_result) {
+			PRINT_WRN(vif->ndev, HOSTINF_DBG,
+				  "Received WILC_MAC_STATUS_DISCONNECTED. Abort the running Scan");
 			del_timer(&hif_drv->scan_timer);
 			handle_scan_done(vif, SCAN_EVENT_ABORTED);
 		}
@@ -683,12 +915,35 @@ int wilc_disconnect(struct wilc_vif *vif)
 	struct wilc_conn_info *conn_info;
 	int result;
 	u16 dummy_reason_code = 0;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
+
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "Abort scan from disconnect. state [%d]\n",
+				   hif_drv_tmp->hif_state);
+			del_timer(&hif_drv_tmp->scan_timer);
+			handle_scan_done(vif_tmp, SCAN_EVENT_ABORTED);
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
 	wid.id = WID_DISCONNECT;
 	wid.type = WID_CHAR;
 	wid.val = (s8 *)&dummy_reason_code;
 	wid.size = sizeof(char);
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
+
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result) {
 		netdev_err(vif->ndev, "Failed to send disconnect\n");
@@ -705,11 +960,20 @@ int wilc_disconnect(struct wilc_vif *vif)
 	}
 
 	if (conn_info->conn_result) {
-		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
+		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||
+		    hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "supplicant requested disconnection\n");
 			del_timer(&hif_drv->connect_timer);
+			conn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP,
+					       WILC_MAC_STATUS_DISCONNECTED,
+					       conn_info->arg);
 
-		conn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF, 0,
-				       conn_info->arg);
+		} else if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+			conn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+					       WILC_MAC_STATUS_DISCONNECTED,
+					       conn_info->arg);
+		}
 	} else {
 		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
 	}
@@ -721,6 +985,7 @@ int wilc_disconnect(struct wilc_vif *vif)
 	conn_info->req_ies_len = 0;
 	kfree(conn_info->req_ies);
 	conn_info->req_ies = NULL;
+	conn_info->conn_result = NULL;
 
 	return 0;
 }
@@ -767,10 +1032,14 @@ int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)
 	}
 
 	if (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
-	    stats->link_speed != DEFAULT_LINK_SPEED)
+	    stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Enable TCP filter\n");
 		wilc_enable_tcp_ack_filter(vif, true);
-	else if (stats->link_speed != DEFAULT_LINK_SPEED)
+	} else if (stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Disable TCP filter %d\n",
+			   stats->link_speed);
 		wilc_enable_tcp_ack_filter(vif, false);
+	}
 
 	return result;
 }
@@ -786,10 +1055,9 @@ static void handle_get_statistics(struct work_struct *work)
 	kfree(msg);
 }
 
-static void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,
-				    struct station_parameters *params)
+static void wilc_hif_pack_sta_param(u8 *cur_byte, struct add_sta_param *params)
 {
-	ether_addr_copy(cur_byte, mac);
+	ether_addr_copy(cur_byte, params->bssid);
 	cur_byte += ETH_ALEN;
 
 	put_unaligned_le16(params->aid, cur_byte);
@@ -801,18 +1069,18 @@ static void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,
 		       params->supported_rates_len);
 	cur_byte += params->supported_rates_len;
 
-	if (params->ht_capa) {
+	if (params->ht_supported) {
 		*cur_byte++ = true;
-		memcpy(cur_byte, params->ht_capa,
+		memcpy(cur_byte, &params->ht_capa,
 		       sizeof(struct ieee80211_ht_cap));
 	} else {
 		*cur_byte++ = false;
 	}
 	cur_byte += sizeof(struct ieee80211_ht_cap);
 
-	put_unaligned_le16(params->sta_flags_mask, cur_byte);
+	put_unaligned_le16(params->flags_mask, cur_byte);
 	cur_byte += 2;
-	put_unaligned_le16(params->sta_flags_set, cur_byte);
+	put_unaligned_le16(params->flags_set, cur_byte);
 }
 
 static int handle_remain_on_chan(struct wilc_vif *vif,
@@ -822,16 +1090,50 @@ static int handle_remain_on_chan(struct wilc_vif *vif,
 	u8 remain_on_chan_flag;
 	struct wid wid;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct wilc_vif *vif_tmp;
+	int srcu_idx;
 
-	if (hif_drv->usr_scan_req.scan_result)
-		return -EBUSY;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
 
-	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
-		return -EBUSY;
+	srcu_idx = srcu_read_lock(&vif->wilc->srcu);
+	list_for_each_entry_rcu(vif_tmp, &vif->wilc->vif_list, list) {
+		struct host_if_drv *hif_drv_tmp;
+
+		if (vif_tmp == NULL || vif_tmp->hif_drv == NULL)
+			continue;
+
+		hif_drv_tmp = vif_tmp->hif_drv;
+
+		if (hif_drv_tmp->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "IFC busy scanning. WLAN_IFC state %d\n",
+				   hif_drv_tmp->hif_state);
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			return -EBUSY;
+		} else if (hif_drv_tmp->hif_state != HOST_IF_IDLE &&
+			   hif_drv_tmp->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif_tmp->ndev, GENERIC_DBG,
+				   "IFC busy connecting. WLAN_IFC %d\n",
+				   hif_drv_tmp->hif_state);
+			srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
+			return -EBUSY;
+		}
+	}
+	srcu_read_unlock(&vif->wilc->srcu, srcu_idx);
 
-	if (vif->connecting)
+	if (vif->connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Don't do scan in (CONNECTING) state\n");
 		return -EBUSY;
+	}
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting channel [%d] duration[%d] [%llu]\n",
+		   hif_remain_ch->ch, hif_remain_ch->duration,
+		   hif_remain_ch->cookie);
 	remain_on_chan_flag = true;
 	wid.id = WID_REMAIN_ON_CHAN;
 	wid.type = WID_STR;
@@ -845,16 +1147,20 @@ static int handle_remain_on_chan(struct wilc_vif *vif,
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	kfree(wid.val);
-	if (result)
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to set remain on channel\n");
 		return -EBUSY;
+	}
 
 	hif_drv->remain_on_ch.arg = hif_remain_ch->arg;
 	hif_drv->remain_on_ch.expired = hif_remain_ch->expired;
 	hif_drv->remain_on_ch.ch = hif_remain_ch->ch;
 	hif_drv->remain_on_ch.cookie = hif_remain_ch->cookie;
+	hif_drv->hif_state = HOST_IF_P2P_LISTEN;
+
 	hif_drv->remain_on_ch_timer_vif = vif;
 
-	return 0;
+	return result;
 }
 
 static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
@@ -863,16 +1169,19 @@ static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
 	struct wid wid;
 	int result;
 	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 null_bssid[6] = {0};
 
-	if (vif->priv.p2p_listen_state) {
+	if (hif_drv->hif_state == HOST_IF_P2P_LISTEN) {
 		remain_on_chan_flag = false;
 		wid.id = WID_REMAIN_ON_CHAN;
 		wid.type = WID_STR;
 		wid.size = 2;
 
 		wid.val = kmalloc(wid.size, GFP_KERNEL);
-		if (!wid.val)
+		if (!wid.val) {
+			PRINT_ER(vif->ndev, "Failed to allocate memory\n");
 			return -ENOMEM;
+		}
 
 		wid.val[0] = remain_on_chan_flag;
 		wid.val[1] = WILC_FALSE_FRMWR_CHANNEL;
@@ -884,10 +1193,14 @@ static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
 			return -EINVAL;
 		}
 
-		if (hif_drv->remain_on_ch.expired) {
+		if (hif_drv->remain_on_ch.expired)
 			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,
 						      cookie);
-		}
+
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
 	} else {
 		netdev_dbg(vif->ndev, "Not in listen state\n");
 	}
@@ -898,15 +1211,28 @@ static int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)
 static void wilc_handle_listen_state_expired(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct wilc_remain_ch *hif_remain_ch = &msg->body.remain_on_ch;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "CANCEL REMAIN ON CHAN\n");
+
+	wilc_handle_roc_expired(vif, hif_remain_ch->cookie);
 
-	wilc_handle_roc_expired(msg->vif, msg->body.remain_on_ch.cookie);
 	kfree(msg);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void listen_timer_cb(struct timer_list *t)
+#else
+static void listen_timer_cb(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	struct host_if_drv *hif_drv = from_timer(hif_drv, t,
 						      remain_on_ch_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
 	struct wilc_vif *vif = hif_drv->remain_on_ch_timer_vif;
 	int result;
 	struct host_if_msg *msg;
@@ -935,6 +1261,8 @@ static void handle_set_mcast_filter(struct work_struct *work)
 	struct wid wid;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setup Multicast Filter\n");
+
 	wid.id = WID_SETUP_MULTICAST_FILTER;
 	wid.type = WID_BIN;
 	wid.size = sizeof(struct wilc_set_multicast) + (set_mc->cnt * ETH_ALEN);
@@ -962,11 +1290,61 @@ static void handle_set_mcast_filter(struct work_struct *work)
 	kfree(msg);
 }
 
+void wilc_set_wowlan_trigger(struct wilc_vif *vif, bool enabled)
+{
+	int ret;
+	struct wid wid;
+	u8 wowlan_trigger = 0;
+
+	if (enabled)
+		wowlan_trigger = 1;
+
+	wid.id = WID_WOWLAN_TRIGGER;
+	wid.type = WID_CHAR;
+	wid.val = &wowlan_trigger;
+	wid.size = sizeof(char);
+
+	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev,
+			 "Failed to send wowlan trigger config packet\n");
+}
+
+int wilc_set_external_auth_param(struct wilc_vif *vif,
+				 struct cfg80211_external_auth_params *auth)
+{
+	int ret;
+	struct wid wid;
+	struct wilc_external_auth_param *param;
+
+	wid.id = WID_EXTERNAL_AUTH_PARAM;
+	wid.type = WID_BIN_DATA;
+	wid.size = sizeof(*param);
+	param = kzalloc(sizeof(*param), GFP_KERNEL);
+	if (!param)
+		return -EINVAL;
+	wid.val = (u8 *)param;
+	param->action = auth->action;
+	ether_addr_copy(param->bssid, auth->bssid);
+	memcpy(param->ssid, auth->ssid.ssid, auth->ssid.ssid_len);
+	param->ssid_len = auth->ssid.ssid_len;
+	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev, "failed to set external auth param\n");
+
+	kfree(param);
+	return ret;
+}
+
 static void handle_scan_timer(struct work_struct *work)
 {
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	int ret;
 
-	handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "handling scan timer\n");
+	ret = handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
+	if (ret)
+		PRINT_ER(msg->vif->ndev, "Failed to handle scan done\n");
 	kfree(msg);
 }
 
@@ -975,15 +1353,24 @@ static void handle_scan_complete(struct work_struct *work)
 	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
 
 	del_timer(&msg->vif->hif_drv->scan_timer);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "scan completed\n");
 
 	handle_scan_done(msg->vif, SCAN_EVENT_DONE);
 
 	kfree(msg);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void timer_scan_cb(struct timer_list *t)
+#else
+static void timer_scan_cb(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	struct host_if_drv *hif_drv = from_timer(hif_drv, t, scan_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
 	struct wilc_vif *vif = hif_drv->scan_timer_vif;
 	struct host_if_msg *msg;
 	int result;
@@ -997,10 +1384,17 @@ static void timer_scan_cb(struct timer_list *t)
 		kfree(msg);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void timer_connect_cb(struct timer_list *t)
+#else
+static void timer_connect_cb(unsigned long arg)
+#endif
 {
-	struct host_if_drv *hif_drv = from_timer(hif_drv, t,
-						      connect_timer);
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t, connect_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
 	struct wilc_vif *vif = hif_drv->connect_timer_vif;
 	struct host_if_msg *msg;
 	int result;
@@ -1014,105 +1408,37 @@ static void timer_connect_cb(struct timer_list *t)
 		kfree(msg);
 }
 
-int wilc_remove_wep_key(struct wilc_vif *vif, u8 index)
-{
-	struct wid wid;
-	int result;
-
-	wid.id = WID_REMOVE_WEP_KEY;
-	wid.type = WID_STR;
-	wid.size = sizeof(char);
-	wid.val = &index;
-
-	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
-	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to send remove wep key config packet\n");
-	return result;
-}
-
-int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index)
-{
-	struct wid wid;
-	int result;
-
-	wid.id = WID_KEY_ID;
-	wid.type = WID_CHAR;
-	wid.size = sizeof(char);
-	wid.val = &index;
-	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
-	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to send wep default key config packet\n");
-
-	return result;
-}
-
-int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
-			     u8 index)
-{
-	struct wid wid;
-	int result;
-	struct wilc_wep_key *wep_key;
-
-	wid.id = WID_ADD_WEP_KEY;
-	wid.type = WID_STR;
-	wid.size = sizeof(*wep_key) + len;
-	wep_key = kzalloc(wid.size, GFP_KERNEL);
-	if (!wep_key)
-		return -ENOMEM;
-
-	wid.val = (u8 *)wep_key;
-
-	wep_key->index = index;
-	wep_key->key_len = len;
-	memcpy(wep_key->key, key, len);
-
-	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
-	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to add wep key config packet\n");
-
-	kfree(wep_key);
-	return result;
-}
-
-int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
-			    u8 index, u8 mode, enum authtype auth_type)
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  void (*deliver_to_stack)(struct wilc_vif *,
+							   u8 *, u32, u32, u8),
+				  void (*eap_buf_param)(void *), u8 *buff,
+				  unsigned int size, unsigned int pkt_offset,
+				  void *user_arg)
 {
-	struct wid wid_list[3];
 	int result;
-	struct wilc_wep_key *wep_key;
-
-	wid_list[0].id = WID_11I_MODE;
-	wid_list[0].type = WID_CHAR;
-	wid_list[0].size = sizeof(char);
-	wid_list[0].val = &mode;
-
-	wid_list[1].id = WID_AUTH_TYPE;
-	wid_list[1].type = WID_CHAR;
-	wid_list[1].size = sizeof(char);
-	wid_list[1].val = (s8 *)&auth_type;
-
-	wid_list[2].id = WID_WEP_KEY_VALUE;
-	wid_list[2].type = WID_STR;
-	wid_list[2].size = sizeof(*wep_key) + len;
-	wep_key = kzalloc(wid_list[2].size, GFP_KERNEL);
-	if (!wep_key)
-		return -ENOMEM;
+	struct host_if_msg *msg;
 
-	wid_list[2].val = (u8 *)wep_key;
+	if (!vif || !deliver_to_stack || !eap_buf_param)
+		return -EFAULT;
 
-	wep_key->index = index;
-	wep_key->key_len = len;
-	memcpy(wep_key->key, key, len);
-	result = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,
-				      ARRAY_SIZE(wid_list));
-	if (result)
-		netdev_err(vif->ndev,
-			   "Failed to add wep ap key config packet\n");
+	msg = wilc_alloc_work(vif, handle_send_buffered_eap, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+	msg->body.send_buff_eap.deliver_to_stack = deliver_to_stack;
+	msg->body.send_buff_eap.eap_buf_param = eap_buf_param;
+	msg->body.send_buff_eap.size = size;
+	msg->body.send_buff_eap.pkt_offset = pkt_offset;
+	msg->body.send_buff_eap.buff = kmalloc(size + pkt_offset,
+					       GFP_ATOMIC);
+	memcpy(msg->body.send_buff_eap.buff, buff, size + pkt_offset);
+	msg->body.send_buff_eap.user_arg = user_arg;
 
-	kfree(wep_key);
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg->body.send_buff_eap.buff);
+		kfree(msg);
+	}
 	return result;
 }
 
@@ -1133,9 +1459,11 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		wid_list[0].val = (s8 *)&cipher_mode;
 
 		key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
-		if (!key_buf)
+		if (!key_buf) {
+			PRINT_ER(vif->ndev,
+				 "NO buffer to keep Key buffer - AP\n");
 			return -ENOMEM;
-
+		}
 		ether_addr_copy(key_buf->mac_addr, mac_addr);
 		key_buf->index = index;
 		key_buf->key_len = t_key_len;
@@ -1161,8 +1489,11 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		struct wilc_sta_wpa_ptk *key_buf;
 
 		key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
-		if (!key_buf)
+		if (!key_buf) {
+			PRINT_ER(vif->ndev,
+				 "No buffer to keep Key buffer - Station\n");
 			return -ENOMEM;
+		}
 
 		ether_addr_copy(key_buf->mac_addr, mac_addr);
 		key_buf->key_len = t_key_len;
@@ -1187,6 +1518,37 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 	return result;
 }
 
+int wilc_add_igtk(struct wilc_vif *vif, const u8 *igtk, u8 igtk_key_len,
+		  const u8 *pn, u8 pn_len, const u8 *mac_addr, u8 mode, u8 index)
+{
+	int result = 0;
+	u8 t_key_len = igtk_key_len;
+	struct wid wid;
+	struct wilc_wpa_igtk *key_buf;
+
+	key_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);
+	if (!key_buf) {
+		PRINT_ER(vif->ndev, "No buffer to keep Key buffer - Station\n");
+		return -ENOMEM;
+	}
+
+	key_buf->index = index;
+
+	memcpy(&key_buf->pn[0], pn, pn_len);
+	key_buf->pn_len = pn_len;
+
+	memcpy(&key_buf->key[0], igtk, igtk_key_len);
+	key_buf->key_len = t_key_len;
+
+	wid.id = WID_ADD_IGTK;
+	wid.type = WID_STR;
+	wid.size = sizeof(*key_buf) + t_key_len;
+	wid.val = (s8 *)key_buf;
+	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	kfree(key_buf);
+	return result;
+}
+
 int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		    u8 index, u32 key_rsc_len, const u8 *key_rsc,
 		    const u8 *rx_mic, const u8 *tx_mic, u8 mode,
@@ -1197,8 +1559,10 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 	int t_key_len = gtk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;
 
 	gtk_key = kzalloc(sizeof(*gtk_key) + t_key_len, GFP_KERNEL);
-	if (!gtk_key)
+	if (!gtk_key) {
+		PRINT_ER(vif->ndev, "No buffer to send GTK Key\n");
 		return -ENOMEM;
+	}
 
 	/* fill bssid value only in station mode */
 	if (mode == WILC_STATION_MODE &&
@@ -1276,6 +1640,23 @@ int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)
 	return result;
 }
 
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr)
+{
+	struct wid wid;
+	int result;
+
+	wid.id = WID_MAC_ADDR;
+	wid.type = WID_STR;
+	wid.size = ETH_ALEN;
+	wid.val = mac_addr;
+
+	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to set mac address\n");
+
+	return result;
+}
+
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,
 		      size_t ies_len)
 {
@@ -1294,9 +1675,14 @@ int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,
 	}
 
 	result = wilc_send_connect_wid(vif);
-	if (result)
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send connect wid\n");
 		goto free_ies;
+	}
 
+#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+	hif_drv->connect_timer.data = (unsigned long)hif_drv;
+#endif
 	hif_drv->connect_timer_vif = vif;
 	mod_timer(&hif_drv->connect_timer,
 		  jiffies + msecs_to_jiffies(WILC_HIF_CONNECT_TIMEOUT_MS));
@@ -1357,8 +1743,10 @@ s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac, u32 *out_val)
 	wid.type = WID_STR;
 	wid.size = ETH_ALEN;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	ether_addr_copy(wid.val, mac);
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
@@ -1376,6 +1764,9 @@ s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac, u32 *out_val)
 	if (result)
 		netdev_err(vif->ndev, "Failed to get inactive time\n");
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting inactive time : %d\n",
+		   *out_val);
+
 	return result;
 }
 
@@ -1405,6 +1796,7 @@ static int wilc_get_stats_async(struct wilc_vif *vif, struct rf_info *stats)
 	int result;
 	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, " getting async statistics\n");
 	msg = wilc_alloc_work(vif, handle_get_statistics, false);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -1458,9 +1850,17 @@ int wilc_hif_set_cfg(struct wilc_vif *vif, struct cfg_param_attr *param)
 	return wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, i);
 }
 
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 static void get_periodic_rssi(struct timer_list *t)
+#else
+static void get_periodic_rssi(unsigned long arg)
+#endif
 {
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	struct wilc_vif *vif = from_timer(vif, t, periodic_rssi);
+#else
+	struct wilc_vif *vif = (struct wilc_vif *)arg;
+#endif
 
 	if (!vif->hif_drv) {
 		netdev_err(vif->ndev, "%s: hif driver is NULL", __func__);
@@ -1477,32 +1877,33 @@ int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)
 {
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
 
-	hif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
-	if (!hif_drv)
+	hif_drv = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
+	if (!hif_drv) {
+		PRINT_ER(dev, "hif driver is NULL\n");
 		return -ENOMEM;
-
+	}
 	*hif_drv_handler = hif_drv;
-
 	vif->hif_drv = hif_drv;
 
-	if (wilc->clients_count == 0)
-		mutex_init(&wilc->deinit_lock);
-
-	timer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);
-	mod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));
-
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
 	timer_setup(&hif_drv->scan_timer, timer_scan_cb, 0);
 	timer_setup(&hif_drv->connect_timer, timer_connect_cb, 0);
 	timer_setup(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+	timer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);
+#else
+	setup_timer(&hif_drv->scan_timer, timer_scan_cb, 0);
+	setup_timer(&hif_drv->connect_timer, timer_connect_cb, 0);
+	setup_timer(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+	setup_timer(&vif->periodic_rssi, get_periodic_rssi,
+		    (unsigned long)vif);
+#endif
+	mod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));
 
 	hif_drv->hif_state = HOST_IF_IDLE;
 
 	hif_drv->p2p_timeout = 0;
 
-	wilc->clients_count++;
-
 	return 0;
 }
 
@@ -1533,7 +1934,6 @@ int wilc_deinit(struct wilc_vif *vif)
 
 	kfree(hif_drv);
 	vif->hif_drv = NULL;
-	vif->wilc->clients_count--;
 	mutex_unlock(&vif->wilc->deinit_lock);
 	return result;
 }
@@ -1545,21 +1945,23 @@ void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
+		goto out;
 
+	hif_drv = vif->hif_drv;
 	if (!hif_drv) {
 		netdev_err(vif->ndev, "driver not init[%p]\n", hif_drv);
-		return;
+		goto out;
 	}
 
 	msg = wilc_alloc_work(vif, handle_rcvd_ntwrk_info, false);
 	if (IS_ERR(msg))
-		return;
+		goto out;
 
 	msg->body.net_info.frame_len = get_unaligned_le16(&buffer[6]) - 1;
 	msg->body.net_info.rssi = buffer[8];
@@ -1568,7 +1970,7 @@ void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 					  GFP_KERNEL);
 	if (!msg->body.net_info.mgmt) {
 		kfree(msg);
-		return;
+		goto out;
 	}
 
 	result = wilc_enqueue_work(msg);
@@ -1577,6 +1979,8 @@ void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 		kfree(msg->body.net_info.mgmt);
 		kfree(msg);
 	}
+out:
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
@@ -1586,43 +1990,47 @@ void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	mutex_lock(&wilc->deinit_lock);
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
-	if (!vif) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
-	}
+	if (!vif)
+		goto out;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "General asynchronous info packet received\n");
 
 	hif_drv = vif->hif_drv;
 
 	if (!hif_drv) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto out;
 	}
 
 	if (!hif_drv->conn_info.conn_result) {
-		netdev_err(vif->ndev, "%s: conn_result is NULL\n", __func__);
-		mutex_unlock(&wilc->deinit_lock);
-		return;
+		PRINT_ER(vif->ndev, "there is no current Connect Request\n");
+		goto out;
 	}
 
 	msg = wilc_alloc_work(vif, handle_rcvd_gnrl_async_info, false);
-	if (IS_ERR(msg)) {
-		mutex_unlock(&wilc->deinit_lock);
-		return;
-	}
+	if (IS_ERR(msg))
+		goto out;
 
 	msg->body.mac_info.status = buffer[7];
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received MAC status= %d Reason= %d Info = %d\n",
+		   buffer[7], buffer[8], buffer[9]);
 	result = wilc_enqueue_work(msg);
 	if (result) {
 		netdev_err(vif->ndev, "%s: enqueue work failed\n", __func__);
 		kfree(msg);
 	}
-
+out:
 	mutex_unlock(&wilc->deinit_lock);
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
@@ -1631,30 +2039,37 @@ void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
 	int id;
 	struct host_if_drv *hif_drv;
 	struct wilc_vif *vif;
+	int srcu_idx;
 
 	id = get_unaligned_le32(&buffer[length - 4]);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
 	vif = wilc_get_vif_from_idx(wilc, id);
 	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
+		goto out;
 
-	if (!hif_drv)
-		return;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Scan notification received\n");
+
+	hif_drv = vif->hif_drv;
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif driver is NULL\n");
+		goto out;
+	}
 
 	if (hif_drv->usr_scan_req.scan_result) {
 		struct host_if_msg *msg;
 
 		msg = wilc_alloc_work(vif, handle_scan_complete, false);
 		if (IS_ERR(msg))
-			return;
+			goto out;
 
 		result = wilc_enqueue_work(msg);
 		if (result) {
-			netdev_err(vif->ndev, "%s: enqueue work failed\n",
-				   __func__);
+			PRINT_ER(vif->ndev, "enqueue work failed\n");
 			kfree(msg);
 		}
 	}
+out:
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 }
 
 int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
@@ -1665,6 +2080,7 @@ int wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,
 	struct wilc_remain_ch roc;
 	int result;
 
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "called\n");
 	roc.ch = chan;
 	roc.expired = expired;
 	roc.arg = user_arg;
@@ -1708,14 +2124,22 @@ void wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
 
 	switch (frame_type) {
 	case IEEE80211_STYPE_ACTION:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "ACTION\n");
 		reg_frame.reg_id = WILC_FW_ACTION_FRM_IDX;
 		break;
 
 	case IEEE80211_STYPE_PROBE_REQ:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "PROBE REQ\n");
 		reg_frame.reg_id = WILC_FW_PROBE_REQ_IDX;
 		break;
 
+	case IEEE80211_STYPE_AUTH:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "AUTH\n");
+		reg_frame.reg_id = WILC_FW_AUTH_REQ_IDX;
+		break;
+
 	default:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Not valid frame type\n");
 		break;
 	}
 	reg_frame.frame_type = cpu_to_le16(frame_type);
@@ -1731,12 +2155,17 @@ int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
 	int result;
 	u8 *cur_byte;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding beacon\n");
+
 	wid.id = WID_ADD_BEACON;
 	wid.type = WID_BIN;
 	wid.size = params->head_len + params->tail_len + 16;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	cur_byte = wid.val;
 	put_unaligned_le32(interval, cur_byte);
@@ -1771,6 +2200,9 @@ int wilc_del_beacon(struct wilc_vif *vif)
 	struct wid wid;
 	u8 del_beacon = 0;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting beacon message queue params\n");
+
 	wid.id = WID_DEL_BEACON;
 	wid.type = WID_CHAR;
 	wid.size = sizeof(char);
@@ -1783,28 +2215,78 @@ int wilc_del_beacon(struct wilc_vif *vif)
 	return result;
 }
 
-int wilc_add_station(struct wilc_vif *vif, const u8 *mac,
-		     struct station_parameters *params)
+static void handle_add_station(struct work_struct *work)
 {
-	struct wid wid;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct add_sta_param *params = &msg->body.add_sta_info;
 	int result;
-	u8 *cur_byte;
+	struct wid wid;
 
 	wid.id = WID_ADD_STA;
 	wid.type = WID_BIN;
 	wid.size = WILC_ADD_STA_LENGTH + params->supported_rates_len;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling add station\n");
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		return -ENOMEM;
+		goto error;
 
-	cur_byte = wid.val;
-	wilc_hif_pack_sta_param(cur_byte, mac, params);
+	wilc_hif_pack_sta_param(wid.val, params);
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
-	if (result != 0)
-		netdev_err(vif->ndev, "Failed to send add station\n");
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
 
 	kfree(wid.val);
+error:
+	kfree(params->supported_rates);
+	kfree(msg);
+}
+
+int wilc_add_station(struct wilc_vif *vif, const u8 *mac,
+		     struct station_parameters *params)
+{
+	int result;
+	struct host_if_msg *msg;
+	struct add_sta_param *sta_params;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting adding station message queue params\n");
+
+	msg = wilc_alloc_work(vif, handle_add_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	sta_params = &msg->body.add_sta_info;
+	memcpy(sta_params->bssid, mac, ETH_ALEN);
+	sta_params->aid = params->aid;
+	if (!params->ht_capa) {
+		sta_params->ht_supported = false;
+	} else {
+		sta_params->ht_supported = true;
+		memcpy(&sta_params->ht_capa, params->ht_capa,
+		       sizeof(struct ieee80211_ht_cap));
+	}
+	sta_params->flags_mask = params->sta_flags_mask;
+	sta_params->flags_set = params->sta_flags_set;
+
+	sta_params->supported_rates_len = params->supported_rates_len;
+	if (params->supported_rates_len > 0) {
+		sta_params->supported_rates = kmemdup(params->supported_rates,
+					    params->supported_rates_len,
+					    GFP_KERNEL);
+		if (!sta_params->supported_rates) {
+			kfree(msg);
+			return -ENOMEM;
+		}
+	}
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(sta_params->supported_rates);
+		kfree(msg);
+	}
 
 	return result;
 }
@@ -1814,12 +2296,17 @@ int wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)
 	struct wid wid;
 	int result;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting station message queue params\n");
+
 	wid.id = WID_REMOVE_STA;
 	wid.type = WID_BIN;
 	wid.size = ETH_ALEN;
 	wid.val = kzalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
+	if (!wid.val) {
+		PRINT_ER(vif->ndev, "Failed to allocate buffer\n");
 		return -ENOMEM;
+	}
 
 	if (!mac_addr)
 		eth_broadcast_addr(wid.val);
@@ -1843,17 +2330,25 @@ int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
 	u8 assoc_sta = 0;
 	struct wilc_del_all_sta del_sta;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deauthenticating station message queue params\n");
 	memset(&del_sta, 0x0, sizeof(del_sta));
 	for (i = 0; i < WILC_MAX_NUM_STA; i++) {
 		if (!is_zero_ether_addr(mac_addr[i])) {
+			PRINT_INFO(vif->ndev,
+				   CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+				   mac_addr[i][0], mac_addr[i][1],
+				   mac_addr[i][2], mac_addr[i][3],
+				   mac_addr[i][4], mac_addr[i][5]);
 			assoc_sta++;
 			ether_addr_copy(del_sta.mac[i], mac_addr[i]);
 		}
 	}
 
-	if (!assoc_sta)
+	if (!assoc_sta) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "NO ASSOCIATED STAS\n");
 		return 0;
-
+	}
 	del_sta.assoc_sta = assoc_sta;
 
 	wid.id = WID_DEL_ALL_STA;
@@ -1868,49 +2363,129 @@ int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
 	return result;
 }
 
-int wilc_edit_station(struct wilc_vif *vif, const u8 *mac,
-		      struct station_parameters *params)
+static void handle_edit_station(struct work_struct *work)
 {
-	struct wid wid;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct add_sta_param *params = &msg->body.edit_sta_info;
 	int result;
-	u8 *cur_byte;
+	struct wid wid;
 
 	wid.id = WID_EDIT_STA;
 	wid.type = WID_BIN;
 	wid.size = WILC_ADD_STA_LENGTH + params->supported_rates_len;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling edit station\n");
 	wid.val = kmalloc(wid.size, GFP_KERNEL);
 	if (!wid.val)
-		return -ENOMEM;
+		goto error;
 
-	cur_byte = wid.val;
-	wilc_hif_pack_sta_param(cur_byte, mac, params);
+	wilc_hif_pack_sta_param(wid.val, params);
 
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send edit station\n");
+		PRINT_ER(vif->ndev, "Failed to send edit station\n");
 
 	kfree(wid.val);
+error:
+	kfree(params->supported_rates);
+	kfree(msg);
+}
+
+int wilc_edit_station(struct wilc_vif *vif, const u8 *mac,
+		      struct station_parameters *params)
+{
+	int result;
+	struct host_if_msg *msg;
+	struct add_sta_param *sta_params;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting editing station message queue params\n");
+
+	msg = wilc_alloc_work(vif, handle_edit_station, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	sta_params = &msg->body.edit_sta_info;
+	memcpy(sta_params->bssid, mac, ETH_ALEN);
+	sta_params->aid = params->aid;
+	if (!params->ht_capa) {
+		sta_params->ht_supported = false;
+	} else {
+		sta_params->ht_supported = true;
+		memcpy(&sta_params->ht_capa, params->ht_capa,
+		       sizeof(struct ieee80211_ht_cap));
+	}
+	sta_params->flags_mask = params->sta_flags_mask;
+	sta_params->flags_set = params->sta_flags_set;
+
+	sta_params->supported_rates_len = params->supported_rates_len;
+	if (params->supported_rates_len > 0) {
+		sta_params->supported_rates = kmemdup(params->supported_rates,
+					    params->supported_rates_len,
+					    GFP_KERNEL);
+		if (!sta_params->supported_rates) {
+			kfree(msg);
+			return -ENOMEM;
+		}
+	}
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(sta_params->supported_rates);
+		kfree(msg);
+	}
+
 	return result;
 }
 
-int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
+static void handle_power_management(struct work_struct *work)
 {
-	struct wid wid;
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	struct power_mgmt_param *pm_param = &msg->body.pwr_mgmt_info;
 	int result;
+	struct wid wid;
 	s8 power_mode;
 
-	if (enabled)
+	wid.id = WID_POWER_MANAGEMENT;
+
+	if (pm_param->enabled)
 		power_mode = WILC_FW_MIN_FAST_PS;
 	else
 		power_mode = WILC_FW_NO_POWERSAVE;
-
-	wid.id = WID_POWER_MANAGEMENT;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling power mgmt to %d\n",
+		   power_mode);
 	wid.val = &power_mode;
 	wid.size = sizeof(char);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling Power Management\n");
 	result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 	if (result)
-		netdev_err(vif->ndev, "Failed to send power management\n");
+		PRINT_ER(vif->ndev, "Failed to send power management\n");
+
+	kfree(msg);
+}
+
+int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
+{
+	int result;
+	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "\n\n>> Setting PS to %d <<\n\n",
+		   enabled);
+	msg = wilc_alloc_work(vif, handle_power_management, false);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	msg->body.pwr_mgmt_info.enabled = enabled;
+	msg->body.pwr_mgmt_info.timeout = timeout;
+
+	result = wilc_enqueue_work(msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+		kfree(msg);
+	}
 	return result;
 }
 
@@ -1920,6 +2495,8 @@ int wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,
 	int result;
 	struct host_if_msg *msg;
 
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting Multicast Filter params\n");
 	msg = wilc_alloc_work(vif, handle_set_mcast_filter, false);
 	if (IS_ERR(msg))
 		return PTR_ERR(msg);
@@ -1948,14 +2525,118 @@ int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)
 	return wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
 }
 
-int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
+static void handle_get_tx_pwr(struct work_struct *work)
 {
+	struct host_if_msg *msg = container_of(work, struct host_if_msg, work);
+	struct wilc_vif *vif = msg->vif;
+	u8 *tx_pwr = &msg->body.tx_power.tx_pwr;
+	int ret;
 	struct wid wid;
 
 	wid.id = WID_TX_POWER;
 	wid.type = WID_CHAR;
-	wid.val = tx_power;
+	wid.val = tx_pwr;
 	wid.size = sizeof(char);
 
-	return wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
+	ret = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get TX PWR\n");
+
+	complete(&msg->work_comp);
+}
+
+int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
+{
+	int ret;
+	struct host_if_msg *msg;
+
+	msg = wilc_alloc_work(vif, handle_get_tx_pwr, true);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	ret = wilc_enqueue_work(msg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "enqueue work failed\n");
+	} else {
+		wait_for_completion(&msg->work_comp);
+		*tx_power = msg->body.tx_power.tx_pwr;
+	}
+
+	/* free 'msg' after copying data */
+	kfree(msg);
+	return ret;
+}
+
+static bool is_valid_gpio(struct wilc_vif *vif, u8 gpio)
+{
+	switch (vif->wilc->chip) {
+	case WILC_1000:
+		if (gpio == 0 || gpio == 1 || gpio == 4 || gpio == 6)
+			return true;
+		else
+			return false;
+	case WILC_3000:
+		if (gpio == 0 || gpio == 3 || gpio == 4 ||
+		    (gpio >= 17 && gpio <= 20))
+			return true;
+		else
+			return false;
+	default:
+		return false;
+	}
+}
+
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode)
+{
+	struct wid wid;
+	int ret;
+	struct sysfs_attr_group *attr_sysfs_p = &vif->wilc->attr_sysfs;
+	struct host_if_set_ant set_ant;
+
+	set_ant.mode = mode;
+
+	if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_INVALID_GPIO_CTRL) {
+		pr_err("Ant switch GPIO mode is invalid.\n");
+		pr_err("Set it using /sys/wilc/ant_swtch_mode\n");
+		return -EINVAL;
+	}
+
+	if (is_valid_gpio(vif, attr_sysfs_p->antenna1)) {
+		set_ant.antenna1 = attr_sysfs_p->antenna1;
+	} else  {
+		pr_err("Invalid GPIO %d\n", attr_sysfs_p->antenna1);
+		return -EINVAL;
+	}
+
+	if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL) {
+		if (attr_sysfs_p->antenna2 != attr_sysfs_p->antenna1 &&
+		    is_valid_gpio(vif, attr_sysfs_p->antenna2)) {
+			set_ant.antenna2 = attr_sysfs_p->antenna2;
+		} else {
+			pr_err("Invalid GPIO %d\n", attr_sysfs_p->antenna2);
+			return -EINVAL;
+		}
+	}
+
+	set_ant.gpio_mode = attr_sysfs_p->ant_swtch_mode;
+
+	wid.id = WID_ANTENNA_SELECTION;
+	wid.type = WID_BIN;
+	wid.val = (u8 *)&set_ant;
+	wid.size = sizeof(struct host_if_set_ant);
+	if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_SNGL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIO %d\n", set_ant.mode,
+			   set_ant.antenna1);
+	else if (attr_sysfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "set antenna %d on GPIOs %d and %d\n",
+			   set_ant.mode, set_ant.antenna1,
+			   set_ant.antenna2);
+
+	ret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set antenna mode\n");
+
+	return ret;
 }
diff --git a/drivers/net/wireless/microchip/wilc1000/hif.h b/drivers/net/wireless/microchip/wilc1000/hif.h
index db91791..d411f53 100644
--- a/drivers/net/wireless/microchip/wilc1000/hif.h
+++ b/drivers/net/wireless/microchip/wilc1000/hif.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
  * All rights reserved.
  */
 
@@ -14,7 +14,8 @@ enum {
 	WILC_AP_MODE = 0x1,
 	WILC_STATION_MODE = 0x2,
 	WILC_GO_MODE = 0x3,
-	WILC_CLIENT_MODE = 0x4
+	WILC_CLIENT_MODE = 0x4,
+	WILC_MONITOR_MODE = 0x5
 };
 
 #define WILC_MAX_NUM_PROBED_SSID		10
@@ -31,6 +32,7 @@ enum {
 };
 
 #define WILC_MAX_ASSOC_RESP_FRAME_SIZE   256
+extern uint32_t cfg_packet_timeout;
 
 struct rf_info {
 	u8 link_speed;
@@ -47,6 +49,7 @@ enum host_if_state {
 	HOST_IF_WAITING_CONN_RESP	= 3,
 	HOST_IF_CONNECTED		= 4,
 	HOST_IF_P2P_LISTEN		= 5,
+	HOST_IF_EXTERNAL_AUTH		= 6,
 	HOST_IF_FORCE_32BIT		= 0xFFFFFFFF
 };
 
@@ -80,7 +83,8 @@ enum conn_event {
 
 enum {
 	WILC_HIF_SDIO = 0,
-	WILC_HIF_SPI = BIT(0)
+	WILC_HIF_SPI = BIT(0),
+	WILC_HIF_SDIO_GPIO_IRQ = BIT(1)
 };
 
 enum {
@@ -107,6 +111,7 @@ struct wilc_conn_info {
 	u8 bssid[ETH_ALEN];
 	u8 security;
 	enum authtype auth_type;
+	enum mfptype mfp_type;
 	u8 ch;
 	u8 *req_ies;
 	size_t req_ies_len;
@@ -123,7 +128,7 @@ struct wilc_remain_ch {
 	u32 duration;
 	void (*expired)(void *priv, u64 cookie);
 	void *arg;
-	u32 cookie;
+	u64 cookie;
 };
 
 struct wilc;
@@ -151,15 +156,20 @@ struct host_if_drv {
 };
 
 struct wilc_vif;
-int wilc_remove_wep_key(struct wilc_vif *vif, u8 index);
-int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index);
-int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
-			     u8 index);
-int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
-			    u8 index, u8 mode, enum authtype auth_type);
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  void (*deliver_to_stack)(struct wilc_vif *,
+							   u8 *, u32, u32, u8),
+				  void (*eap_buf_param)(void *), u8 *buff,
+				  unsigned int size, unsigned int pkt_offset,
+				  void *user_arg);
 int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
 		 u8 mode, u8 cipher_mode, u8 index);
+int wilc_add_igtk(struct wilc_vif *vif,
+		  const u8 *igtk, u8 igtk_key_len,
+		  const u8 *pn, u8 pn_len,
+		  const u8 *mac_addr, u8 mode, u8 index);
 s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac,
 			   u32 *out_val);
 int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
@@ -168,6 +178,7 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		    u8 cipher_mode);
 int wilc_set_pmkid_info(struct wilc_vif *vif, struct wilc_pmkid_attr *pmkid);
 int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr);
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr);
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,
 		      size_t ies_len);
 int wilc_disconnect(struct wilc_vif *vif);
@@ -206,9 +217,20 @@ int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats);
 int wilc_get_vif_idx(struct wilc_vif *vif);
 int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power);
 int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power);
+void wilc_set_wowlan_trigger(struct wilc_vif *vif, bool enabled);
+int wilc_set_external_auth_param(struct wilc_vif *vif,
+				  struct cfg80211_external_auth_params *param);
+/* 0 select antenna 1 , 2 select antenna mode , 2 allow the firmware to choose
+ * the best antenna
+ */
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode);
+int handle_scan_done(struct wilc_vif *vif, enum scan_event evt);
 void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length);
 void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length);
 void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length);
 void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
 				struct cfg80211_crypto_settings *crypto);
+void handle_connect_cancel(struct wilc_vif *vif);
+int wilc_of_parse_power_pins(struct wilc *wilc);
+void wilc_wlan_power(struct wilc *wilc, bool on);
 #endif
diff --git a/drivers/net/wireless/microchip/wilc1000/mon.c b/drivers/net/wireless/microchip/wilc1000/mon.c
index b5a1b65..2c9c2d9 100644
--- a/drivers/net/wireless/microchip/wilc1000/mon.c
+++ b/drivers/net/wireless/microchip/wilc1000/mon.c
@@ -21,6 +21,50 @@ struct wilc_wfi_radiotap_cb_hdr {
 #define TX_RADIOTAP_PRESENT ((1 << IEEE80211_RADIOTAP_RATE) |	\
 			     (1 << IEEE80211_RADIOTAP_TX_FLAGS))
 
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size)
+{
+	struct wilc_vif *vif = NULL;
+	struct sk_buff *skb = NULL;
+	struct wilc_wfi_radiotap_hdr *hdr;
+
+	vif = wilc_get_vif_from_type(wilc, WILC_MONITOR_MODE);
+	if (!vif) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG, "Monitor interface not up\n");
+		return;
+	}
+
+	skb = dev_alloc_skb(size + sizeof(*hdr));
+	if (!skb) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Monitor if: No memory to allocate skb");
+		return;
+	}
+#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+	skb_put_data(skb, buff, size);
+	hdr = skb_push(skb, sizeof(*hdr));
+#else
+	memcpy(skb_put(skb, size), buff, size);
+	hdr = (struct wilc_wfi_radiotap_hdr *)skb_push(skb, sizeof(*hdr));
+#endif
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
+	hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+	PRINT_D(vif->ndev, HOSTAPD_DBG,
+		"Radiotap len %d\n", hdr->hdr.it_len);
+	hdr->hdr.it_present = cpu_to_le32
+			(1 << IEEE80211_RADIOTAP_RATE); /* | */
+	PRINT_D(vif->ndev, HOSTAPD_DBG, "Presentflags %d\n",
+		hdr->hdr.it_present);
+	hdr->rate = 5; /* txrate->bitrate / 5; */
+	skb->dev = vif->ndev;
+	skb_reset_mac_header(skb);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = htons(ETH_P_802_2);
+	memset(skb->cb, 0, sizeof(skb->cb));
+	netif_rx(skb);
+}
+
 void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 {
 	u32 header, pkt_offset;
@@ -31,8 +75,11 @@ void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 	if (!mon_dev)
 		return;
 
-	if (!netif_running(mon_dev))
+	if (!netif_running(mon_dev)) {
+		PRINT_D(mon_dev, HOSTAPD_DBG,
+			"Monitor interface already RUNNING\n");
 		return;
+	}
 
 	/* Get WILC header */
 	header = get_unaligned_le32(buff - HOST_HDR_OFFSET);
@@ -46,12 +93,20 @@ void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 		/* hostapd callback mgmt frame */
 
 		skb = dev_alloc_skb(size + sizeof(*cb_hdr));
-		if (!skb)
+		if (!skb) {
+			PRINT_D(mon_dev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
 		skb_put_data(skb, buff, size);
 
 		cb_hdr = skb_push(skb, sizeof(*cb_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		cb_hdr = (struct wilc_wfi_radiotap_cb_hdr *)skb_push(skb,
+							    sizeof(*cb_hdr));
+	#endif
 		memset(cb_hdr, 0, sizeof(*cb_hdr));
 
 		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
@@ -72,16 +127,28 @@ void wilc_wfi_monitor_rx(struct net_device *mon_dev, u8 *buff, u32 size)
 	} else {
 		skb = dev_alloc_skb(size + sizeof(*hdr));
 
-		if (!skb)
+		if (!skb) {
+			PRINT_D(mon_dev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
 		skb_put_data(skb, buff, size);
 		hdr = skb_push(skb, sizeof(*hdr));
-		memset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		hdr = (struct wilc_wfi_radiotap_hdr *)skb_push(skb,
+							       sizeof(*hdr));
+	#endif
+		memset(hdr, 0, sizeof(*hdr));
 		hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
 		hdr->hdr.it_len = cpu_to_le16(sizeof(*hdr));
+		PRINT_D(mon_dev, HOSTAPD_DBG,
+			"Radiotap len %d\n", hdr->hdr.it_len);
 		hdr->hdr.it_present = cpu_to_le32
-				(1 << IEEE80211_RADIOTAP_RATE);
+				(1 << IEEE80211_RADIOTAP_RATE); /* | */
+		PRINT_D(mon_dev, HOSTAPD_DBG, "Presentflags %d\n",
+			hdr->hdr.it_present);
 		hdr->rate = 5;
 	}
 
@@ -103,6 +170,16 @@ struct tx_complete_mon_data {
 static void mgmt_tx_complete(void *priv, int status)
 {
 	struct tx_complete_mon_data *pv_data = priv;
+	u8 *buf =  pv_data->buff;
+
+	if (status == 1) {
+		if (buf[0] == 0x10 || buf[0] == 0xb0)
+			pr_info("Packet sent Size = %d Add = %p.\n",
+				pv_data->size, pv_data->buff);
+	} else {
+		pr_info("Couldn't send packet Size = %d Add = %p.\n",
+			pv_data->size, pv_data->buff);
+	}
 	/*
 	 * in case of fully hosting mode, the freeing will be done
 	 * in response to the cfg packet
@@ -116,13 +193,18 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct tx_complete_mon_data *mgmt_tx = NULL;
 
-	if (!dev)
+	if (!dev) {
+		PRINT_ER(dev, "ERROR: dev == NULL\n");
 		return -EFAULT;
+	}
 
 	netif_stop_queue(dev);
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_ATOMIC);
-	if (!mgmt_tx)
+	if (!mgmt_tx) {
+		PRINT_ER(dev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
 		return -ENOMEM;
+	}
 
 	mgmt_tx->buff = kmemdup(buf, len, GFP_ATOMIC);
 	if (!mgmt_tx->buff) {
@@ -144,53 +226,28 @@ static netdev_tx_t wilc_wfi_mon_xmit(struct sk_buff *skb,
 {
 	u32 rtap_len, ret = 0;
 	struct wilc_wfi_mon_priv  *mon_priv;
-	struct sk_buff *skb2;
-	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
 	u8 srcadd[ETH_ALEN];
 	u8 bssid[ETH_ALEN];
 
 	mon_priv = netdev_priv(dev);
-	if (!mon_priv)
+	if (!mon_priv) {
+		PRINT_ER(dev, "Monitor interface private structure is NULL\n");
 		return -EFAULT;
-
+	}
 	rtap_len = ieee80211_get_radiotap_len(skb->data);
-	if (skb->len < rtap_len)
+	if (skb->len < rtap_len) {
+		PRINT_ER(dev, "Error in radiotap header\n");
 		return -1;
+	}
 
 	skb_pull(skb, rtap_len);
 
-	if (skb->data[0] == 0xc0 && is_broadcast_ether_addr(&skb->data[4])) {
-		skb2 = dev_alloc_skb(skb->len + sizeof(*cb_hdr));
-		if (!skb2)
-			return -ENOMEM;
-
-		skb_put_data(skb2, skb->data, skb->len);
-
-		cb_hdr = skb_push(skb2, sizeof(*cb_hdr));
-		memset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));
-
-		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
-
-		cb_hdr->hdr.it_len = cpu_to_le16(sizeof(*cb_hdr));
-
-		cb_hdr->hdr.it_present = cpu_to_le32(TX_RADIOTAP_PRESENT);
-
-		cb_hdr->rate = 5;
-		cb_hdr->tx_flags = 0x0004;
-
-		skb2->dev = dev;
-		skb_reset_mac_header(skb2);
-		skb2->ip_summed = CHECKSUM_UNNECESSARY;
-		skb2->pkt_type = PACKET_OTHERHOST;
-		skb2->protocol = htons(ETH_P_802_2);
-		memset(skb2->cb, 0, sizeof(skb2->cb));
-
-		netif_rx(skb2);
-
-		return 0;
-	}
 	skb->dev = mon_priv->real_ndev;
 
+	PRINT_D(dev, HOSTAPD_DBG, "Skipping the radiotap header\n");
+	PRINT_D(dev, HOSTAPD_DBG, "SKB netdevice name = %s\n", skb->dev->name);
+	PRINT_D(dev, HOSTAPD_DBG, "MONITOR real dev name = %s\n",
+		mon_priv->real_ndev->name);
 	ether_addr_copy(srcadd, &skb->data[10]);
 	ether_addr_copy(bssid, &skb->data[16]);
 	/*
@@ -200,7 +257,7 @@ static netdev_tx_t wilc_wfi_mon_xmit(struct sk_buff *skb,
 	if (!(memcmp(srcadd, bssid, 6))) {
 		ret = mon_mgmt_tx(mon_priv->real_ndev, skb->data, skb->len);
 		if (ret)
-			netdev_err(dev, "fail to mgmt tx\n");
+			PRINT_ER(dev, "fail to mgmt tx\n");
 		dev_kfree_skb(skb);
 	} else {
 		ret = wilc_mac_xmit(skb, mon_priv->real_ndev);
@@ -225,16 +282,20 @@ struct net_device *wilc_wfi_init_mon_interface(struct wilc *wl,
 		return wl->monitor_dev;
 
 	wl->monitor_dev = alloc_etherdev(sizeof(struct wilc_wfi_mon_priv));
-	if (!wl->monitor_dev)
+	if (!wl->monitor_dev) {
+		PRINT_ER(real_dev, "failed to allocate memory\n");
 		return NULL;
-
+	}
 	wl->monitor_dev->type = ARPHRD_IEEE80211_RADIOTAP;
 	strlcpy(wl->monitor_dev->name, name, IFNAMSIZ);
 	wl->monitor_dev->netdev_ops = &wilc_wfi_netdev_ops;
+#if KERNEL_VERSION(4, 11, 9) <= LINUX_VERSION_CODE
 	wl->monitor_dev->needs_free_netdev = true;
-
+#else
+	wl->monitor_dev->destructor = free_netdev;
+#endif
 	if (register_netdevice(wl->monitor_dev)) {
-		netdev_err(real_dev, "register_netdevice failed\n");
+		PRINT_ER(real_dev, "register_netdevice failed\n");
 		free_netdev(wl->monitor_dev);
 		return NULL;
 	}
@@ -250,9 +311,14 @@ void wilc_wfi_deinit_mon_interface(struct wilc *wl, bool rtnl_locked)
 	if (!wl->monitor_dev)
 		return;
 
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG,
+		   "In Deinit monitor interface\n");
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG, "Unregister monitor netdev\n");
 	if (rtnl_locked)
 		unregister_netdevice(wl->monitor_dev);
 	else
 		unregister_netdev(wl->monitor_dev);
+	PRINT_INFO(wl->monitor_dev, HOSTAPD_DBG,
+		   "Deinit monitor interface done\n");
 	wl->monitor_dev = NULL;
 }
diff --git a/drivers/net/wireless/microchip/wilc1000/netdev.c b/drivers/net/wireless/microchip/wilc1000/netdev.c
index 20615c7..824afea 100644
--- a/drivers/net/wireless/microchip/wilc1000/netdev.c
+++ b/drivers/net/wireless/microchip/wilc1000/netdev.c
@@ -18,18 +18,152 @@
 /* latest API version supported */
 #define WILC1000_API_VER		1
 
-#define WILC1000_FW_PREFIX		"atmel/wilc1000_wifi_firmware-"
+#define WILC1000_FW_PREFIX		"mchp/wilc1000_wifi_firmware"
 #define __WILC1000_FW(api)		WILC1000_FW_PREFIX #api ".bin"
 #define WILC1000_FW(api)		__WILC1000_FW(api)
 
+#define WILC3000_API_VER		1
+
+#define WILC3000_FW_PREFIX		"mchp/wilc3000_wifi_firmware"
+#define __WILC3000_FW(api)		WILC3000_FW_PREFIX #api ".bin"
+#define WILC3000_FW(api)		__WILC3000_FW(api)
+
+static int wilc_mac_open(struct net_device *ndev);
+static int wilc_mac_close(struct net_device *ndev);
+
+static int debug_running;
+static int recovery_on;
+int wait_for_recovery;
+static int debug_thread(void *arg)
+{
+	struct wilc *wl = arg;
+	struct wilc_vif *vif;
+	signed long timeout;
+	struct host_if_drv *hif_drv;
+	int i = 0;
+
+	complete(&wl->debug_thread_started);
+
+	while (1) {
+		int srcu_idx;
+		int ret;
+
+		if (!wl->initialized && !kthread_should_stop()) {
+			msleep(1000);
+			continue;
+		} else if (!wl->initialized) {
+			break;
+		}
+		ret = wait_for_completion_interruptible_timeout(
+			&wl->debug_thread_started, msecs_to_jiffies(6000));
+		if (ret > 0) {
+			while (!kthread_should_stop())
+				schedule();
+			pr_info("Exit debug thread\n");
+			return 0;
+		}
+		if (!debug_running || ret == -ERESTARTSYS)
+			continue;
+
+		pr_debug("%s *** Debug Thread Running ***cnt[%d]\n", __func__,
+			 cfg_packet_timeout);
+
+		if (cfg_packet_timeout < 5)
+			continue;
+
+		pr_info("%s <Recover>\n", __func__);
+		cfg_packet_timeout = 0;
+		timeout = 10;
+		recovery_on = 1;
+		wait_for_recovery = 1;
+
+		srcu_idx = srcu_read_lock(&wl->srcu);
+		list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+			/* close the interface only if it was open */
+			if (vif->mac_opened) {
+				wilc_mac_close(vif->ndev);
+				vif->restart = 1;
+			}
+		}
+
+		/* For Spi, clear 'is_init' flag so that protocol offset
+		 * register can be send to FW to setup required crc mode after
+		 * chip reset
+		 */
+		if (wl->io_type == WILC_HIF_SPI)
+			wl->hif_func->hif_clear_init(wl);
+
+		//TODO://Need to find way to call them in reverse
+		i = 0;
+		list_for_each_entry_rcu(vif, &wl->vif_list, list) {
+			struct wilc_conn_info *info;
+
+			/* Only open the interface manually closed earlier */
+			if (!vif->restart)
+				continue;
+			i++;
+			hif_drv = vif->priv.hif_drv;
+			while (wilc_mac_open(vif->ndev) && --timeout)
+				msleep(100);
+
+			if (timeout == 0)
+				PRINT_WRN(vif->ndev, GENERIC_DBG,
+					  "Couldn't restart ifc %d\n", i);
+
+			if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+				info = &hif_drv->conn_info;
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "notify the user with the Disconnection\n");
+				if (hif_drv->usr_scan_req.scan_result) {
+					PRINT_INFO(vif->ndev, GENERIC_DBG,
+						   "Abort the running OBSS Scan\n");
+					del_timer(&hif_drv->scan_timer);
+					handle_scan_done(vif,
+							 SCAN_EVENT_ABORTED);
+				}
+				if (info->conn_result) {
+					info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+							  0, info->arg);
+				} else {
+					PRINT_ER(vif->ndev,
+						 "Connect result NULL\n");
+				}
+				eth_zero_addr(hif_drv->assoc_bssid);
+				info->req_ies_len = 0;
+				kfree(info->req_ies);
+				info->req_ies = NULL;
+				hif_drv->hif_state = HOST_IF_IDLE;
+			}
+			vif->restart = 0;
+		}
+		srcu_read_unlock(&wl->srcu, srcu_idx);
+		recovery_on = 0;
+	}
+	return 0;
+}
+
+static void wilc_disable_irq(struct wilc *wilc, int wait)
+{
+	if (wait) {
+		pr_info("%s Disabling IRQ ...\n", __func__);
+		disable_irq(wilc->dev_irq_num);
+	} else {
+		pr_info("%s Disabling IRQ ...\n", __func__);
+		disable_irq_nosync(wilc->dev_irq_num);
+	}
+}
+
+static irqreturn_t host_wakeup_isr(int irq, void *user_data)
+{
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t isr_uh_routine(int irq, void *user_data)
 {
-	struct net_device *dev = user_data;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
+	struct wilc *wilc = user_data;
 
 	if (wilc->close) {
-		netdev_err(dev, "Can't handle UH interrupt\n");
+		pr_err("%s: Can't handle UH interrupt\n", __func__);
 		return IRQ_HANDLED;
 	}
 	return IRQ_WAKE_THREAD;
@@ -37,12 +171,10 @@ static irqreturn_t isr_uh_routine(int irq, void *user_data)
 
 static irqreturn_t isr_bh_routine(int irq, void *userdata)
 {
-	struct net_device *dev = userdata;
-	struct wilc_vif *vif = netdev_priv(userdata);
-	struct wilc *wilc = vif->wilc;
+	struct wilc *wilc = userdata;
 
 	if (wilc->close) {
-		netdev_err(dev, "Can't handle BH interrupt\n");
+		pr_err("%s: Can't handle BH interrupt\n", __func__);
 		return IRQ_HANDLED;
 	}
 
@@ -55,18 +187,33 @@ static int init_irq(struct net_device *dev)
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
-	int ret;
 
-	ret = request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
-				   isr_bh_routine,
-				   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-				   "WILC_IRQ", dev);
-	if (ret) {
-		netdev_err(dev, "Failed to request IRQ [%d]\n", ret);
-		return ret;
+	if (wl->dev_irq_num <= 0)
+		return 0;
+
+	if (wl->io_type == WILC_HIF_SPI ||
+	    wl->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		if (request_threaded_irq(wl->dev_irq_num, isr_uh_routine,
+					 isr_bh_routine,
+					 IRQF_TRIGGER_FALLING | IRQF_NO_SUSPEND,
+					 "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ [%d]\n",
+				 wl->dev_irq_num);
+			return -EINVAL;
+		}
+	} else {
+		if (request_irq(wl->dev_irq_num, host_wakeup_isr,
+				IRQF_TRIGGER_FALLING | IRQF_NO_SUSPEND,
+				"WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ [%d]\n",
+				 wl->dev_irq_num);
+			return -EINVAL;
+		}
 	}
-	netdev_dbg(dev, "IRQ request succeeded IRQ-NUM= %d\n", wl->dev_irq_num);
 
+	PRINT_INFO(dev, GENERIC_DBG, "IRQ request succeeded IRQ-NUM= %d\n",
+		   wl->dev_irq_num);
+	enable_irq_wake(wl->dev_irq_num);
 	return 0;
 }
 
@@ -93,72 +240,110 @@ void wilc_mac_indicate(struct wilc *wilc)
 	}
 }
 
-static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+static void free_eap_buff_params(void *vp)
 {
-	struct net_device *ndev = NULL;
-	struct wilc_vif *vif;
-	struct ieee80211_hdr *h = (struct ieee80211_hdr *)mac_header;
+	struct wilc_priv *priv;
 
-	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
-		if (vif->mode == WILC_STATION_MODE)
-			if (ether_addr_equal_unaligned(h->addr2, vif->bssid)) {
-				ndev = vif->ndev;
-				goto out;
-			}
-		if (vif->mode == WILC_AP_MODE)
-			if (ether_addr_equal_unaligned(h->addr1, vif->bssid)) {
-				ndev = vif->ndev;
-				goto out;
-			}
+	priv = (struct wilc_priv *)vp;
+
+	if (priv->buffered_eap) {
+		kfree(priv->buffered_eap->buff);
+		priv->buffered_eap->buff = NULL;
+
+		kfree(priv->buffered_eap);
+		priv->buffered_eap = NULL;
 	}
-out:
-	return ndev;
 }
 
-void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void eap_buff_timeout(struct timer_list *t)
+#else
+void eap_buff_timeout(unsigned long user)
+#endif
 {
-	struct wilc_vif *vif = netdev_priv(wilc_netdev);
-
-	if (bssid)
-		ether_addr_copy(vif->bssid, bssid);
-	else
-		eth_zero_addr(vif->bssid);
-
-	vif->mode = mode;
+	u8 null_bssid[ETH_ALEN] = {0};
+	u8 *assoc_bss;
+	static u8 timeout = 5;
+	int status = -1;
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+	struct wilc_priv *priv = from_timer(priv, t, eap_buff_timer);
+#else
+	struct wilc_priv *priv = (struct wilc_priv *)user;
+#endif
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	assoc_bss = priv->associated_bss;
+	if (!(memcmp(assoc_bss, null_bssid, ETH_ALEN)) && (timeout-- > 0)) {
+		mod_timer(&priv->eap_buff_timer,
+			  (jiffies + msecs_to_jiffies(10)));
+		return;
+	}
+	del_timer(&priv->eap_buff_timer);
+	timeout = 5;
+
+	status = wilc_send_buffered_eap(vif, wilc_frmw_to_host,
+					free_eap_buff_params,
+					priv->buffered_eap->buff,
+					priv->buffered_eap->size,
+					priv->buffered_eap->pkt_offset,
+					(void *)priv);
+	if (status)
+		PRINT_ER(vif->ndev, "Failed so send buffered eap\n");
 }
 
-int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)
+void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
 {
+	struct wilc_vif *vif = netdev_priv(wilc_netdev);
+	struct wilc *wilc = vif->wilc;
 	int srcu_idx;
-	u8 ret_val = 0;
-	struct wilc_vif *vif;
 
 	srcu_idx = srcu_read_lock(&wilc->srcu);
 	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
-		if (!is_zero_ether_addr(vif->bssid))
-			ret_val++;
+		if (wilc_netdev == vif->ndev) {
+			if (bssid)
+				ether_addr_copy(vif->bssid, bssid);
+			else
+				eth_zero_addr(vif->bssid);
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "set bssid [%pM]\n", vif->bssid);
+			vif->iftype = mode;
+		}
 	}
 	srcu_read_unlock(&wilc->srcu, srcu_idx);
-	return ret_val;
 }
 
+#define TX_BACKOFF_WEIGHT_INCR_STEP (1)
+#define TX_BACKOFF_WEIGHT_DECR_STEP (1)
+#define TX_BACKOFF_WEIGHT_MAX (0)
+#define TX_BACKOFF_WEIGHT_MIN (0)
+#define TX_BCKOFF_WGHT_MS (1)
+
 static int wilc_txq_task(void *vp)
 {
 	int ret;
 	u32 txq_count;
+	int backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+	signed long timeout;
 	struct wilc *wl = vp;
 
 	complete(&wl->txq_thread_started);
 	while (1) {
-		wait_for_completion(&wl->txq_event);
+		struct wilc_vif *vif = wilc_get_wl_to_vif(wl);
+		struct net_device *ndev = vif->ndev;
 
+		PRINT_INFO(ndev, TX_DBG, "txq_task Taking a nap\n");
+		if (wait_for_completion_interruptible(&wl->txq_event))
+			continue;
+		PRINT_INFO(ndev, TX_DBG, "txq_task Who waked me up\n");
 		if (wl->close) {
 			complete(&wl->txq_thread_started);
 
 			while (!kthread_should_stop())
 				schedule();
+			PRINT_INFO(ndev, TX_DBG, "TX thread stopped\n");
 			break;
 		}
+		PRINT_INFO(ndev, TX_DBG, "handle the tx packet\n");
 		do {
 			ret = wilc_wlan_handle_txq(wl, &txq_count);
 			if (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {
@@ -166,13 +351,38 @@ static int wilc_txq_task(void *vp)
 				struct wilc_vif *ifc;
 
 				srcu_idx = srcu_read_lock(&wl->srcu);
+				PRINT_INFO(ndev, TX_DBG, "Waking up queue\n");
 				list_for_each_entry_rcu(ifc, &wl->vif_list,
 							list) {
-					if (ifc->mac_opened && ifc->ndev)
+					if (ifc->mac_opened &&
+					    netif_queue_stopped(ifc->ndev))
 						netif_wake_queue(ifc->ndev);
 				}
 				srcu_read_unlock(&wl->srcu, srcu_idx);
 			}
+
+			if (ret == WILC_VMM_ENTRY_FULL_RETRY) {
+				timeout = msecs_to_jiffies(TX_BCKOFF_WGHT_MS <<
+							   backoff_weight);
+				do {
+			/* Back off from sending packets for some time.
+			 * schedule_timeout will allow RX task to run and free
+			 * buffers. Setting state to TASK_INTERRUPTIBLE will
+			 * put the thread back to CPU running queue when it's
+			 * signaled even if 'timeout' isn't elapsed. This gives
+			 * faster chance for reserved SK buffers to be freed
+			 */
+					set_current_state(TASK_INTERRUPTIBLE);
+					timeout = schedule_timeout(timeout);
+					} while (/*timeout*/0);
+				backoff_weight += TX_BACKOFF_WEIGHT_INCR_STEP;
+				if (backoff_weight > TX_BACKOFF_WEIGHT_MAX)
+					backoff_weight = TX_BACKOFF_WEIGHT_MAX;
+			} else if (backoff_weight > TX_BACKOFF_WEIGHT_MIN) {
+				backoff_weight -= TX_BACKOFF_WEIGHT_DECR_STEP;
+				if (backoff_weight < TX_BACKOFF_WEIGHT_MIN)
+					backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+			}
 		} while (ret == WILC_VMM_ENTRY_FULL_RETRY && !wl->close);
 	}
 	return 0;
@@ -182,20 +392,31 @@ static int wilc_wlan_get_firmware(struct net_device *dev)
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
-	int chip_id;
 	const struct firmware *wilc_fw;
+	char *firmware;
 	int ret;
 
-	chip_id = wilc_get_chipid(wilc, false);
+	if (wilc->chip == WILC_3000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC3000\n");
+		firmware = WILC3000_FW();
+	} else if (wilc->chip == WILC_1000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC1000\n");
+		firmware = WILC1000_FW();
+	} else {
+		return -EINVAL;
+	}
+
+	PRINT_INFO(dev, INIT_DBG, "loading firmware %s\n", firmware);
 
-	netdev_info(dev, "ChipID [%x] loading firmware [%s]\n", chip_id,
-		    WILC1000_FW(WILC1000_API_VER));
+	if (!(&vif->ndev->dev)) {
+		PRINT_ER(dev, "Dev  is NULL\n");
+		return -EINVAL;
+	}
 
-	ret = request_firmware(&wilc_fw, WILC1000_FW(WILC1000_API_VER),
-			       wilc->dev);
+	PRINT_INFO(vif->ndev, INIT_DBG, "WLAN firmware: %s\n", firmware);
+	ret = request_firmware(&wilc_fw, firmware, wilc->dev);
 	if (ret != 0) {
-		netdev_err(dev, "%s - firmware not available\n",
-			   WILC1000_FW(WILC1000_API_VER));
+		PRINT_ER(dev, "%s - firmware not available\n", firmware);
 		return -EINVAL;
 	}
 	wilc->firmware = wilc_fw;
@@ -209,39 +430,48 @@ static int wilc_start_firmware(struct net_device *dev)
 	struct wilc *wilc = vif->wilc;
 	int ret = 0;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Starting Firmware ...\n");
+
 	ret = wilc_wlan_start(wilc);
-	if (ret)
+	if (ret < 0) {
+		PRINT_ER(dev, "Failed to start Firmware\n");
 		return ret;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Waiting for FW to get ready ...\n");
 
 	if (!wait_for_completion_timeout(&wilc->sync_event,
-					 msecs_to_jiffies(5000)))
+					 msecs_to_jiffies(500))) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Firmware start timed out\n");
 		return -ETIME;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Firmware successfully started\n");
 
 	return 0;
 }
 
-static int wilc1000_firmware_download(struct net_device *dev)
+static int wilc_firmware_download(struct net_device *dev)
 {
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 	int ret = 0;
 
 	if (!wilc->firmware) {
-		netdev_err(dev, "Firmware buffer is NULL\n");
-		return -ENOBUFS;
+		PRINT_ER(dev, "Firmware buffer is NULL\n");
+		ret = -ENOBUFS;
 	}
-
+	PRINT_INFO(vif->ndev, INIT_DBG, "Downloading Firmware ...\n");
 	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
 					  wilc->firmware->size);
-	if (ret)
-		return ret;
+	if (ret < 0)
+		goto fail;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Download Succeeded\n");
 
+fail:
 	release_firmware(wilc->firmware);
 	wilc->firmware = NULL;
 
-	netdev_dbg(dev, "Download Succeeded\n");
-
-	return 0;
+	return ret;
 }
 
 static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
@@ -252,14 +482,14 @@ static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
 	u16 hw;
 	u32 w;
 
-	netdev_dbg(dev, "Start configuring Firmware\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Start configuring Firmware\n");
 	hif_drv = (struct host_if_drv *)priv->hif_drv;
-	netdev_dbg(dev, "Host = %p\n", hif_drv);
+	PRINT_D(vif->ndev, INIT_DBG, "Host = %p\n", hif_drv);
 
 	w = vif->iftype;
 	cpu_to_le32s(&w);
-	if (!wilc_wlan_cfg_set(vif, 1, WID_SET_OPERATION_MODE, (u8 *)&w, 4,
-			       0, 0))
+	if (!wilc_wlan_cfg_set(vif, 1, WID_SET_OPERATION_MODE, (u8 *)&w, 4, 0,
+			       0))
 		goto fail;
 
 	b = WILC_FW_BSS_TYPE_INFRA;
@@ -274,7 +504,7 @@ static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
 	if (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, &b, 1, 0, 0))
 		goto fail;
 
-	b = WILC_FW_PREAMBLE_SHORT;
+	b = WILC_FW_PREAMBLE_AUTO;
 	if (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, &b, 1, 0, 0))
 		goto fail;
 
@@ -406,7 +636,7 @@ static int wilc_init_fw_config(struct net_device *dev, struct wilc_vif *vif)
 
 	b = 1;
 	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, &b, 1,
-			       1, 1))
+			       1, 0))
 		goto fail;
 
 	return 0;
@@ -420,7 +650,20 @@ static void wlan_deinitialize_threads(struct net_device *dev)
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+	if (!recovery_on) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinit debug Thread\n");
+		debug_running = false;
+		if (&wl->debug_thread_started)
+			complete(&wl->debug_thread_started);
+		if (wl->debug_thread) {
+			kthread_stop(wl->debug_thread);
+			wl->debug_thread = NULL;
+		}
+	}
+
 	wl->close = 1;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 
 	complete(&wl->txq_event);
 
@@ -432,36 +675,50 @@ static void wlan_deinitialize_threads(struct net_device *dev)
 
 static void wilc_wlan_deinitialize(struct net_device *dev)
 {
+	int ret;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wl = vif->wilc;
 
 	if (!wl) {
-		netdev_err(dev, "wl is NULL\n");
+		PRINT_ER(dev, "wl is NULL\n");
 		return;
 	}
 
 	if (wl->initialized) {
-		netdev_info(dev, "Deinitializing wilc1000...\n");
-
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt) {
-			mutex_lock(&wl->hif_cs);
-			wl->hif_func->disable_interrupt(wl);
-			mutex_unlock(&wl->hif_cs);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing wilc  ...\n");
+
+		PRINT_D(vif->ndev, INIT_DBG, "destroy aging timer\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Disabling IRQ\n");
+		if (wl->io_type == WILC_HIF_SPI ||
+		    wl->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+			wilc_disable_irq(wl, 1);
+		} else {
+			if (wl->hif_func->disable_interrupt) {
+				mutex_lock(&wl->hif_cs);
+				wl->hif_func->disable_interrupt(wl);
+				mutex_unlock(&wl->hif_cs);
+			}
 		}
 		complete(&wl->txq_event);
 
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
 		wlan_deinitialize_threads(dev);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing IRQ\n");
 		deinit_irq(dev);
 
-		wilc_wlan_stop(wl, vif);
+		ret = wilc_wlan_stop(wl, vif);
+		if (ret != 0)
+			PRINT_ER(dev, "failed in wlan_stop\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing WILC Wlan\n");
 		wilc_wlan_cleanup(dev);
 
 		wl->initialized = false;
 
-		netdev_dbg(dev, "wilc1000 deinitialization Done\n");
+		PRINT_INFO(dev, INIT_DBG, "wilc deinitialization Done\n");
 	} else {
-		netdev_dbg(dev, "wilc1000 is not initialized\n");
+		PRINT_INFO(dev, INIT_DBG, "wilc is not initialized\n");
 	}
 }
 
@@ -470,15 +727,32 @@ static int wlan_initialize_threads(struct net_device *dev)
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Threads ...\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Creating kthread for transmission\n");
 	wilc->txq_thread = kthread_run(wilc_txq_task, (void *)wilc,
 				       "K_TXQ_TASK");
 	if (IS_ERR(wilc->txq_thread)) {
 		netdev_err(dev, "couldn't create TXQ thread\n");
-		wilc->close = 0;
+		wilc->close = 1;
 		return PTR_ERR(wilc->txq_thread);
 	}
 	wait_for_completion(&wilc->txq_thread_started);
 
+	if (!debug_running) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Creating kthread for Debugging\n");
+		wilc->debug_thread = kthread_run(debug_thread, (void *)wilc,
+						 "WILC_DEBUG");
+		if (IS_ERR(wilc->debug_thread)) {
+			PRINT_ER(dev, "couldn't create debug thread\n");
+			wilc->close = 1;
+			kthread_stop(wilc->txq_thread);
+			return PTR_ERR(wilc->debug_thread);
+		}
+		debug_running = true;
+		wait_for_completion(&wilc->debug_thread_started);
+	}
+
 	return 0;
 }
 
@@ -492,53 +766,67 @@ static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
 		wl->close = 0;
 
 		ret = wilc_wlan_init(dev);
-		if (ret)
+		if (ret) {
+			PRINT_ER(dev, "Initializing WILC_Wlan FAILED\n");
 			return ret;
+		}
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "WILC Initialization done\n");
 
 		ret = wlan_initialize_threads(dev);
-		if (ret)
+		if (ret) {
+			PRINT_ER(dev, "Initializing Threads FAILED\n");
 			goto fail_wilc_wlan;
+		}
 
-		if (wl->dev_irq_num && init_irq(dev)) {
-			ret = -EIO;
+		ret = init_irq(dev);
+		if (ret)
 			goto fail_threads;
-		}
 
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->enable_interrupt &&
+		if (wl->io_type == WILC_HIF_SDIO &&
 		    wl->hif_func->enable_interrupt(wl)) {
+			PRINT_ER(dev, "couldn't initialize IRQ\n");
 			ret = -EIO;
 			goto fail_irq_init;
 		}
 
 		ret = wilc_wlan_get_firmware(dev);
-		if (ret)
+		if (ret) {
+			PRINT_ER(dev, "Can't get firmware\n");
 			goto fail_irq_enable;
+		}
 
-		ret = wilc1000_firmware_download(dev);
-		if (ret)
+		ret = wilc_firmware_download(dev);
+		if (ret) {
+			PRINT_ER(dev, "Failed to download firmware\n");
 			goto fail_irq_enable;
+		}
 
 		ret = wilc_start_firmware(dev);
-		if (ret)
+		if (ret) {
+			PRINT_ER(dev, "Failed to start firmware\n");
 			goto fail_irq_enable;
+		}
 
 		if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
 			int size;
-			char firmware_ver[20];
+			char firmware_ver[50];
 
 			size = wilc_wlan_cfg_get_val(wl, WID_FIRMWARE_VERSION,
 						     firmware_ver,
 						     sizeof(firmware_ver));
 			firmware_ver[size] = '\0';
-			netdev_dbg(dev, "Firmware Ver = %s\n", firmware_ver);
+			PRINT_INFO(dev, INIT_DBG, "WILC Firmware Ver = %s\n",
+				   firmware_ver);
 		}
 
 		ret = wilc_init_fw_config(dev, vif);
-		if (ret) {
+		if (ret < 0) {
 			netdev_err(dev, "Failed to configure firmware\n");
+			ret = -EIO;
 			goto fail_fw_start;
 		}
+
 		wl->initialized = true;
 		return 0;
 
@@ -546,19 +834,18 @@ static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
 		wilc_wlan_stop(wl, vif);
 
 fail_irq_enable:
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt)
+		if (wl->io_type == WILC_HIF_SDIO)
 			wl->hif_func->disable_interrupt(wl);
 fail_irq_init:
-		if (wl->dev_irq_num)
-			deinit_irq(dev);
+		deinit_irq(dev);
+
 fail_threads:
 		wlan_deinitialize_threads(dev);
 fail_wilc_wlan:
 		wilc_wlan_cleanup(dev);
 		netdev_err(dev, "WLAN initialization FAILED\n");
 	} else {
-		netdev_dbg(dev, "wilc1000 already initialized\n");
+		PRINT_WRN(vif->ndev, INIT_DBG, "wilc already initialized\n");
 	}
 	return ret;
 }
@@ -575,46 +862,73 @@ static int wilc_mac_open(struct net_device *ndev)
 {
 	struct wilc_vif *vif = netdev_priv(ndev);
 	struct wilc *wl = vif->wilc;
-	unsigned char mac_add[ETH_ALEN] = {0};
 	int ret = 0;
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 	struct mgmt_frame_regs mgmt_regs = {};
+#endif
 
 	if (!wl || !wl->dev) {
 		netdev_err(ndev, "device not ready\n");
 		return -ENODEV;
 	}
 
-	netdev_dbg(ndev, "MAC OPEN[%p]\n", ndev);
+	PRINT_INFO(ndev, INIT_DBG, "MAC OPEN[%p] %s\n", ndev, ndev->name);
 
-	ret = wilc_init_host_int(ndev);
-	if (ret)
-		return ret;
+	if (wl->open_ifcs == 0)
+		wilc_bt_power_up(wl, DEV_WIFI);
+
+	if (!recovery_on) {
+		ret = wilc_init_host_int(ndev);
+		if (ret < 0) {
+			PRINT_ER(ndev, "Failed to initialize host interface\n");
+			return ret;
+		}
+	}
 
+	PRINT_INFO(vif->ndev, INIT_DBG, "*** re-init ***\n");
 	ret = wilc_wlan_initialize(ndev, vif);
 	if (ret) {
-		wilc_deinit_host_int(ndev);
+		PRINT_ER(ndev, "Failed to initialize wilc\n");
+		if (!recovery_on)
+			wilc_deinit_host_int(ndev);
 		return ret;
 	}
 
+	wait_for_recovery = 0;
 	wilc_set_operation_mode(vif, wilc_get_vif_idx(vif), vif->iftype,
 				vif->idx);
-	wilc_get_mac_address(vif, mac_add);
-	netdev_dbg(ndev, "Mac address: %pM\n", mac_add);
-	ether_addr_copy(ndev->dev_addr, mac_add);
+
+	if (is_valid_ether_addr(ndev->dev_addr))
+		wilc_set_mac_address(vif, ndev->dev_addr);
+	else
+		wilc_get_mac_address(vif, ndev->dev_addr);
+	netdev_dbg(ndev, "Mac address: %pM\n", ndev->dev_addr);
 
 	if (!is_valid_ether_addr(ndev->dev_addr)) {
-		netdev_err(ndev, "Wrong MAC address\n");
+		PRINT_ER(ndev, "Wrong MAC address\n");
 		wilc_deinit_host_int(ndev);
 		wilc_wlan_deinitialize(ndev);
 		return -EINVAL;
 	}
 
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 	mgmt_regs.interface_stypes = vif->mgmt_reg_stypes;
 	/* so we detect a change */
 	vif->mgmt_reg_stypes = 0;
+
 	wilc_update_mgmt_frame_registrations(vif->ndev->ieee80211_ptr->wiphy,
 					     vif->ndev->ieee80211_ptr,
 					     &mgmt_regs);
+#else
+	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
+				 vif->ndev->ieee80211_ptr,
+				 vif->frame_reg[0].type,
+				 vif->frame_reg[0].reg);
+	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
+				 vif->ndev->ieee80211_ptr,
+				 vif->frame_reg[1].type,
+				 vif->frame_reg[1].reg);
+#endif
 	netif_wake_queue(ndev);
 	wl->open_ifcs++;
 	vif->mac_opened = 1;
@@ -628,6 +942,52 @@ static struct net_device_stats *mac_stats(struct net_device *dev)
 	return &vif->netstats;
 }
 
+static int wilc_set_mac_addr(struct net_device *dev, void *p)
+{
+	int result;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc = vif->wilc;
+	struct sockaddr *addr = (struct sockaddr *)p;
+	unsigned char mac_addr[ETH_ALEN];
+	struct wilc_vif *tmp_vif;
+	int srcu_idx;
+
+	if (!is_valid_ether_addr(addr->sa_data)) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Invalid MAC address\n");
+		return -EADDRNOTAVAIL;
+	}
+
+	if (!vif->mac_opened) {
+		eth_commit_mac_addr_change(dev, p);
+		return 0;
+	}
+
+	/* Verify MAC Address is not already in use: */
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(tmp_vif, &wilc->vif_list, list) {
+		wilc_get_mac_address(tmp_vif, mac_addr);
+		if (ether_addr_equal(addr->sa_data, mac_addr)) {
+			if (vif != tmp_vif) {
+				PRINT_INFO(vif->ndev, INIT_DBG,
+					   "MAC address is already in use\n");
+				srcu_read_unlock(&wilc->srcu, srcu_idx);
+				return -EADDRNOTAVAIL;
+			}
+			srcu_read_unlock(&wilc->srcu, srcu_idx);
+			return 0;
+		}
+	}
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
+
+	/* configure new MAC address */
+	result = wilc_set_mac_address(vif, (u8 *)addr->sa_data);
+	if (result)
+		return result;
+
+	eth_commit_mac_addr_change(dev, p);
+	return result;
+}
+
 static void wilc_set_multicast_list(struct net_device *dev)
 {
 	struct netdev_hw_addr *ha;
@@ -636,16 +996,25 @@ static void wilc_set_multicast_list(struct net_device *dev)
 	u8 *mc_list;
 	u8 *cur_mc;
 
-	if (dev->flags & IFF_PROMISC)
+	PRINT_INFO(vif->ndev, INIT_DBG,
+		   "Setting mcast List with count = %d.\n", dev->mc.count);
+	if (dev->flags & IFF_PROMISC) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Set promiscuous mode ON retrieve all pkts\n");
 		return;
+	}
 
 	if (dev->flags & IFF_ALLMULTI ||
 	    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Disable mcast filter retrieve multicast pkts\n");
 		wilc_setup_multicast_filter(vif, 0, 0, NULL);
 		return;
 	}
 
 	if (dev->mc.count == 0) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Enable mcast filter retrieve directed pkts only\n");
 		wilc_setup_multicast_filter(vif, 1, 0, NULL);
 		return;
 	}
@@ -671,6 +1040,14 @@ static void wilc_tx_complete(void *priv, int status)
 {
 	struct tx_complete_data *pv_data = priv;
 
+	if (status == 1)
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			   "Packet sentSize= %d Add= %p SKB= %p\n",
+			   pv_data->size, pv_data->buff, pv_data->skb);
+	else
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			   "Couldn't send pkt Size= %d Add= %p SKB= %p\n",
+			   pv_data->size, pv_data->buff, pv_data->skb);
 	dev_kfree_skb(pv_data->skb);
 	kfree(pv_data);
 }
@@ -682,6 +1059,8 @@ netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
 	struct tx_complete_data *tx_data = NULL;
 	int queue_count;
 
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Sending packet just received from TCP/IP\n");
 	if (skb->dev != ndev) {
 		netdev_err(ndev, "Packet not destined to this device\n");
 		return NETDEV_TX_OK;
@@ -689,6 +1068,7 @@ netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
 
 	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
 	if (!tx_data) {
+		PRINT_ER(ndev, "Failed to alloc memory for tx_data struct\n");
 		dev_kfree_skb(skb);
 		netif_wake_queue(ndev);
 		return NETDEV_TX_OK;
@@ -698,9 +1078,13 @@ netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
 	tx_data->size = skb->len;
 	tx_data->skb  = skb;
 
+	PRINT_D(vif->ndev, TX_DBG, "Sending pkt Size= %d Add= %p SKB= %p\n",
+		tx_data->size, tx_data->buff, tx_data->skb);
+	PRINT_D(vif->ndev, TX_DBG, "Adding tx pkt to TX Queue\n");
 	vif->netstats.tx_packets++;
 	vif->netstats.tx_bytes += tx_data->size;
-	queue_count = wilc_wlan_txq_add_net_pkt(ndev, (void *)tx_data,
+	tx_data->vif = vif;
+	queue_count = wilc_wlan_txq_add_net_pkt(ndev, tx_data,
 						tx_data->buff, tx_data->size,
 						wilc_tx_complete);
 
@@ -724,21 +1108,26 @@ static int wilc_mac_close(struct net_device *ndev)
 	struct wilc_vif *vif = netdev_priv(ndev);
 	struct wilc *wl = vif->wilc;
 
-	netdev_dbg(ndev, "Mac close\n");
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Mac close\n");
 
-	if (wl->open_ifcs > 0)
+	if (wl->open_ifcs > 0) {
 		wl->open_ifcs--;
-	else
+	} else {
+		PRINT_ER(ndev, "MAC close called with no opened interfaces\n");
 		return 0;
+	}
 
 	if (vif->ndev) {
 		netif_stop_queue(vif->ndev);
 
+	handle_connect_cancel(vif);
+
+	if (!recovery_on)
 		wilc_deinit_host_int(vif->ndev);
 	}
 
 	if (wl->open_ifcs == 0) {
-		netdev_dbg(ndev, "Deinitializing wilc1000\n");
+		netdev_dbg(ndev, "Deinitializing wilc\n");
 		wl->close = 1;
 		wilc_wlan_deinitialize(ndev);
 	}
@@ -748,48 +1137,84 @@ static int wilc_mac_close(struct net_device *ndev)
 	return 0;
 }
 
-void wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size,
-		       u32 pkt_offset)
+void wilc_frmw_to_host(struct wilc_vif *vif, u8 *buff, u32 size,
+		       u32 pkt_offset, u8 status)
 {
 	unsigned int frame_len = 0;
 	int stats;
 	unsigned char *buff_to_send = NULL;
 	struct sk_buff *skb;
-	struct net_device *wilc_netdev;
-	struct wilc_vif *vif;
-
-	if (!wilc)
-		return;
-
-	wilc_netdev = get_if_handler(wilc, buff);
-	if (!wilc_netdev)
-		return;
+	struct wilc_priv *priv;
+	u8 null_bssid[ETH_ALEN] = {0};
 
 	buff += pkt_offset;
-	vif = netdev_priv(wilc_netdev);
-
-	if (size > 0) {
-		frame_len = size;
-		buff_to_send = buff;
-
-		skb = dev_alloc_skb(frame_len);
-		if (!skb)
-			return;
+	priv = &vif->priv;
 
-		skb->dev = wilc_netdev;
-
-		skb_put_data(skb, buff_to_send, frame_len);
+	if (size == 0) {
+		PRINT_ER(vif->ndev,
+			 "Discard sending packet with len = %d\n", size);
+		return;
+	}
 
-		skb->protocol = eth_type_trans(skb, wilc_netdev);
-		vif->netstats.rx_packets++;
-		vif->netstats.rx_bytes += frame_len;
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-		stats = netif_rx(skb);
-		netdev_dbg(wilc_netdev, "netif_rx ret value is: %d\n", stats);
+	frame_len = size;
+	buff_to_send = buff;
+
+	if (status == PKT_STATUS_NEW && buff_to_send[12] == 0x88 &&
+	    buff_to_send[13] == 0x8e &&
+	    (vif->iftype == WILC_STATION_MODE ||
+	     vif->iftype == WILC_CLIENT_MODE) &&
+	    ether_addr_equal_unaligned(priv->associated_bss, null_bssid)) {
+		if (!priv->buffered_eap) {
+			priv->buffered_eap = kmalloc(sizeof(struct
+							    wilc_buffered_eap),
+						     GFP_ATOMIC);
+			if (priv->buffered_eap) {
+				priv->buffered_eap->buff = NULL;
+				priv->buffered_eap->size = 0;
+				priv->buffered_eap->pkt_offset = 0;
+			} else {
+				PRINT_ER(vif->ndev,
+					 "failed to alloc buffered_eap\n");
+				return;
+			}
+		} else {
+			kfree(priv->buffered_eap->buff);
+		}
+		priv->buffered_eap->buff = kmalloc(size + pkt_offset,
+						   GFP_ATOMIC);
+		priv->buffered_eap->size = size;
+		priv->buffered_eap->pkt_offset = pkt_offset;
+		memcpy(priv->buffered_eap->buff, buff -
+		       pkt_offset, size + pkt_offset);
+	#if KERNEL_VERSION(4, 15, 0) > LINUX_VERSION_CODE
+		priv->eap_buff_timer.data = (unsigned long)priv;
+	#endif
+		mod_timer(&priv->eap_buff_timer, (jiffies +
+			  msecs_to_jiffies(10)));
+		return;
 	}
+	skb = dev_alloc_skb(frame_len);
+	if (!skb) {
+		PRINT_ER(vif->ndev, "Low memory - packet dropped\n");
+		return;
+	}
+
+	skb->dev = vif->ndev;
+#if KERNEL_VERSION(4, 13, 0) <= LINUX_VERSION_CODE
+	skb_put_data(skb, buff_to_send, frame_len);
+#else
+	memcpy(skb_put(skb, frame_len), buff_to_send, frame_len);
+#endif
+
+	skb->protocol = eth_type_trans(skb, vif->ndev);
+	vif->netstats.rx_packets++;
+	vif->netstats.rx_bytes += frame_len;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	stats = netif_rx(skb);
+	PRINT_D(vif->ndev, RX_DBG, "netif_rx ret value: %d\n", stats);
 }
 
-void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size, bool is_auth)
 {
 	int srcu_idx;
 	struct wilc_vif *vif;
@@ -797,11 +1222,39 @@ void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
 	srcu_idx = srcu_read_lock(&wilc->srcu);
 	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
 		u16 type = le16_to_cpup((__le16 *)buff);
+		struct wilc_priv *priv;
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
+		struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buff;
 		u32 type_bit = BIT(type >> 4);
+		u32 auth_bit = BIT(IEEE80211_STYPE_AUTH >> 4);
+#endif
+
+		priv = &vif->priv;
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
+		if ((vif->mgmt_reg_stypes & auth_bit &&
+		     ieee80211_is_auth(mgmt->frame_control)) &&
+		     vif->iftype == WILC_STATION_MODE && is_auth) {
+			wilc_wfi_mgmt_frame_rx(vif, buff, size);
+			break;
+		}
+#else
+		if ((type == vif->frame_reg[2].type && vif->frame_reg[2].reg) &&
+		    vif->iftype == WILC_STATION_MODE) {
+			wilc_wfi_mgmt_frame_rx(vif, buff, size);
+			break;
+		}
+#endif
 
-		if (vif->priv.p2p_listen_state &&
-		    vif->mgmt_reg_stypes & type_bit)
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
+		if (vif->mgmt_reg_stypes & type_bit &&
+		    vif->p2p_listen_state)
+			wilc_wfi_p2p_rx(vif, buff, size);
+#else
+		if (((type == vif->frame_reg[0].type && vif->frame_reg[0].reg) ||
+		     (type == vif->frame_reg[1].type && vif->frame_reg[1].reg)) &&
+		    vif->p2p_listen_state)
 			wilc_wfi_p2p_rx(vif, buff, size);
+#endif
 
 		if (vif->monitor_flag)
 			wilc_wfi_monitor_rx(wilc->monitor_dev, buff, size);
@@ -813,6 +1266,7 @@ static const struct net_device_ops wilc_netdev_ops = {
 	.ndo_init = mac_init_fn,
 	.ndo_open = wilc_mac_open,
 	.ndo_stop = wilc_mac_close,
+	.ndo_set_mac_address = wilc_set_mac_addr,
 	.ndo_start_xmit = wilc_mac_xmit,
 	.ndo_get_stats = mac_stats,
 	.ndo_set_rx_mode  = wilc_set_multicast_list,
@@ -833,15 +1287,23 @@ void wilc_netdev_cleanup(struct wilc *wilc)
 
 	srcu_idx = srcu_read_lock(&wilc->srcu);
 	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
-		if (vif->ndev)
+		/* clear the mode */
+		wilc_set_operation_mode(vif, 0, 0, 0);
+		if (vif->ndev) {
+			PRINT_INFO(vif->ndev, INIT_DBG,
+				   "Unregistering netdev %p\n",
+				   vif->ndev);
 			unregister_netdev(vif->ndev);
+		}
 	}
 	srcu_read_unlock(&wilc->srcu, srcu_idx);
 
 	wilc_wfi_deinit_mon_interface(wilc, false);
+
 	flush_workqueue(wilc->hif_workqueue);
 	destroy_workqueue(wilc->hif_workqueue);
-
+	wilc->hif_workqueue = NULL;
+	/* update the list */
 	while (ifc_cnt < WILC_NUM_CONCURRENT_IFC) {
 		mutex_lock(&wilc->vif_mutex);
 		if (wilc->vif_num <= 0) {
@@ -851,7 +1313,6 @@ void wilc_netdev_cleanup(struct wilc *wilc)
 		vif = wilc_get_wl_to_vif(wilc);
 		if (!IS_ERR(vif))
 			list_del_rcu(&vif->list);
-
 		wilc->vif_num--;
 		mutex_unlock(&wilc->vif_mutex);
 		synchronize_srcu(&wilc->srcu);
@@ -859,12 +1320,17 @@ void wilc_netdev_cleanup(struct wilc *wilc)
 	}
 
 	wilc_wlan_cfg_deinit(wilc);
+#ifdef WILC_DEBUGFS
+	wilc_debugfs_remove();
+#endif
+	wilc_sysfs_exit();
 	wlan_deinit_locks(wilc);
 	kfree(wilc->bus_data);
 	wiphy_unregister(wilc->wiphy);
+	pr_info("Freeing wiphy\n");
 	wiphy_free(wilc->wiphy);
+	pr_info("Module_exit Done.\n");
 }
-EXPORT_SYMBOL_GPL(wilc_netdev_cleanup);
 
 static u8 wilc_get_available_idx(struct wilc *wl)
 {
@@ -906,22 +1372,28 @@ struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
 
 	SET_NETDEV_DEV(ndev, wiphy_dev(wl->wiphy));
 
+	vif->ndev->ml_priv = vif;
 	vif->priv.wdev.wiphy = wl->wiphy;
 	vif->priv.wdev.netdev = ndev;
 	vif->priv.wdev.iftype = type;
 	vif->priv.dev = ndev;
 
+	vif->priv.dev = ndev;
 	if (rtnl_locked)
 		ret = register_netdevice(ndev);
 	else
 		ret = register_netdev(ndev);
 
 	if (ret) {
+		pr_err("Device couldn't be registered - %s\n", ndev->name);
 		free_netdev(ndev);
 		return ERR_PTR(-EFAULT);
 	}
-
+#if KERNEL_VERSION(4, 11, 9) <= LINUX_VERSION_CODE
 	ndev->needs_free_netdev = true;
+#else
+	ndev->destructor = free_netdev;
+#endif
 	vif->iftype = vif_type;
 	vif->idx = wilc_get_available_idx(wl);
 	vif->mac_opened = 0;
@@ -936,3 +1408,4 @@ struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
 
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(WILC1000_FW(WILC1000_API_VER));
+MODULE_FIRMWARE(WILC3000_FW(WILC3000_API_VER));
diff --git a/drivers/net/wireless/microchip/wilc1000/netdev.h b/drivers/net/wireless/microchip/wilc1000/netdev.h
index d0a006b..f06d45a 100644
--- a/drivers/net/wireless/microchip/wilc1000/netdev.h
+++ b/drivers/net/wireless/microchip/wilc1000/netdev.h
@@ -18,6 +18,131 @@
 #include "wlan.h"
 #include "wlan_cfg.h"
 
+extern int wait_for_recovery;
+
+#if KERNEL_VERSION(3, 14, 0) > LINUX_VERSION_CODE
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+
+static inline bool ether_addr_equal_unaligned(const u8 *addr1, const u8 *addr2)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	return ether_addr_equal(addr1, addr2);
+#else
+	return memcmp(addr1, addr2, ETH_ALEN) == 0;
+#endif
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0) */
+
+#if KERNEL_VERSION(3, 12, 0) > LINUX_VERSION_CODE
+#define PTR_ERR_OR_ZERO(ptr) PTR_RET(ptr)
+#endif
+
+#if KERNEL_VERSION(3, 13, 0) > LINUX_VERSION_CODE
+/*
+ * Create a contiguous bitmask starting at bit position @l and ending at
+ * position @h. For example
+ * GENMASK_ULL(39, 21) gives us the 64bit vector 0x000000ffffe00000.
+ */
+#define GENMASK(h, l) \
+	(((~UL(0)) - (UL(1) << (l)) + 1) & \
+	 (~UL(0) >> (BITS_PER_LONG - 1 - (h))))
+#endif
+
+#if KERNEL_VERSION(4, 9, 0) > LINUX_VERSION_CODE
+#ifdef __CHECKER__
+#define __BUILD_BUG_ON_NOT_POWER_OF_2(n) (0)
+#else
+/* Force a compilation error if a constant expression is not a power of 2 */
+#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)	\
+	BUILD_BUG_ON(((n) & ((n) - 1)) != 0)
+#endif
+
+/*
+ * Bitfield access macros
+ *
+ * FIELD_{GET,PREP} macros take as first parameter shifted mask
+ * from which they extract the base mask and shift amount.
+ * Mask must be a compilation time constant.
+ *
+ * Example:
+ *
+ *  #define REG_FIELD_A  GENMASK(6, 0)
+ *  #define REG_FIELD_B  BIT(7)
+ *  #define REG_FIELD_C  GENMASK(15, 8)
+ *  #define REG_FIELD_D  GENMASK(31, 16)
+ *
+ * Get:
+ *  a = FIELD_GET(REG_FIELD_A, reg);
+ *  b = FIELD_GET(REG_FIELD_B, reg);
+ *
+ * Set:
+ *  reg = FIELD_PREP(REG_FIELD_A, 1) |
+ *	  FIELD_PREP(REG_FIELD_B, 0) |
+ *	  FIELD_PREP(REG_FIELD_C, c) |
+ *	  FIELD_PREP(REG_FIELD_D, 0x40);
+ *
+ * Modify:
+ *  reg &= ~REG_FIELD_C;
+ *  reg |= FIELD_PREP(REG_FIELD_C, c);
+ */
+
+#define __bf_shf(x) (__builtin_ffsll(x) - 1)
+
+#define __BF_FIELD_CHECK(_mask, _reg, _val, _pfx)			\
+	({								\
+		BUILD_BUG_ON_MSG(!__builtin_constant_p(_mask),		\
+				 _pfx "mask is not constant");		\
+		BUILD_BUG_ON_MSG(!(_mask), _pfx "mask is zero");	\
+		BUILD_BUG_ON_MSG(__builtin_constant_p(_val) ?		\
+				 ~((_mask) >> __bf_shf(_mask)) & (_val) : 0, \
+				 _pfx "value too large for the field"); \
+		BUILD_BUG_ON_MSG((_mask) > (typeof(_reg))~0ull,		\
+				 _pfx "type of reg too small for mask"); \
+		__BUILD_BUG_ON_NOT_POWER_OF_2((_mask) +			\
+					      (1ULL << __bf_shf(_mask))); \
+	})
+/**
+ * FIELD_GET() - extract a bitfield element
+ * @_mask: shifted mask defining the field's length and position
+ * @_reg:  32bit value of entire bitfield
+ *
+ * FIELD_GET() extracts the field specified by @_mask from the
+ * bitfield passed in as @_reg by masking and shifting it down.
+ */
+#define FIELD_GET(_mask, _reg)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, _reg, 0U, "FIELD_GET: ");	\
+		(typeof(_mask))(((_reg) & (_mask)) >> __bf_shf(_mask));	\
+	})
+
+/**
+ * FIELD_PREP() - prepare a bitfield element
+ * @_mask: shifted mask defining the field's length and position
+ * @_val:  value to put in the field
+ *
+ * FIELD_PREP() masks and shifts up the value.  The result should
+ * be combined with other fields of the bitfield using logical OR.
+ */
+#define FIELD_PREP(_mask, _val)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, 0ULL, _val, "FIELD_PREP: ");	\
+		((typeof(_mask))(_val) << __bf_shf(_mask)) & (_mask);	\
+	})
+#endif
+
 #define FLOW_CONTROL_LOWER_THRESHOLD		128
 #define FLOW_CONTROL_UPPER_THRESHOLD		256
 
@@ -27,6 +152,10 @@
 #define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
 #define DEFAULT_LINK_SPEED			72
 
+#define ANT_SWTCH_INVALID_GPIO_CTRL		0
+#define ANT_SWTCH_SNGL_GPIO_CTRL		1
+#define ANT_SWTCH_DUAL_GPIO_CTRL		2
+
 struct wilc_wfi_stats {
 	unsigned long rx_packets;
 	unsigned long tx_packets;
@@ -45,12 +174,6 @@ struct wilc_wfi_key {
 	u32 cipher;
 };
 
-struct wilc_wfi_wep_key {
-	u8 *key;
-	u8 key_len;
-	u8 key_idx;
-};
-
 struct sta_info {
 	u8 sta_associated_bss[WILC_MAX_NUM_STA][ETH_ALEN];
 };
@@ -62,22 +185,44 @@ struct wilc_wfi_p2p_listen_params {
 	u64 listen_cookie;
 };
 
+/* Struct to buffer eapol 1/4 frame */
+struct wilc_buffered_eap {
+	unsigned int size;
+	unsigned int pkt_offset;
+	u8 *buff;
+};
+
+struct wilc_p2p_var {
+	u8 local_random;
+	u8 recv_random;
+	bool is_wilc_ie;
+};
+
 static const u32 wilc_cipher_suites[] = {
-	WLAN_CIPHER_SUITE_WEP40,
-	WLAN_CIPHER_SUITE_WEP104,
 	WLAN_CIPHER_SUITE_TKIP,
 	WLAN_CIPHER_SUITE_CCMP,
 	WLAN_CIPHER_SUITE_AES_CMAC
 };
 
-#define CHAN2G(_channel, _freq, _flags) {	 \
+#if KERNEL_VERSION(4, 7, 0) > LINUX_VERSION_CODE
+#define CHAN2G(_channel, _freq, _flags) {       \
+	.band             = IEEE80211_BAND_2GHZ, \
+	.center_freq      = (_freq),             \
+	.hw_value         = (_channel),          \
+	.flags            = (_flags),            \
+	.max_antenna_gain = 0,                   \
+	.max_power        = 30,                  \
+}
+#else
+#define CHAN2G(_channel, _freq, _flags) {       \
 	.band             = NL80211_BAND_2GHZ, \
-	.center_freq      = (_freq),		 \
-	.hw_value         = (_channel),		 \
-	.flags            = (_flags),		 \
-	.max_antenna_gain = 0,			 \
-	.max_power        = 30,			 \
+	.center_freq      = (_freq),             \
+	.hw_value         = (_channel),          \
+	.flags            = (_flags),            \
+	.max_antenna_gain = 0,                   \
+	.max_power        = 30,                  \
 }
+#endif
 
 static const struct ieee80211_channel wilc_2ghz_channels[] = {
 	CHAN2G(1,  2412, 0),
@@ -132,23 +277,34 @@ struct wilc_priv {
 	struct net_device *dev;
 	struct host_if_drv *hif_drv;
 	struct wilc_pmkid_attr pmkid_list;
-	u8 wep_key[4][WLAN_KEY_LEN_WEP104];
-	u8 wep_key_len[4];
 
 	/* The real interface that the monitor is on */
 	struct net_device *real_ndev;
 	struct wilc_wfi_key *wilc_gtk[WILC_MAX_NUM_STA];
 	struct wilc_wfi_key *wilc_ptk[WILC_MAX_NUM_STA];
+	struct wilc_wfi_key *wilc_igtk[2];
 	u8 wilc_groupkey;
 
 	/* mutexes */
 	struct mutex scan_req_lock;
-	bool p2p_listen_state;
-	int scanned_cnt;
 
+	struct wilc_buffered_eap *buffered_eap;
+
+	struct timer_list eap_buff_timer;
+	int scanned_cnt;
+	struct wilc_p2p_var p2p;
 	u64 inc_roc_cookie;
 };
 
+#if KERNEL_VERSION(5, 8, 0) > LINUX_VERSION_CODE
+struct frame_reg {
+	u16 type;
+	bool reg;
+};
+
+#define NUM_REG_FRAME				3
+#endif
+
 #define MAX_TCP_SESSION                25
 #define MAX_PENDING_ACKS               256
 
@@ -175,31 +331,66 @@ struct tcp_ack_filter {
 	bool enabled;
 };
 
+#define WILC_P2P_ROLE_GO	1
+#define WILC_P2P_ROLE_CLIENT	0
+
+struct sysfs_attr_group {
+	bool p2p_mode;
+	u8 ant_swtch_mode;
+	u8 antenna1;
+	u8 antenna2;
+};
+
 struct wilc_vif {
 	u8 idx;
 	u8 iftype;
 	int monitor_flag;
 	int mac_opened;
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE
 	u32 mgmt_reg_stypes;
+#else
+	struct frame_reg frame_reg[NUM_REG_FRAME];
+#endif
 	struct net_device_stats netstats;
 	struct wilc *wilc;
 	u8 bssid[ETH_ALEN];
 	struct host_if_drv *hif_drv;
 	struct net_device *ndev;
-	u8 mode;
-	struct timer_list during_ip_timer;
+
 	struct timer_list periodic_rssi;
 	struct rf_info periodic_stat;
 	struct tcp_ack_filter ack_filter;
 	bool connecting;
 	struct wilc_priv priv;
 	struct list_head list;
+	u8 restart;
+	bool p2p_listen_state;
 	struct cfg80211_bss *bss;
+	struct cfg80211_external_auth_params auth;
+};
+
+struct wilc_power_gpios {
+	int reset;
+	int chip_en;
+};
+
+struct wilc_power {
+	struct wilc_power_gpios gpios;
+	u8 status[DEV_MAX];
+};
+
+struct wilc_tx_queue_status {
+	u8 buffer[AC_BUFFER_SIZE];
+	u16 end_index;
+	u16 cnt[NQUEUES];
+	u16 sum;
+	bool initialized;
 };
 
 struct wilc {
 	struct wiphy *wiphy;
 	const struct wilc_hif_func *hif_func;
+	u32 chipid;
 	int io_type;
 	s8 mac_status;
 	struct clk *rtc_clk;
@@ -230,8 +421,9 @@ struct wilc {
 	struct completion sync_event;
 	struct completion txq_event;
 	struct completion txq_thread_started;
-
+	struct completion debug_thread_started;
 	struct task_struct *txq_thread;
+	struct task_struct *debug_thread;
 
 	int quit;
 
@@ -245,19 +437,22 @@ struct wilc {
 	u32 rx_buffer_offset;
 	u8 *tx_buffer;
 
-	struct txq_entry_t txq_head;
+	struct txq_handle txq[NQUEUES];
 	int txq_entries;
 
+	struct wilc_tx_queue_status tx_q_limit;
 	struct rxq_entry_t rxq_head;
 
 	const struct firmware *firmware;
 
 	struct device *dev;
-	bool suspend_event;
+	struct device *dt_dev;
 
-	int clients_count;
+	enum wilc_chip_type chip;
+	struct wilc_power power;
+	uint8_t keep_awake[DEV_MAX];
+	struct mutex cs;
 	struct workqueue_struct *hif_workqueue;
-	enum chip_ps_states chip_ps_state;
 	struct wilc_cfg cfg;
 	void *bus_data;
 	struct net_device *monitor_dev;
@@ -266,6 +461,7 @@ struct wilc {
 	struct mutex deinit_lock;
 	u8 sta_ch;
 	u8 op_ch;
+	struct sysfs_attr_group attr_sysfs;
 	struct ieee80211_channel channels[ARRAY_SIZE(wilc_2ghz_channels)];
 	struct ieee80211_rate bitrates[ARRAY_SIZE(wilc_bitrates)];
 	struct ieee80211_supported_band band;
@@ -276,12 +472,16 @@ struct wilc_wfi_mon_priv {
 	struct net_device *real_ndev;
 };
 
-void wilc_frmw_to_host(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset);
+void wilc_frmw_to_host(struct wilc_vif *vif, u8 *buff, u32 size,
+		       u32 pkt_offset, u8 status);
 void wilc_mac_indicate(struct wilc *wilc);
 void wilc_netdev_cleanup(struct wilc *wilc);
-void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size, bool is_auth);
 void wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode);
 struct wilc_vif *wilc_netdev_ifc_init(struct wilc *wl, const char *name,
 				      int vif_type, enum nl80211_iftype type,
 				      bool rtnl_locked);
+int wilc_bt_power_up(struct wilc *wilc, int source);
+int wilc_bt_power_down(struct wilc *wilc, int source);
+
 #endif
diff --git a/drivers/net/wireless/microchip/wilc1000/power.c b/drivers/net/wireless/microchip/wilc1000/power.c
new file mode 100644
index 00000000..6c59e0b
--- /dev/null
+++ b/drivers/net/wireless/microchip/wilc1000/power.c
@@ -0,0 +1,76 @@
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/version.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+
+#include "netdev.h"
+
+/**
+ * wilc_of_parse_power_pins() - parse power sequence pins; to keep backward
+ *		compatibility with old device trees that doesn't provide
+ *		power sequence pins we check for default pins on proper boards
+ *
+ * @wilc:	wilc data structure
+ *
+ * Returns:	 0 on success, negative error number on failures.
+ */
+int wilc_of_parse_power_pins(struct wilc *wilc)
+{
+	static const struct wilc_power_gpios default_gpios[] = {
+		{ .reset = GPIO_NUM_RESET,	.chip_en = GPIO_NUM_CHIP_EN, },
+	};
+	struct device_node *of = wilc->dt_dev->of_node;
+	struct wilc_power *power = &wilc->power;
+	const struct wilc_power_gpios *gpios = &default_gpios[0];
+	int ret;
+
+	power->gpios.reset = of_get_named_gpio_flags(of, "reset-gpios", 0,
+						     NULL);
+	if (!gpio_is_valid(power->gpios.reset))
+		power->gpios.reset = gpios->reset;
+
+	power->gpios.chip_en = of_get_named_gpio_flags(of, "chip_en-gpios", 0,
+						       NULL);
+	if (!gpio_is_valid(power->gpios.chip_en))
+		power->gpios.chip_en = gpios->chip_en;
+
+	if (!gpio_is_valid(power->gpios.chip_en) ||
+			!gpio_is_valid(power->gpios.reset))
+		return -EINVAL;
+
+	ret = devm_gpio_request(wilc->dev, power->gpios.chip_en, "CHIP_EN");
+	if (ret)
+		return ret;
+
+	ret = devm_gpio_request(wilc->dev, power->gpios.reset, "RESET");
+	return ret;
+}
+
+/**
+ * wilc_wlan_power() - handle power on/off commands
+ *
+ * @wilc:	wilc data structure
+ * @on:		requested power status
+ *
+ * Returns:	none
+ */
+void wilc_wlan_power(struct wilc *wilc, bool on)
+{
+	if (!gpio_is_valid(wilc->power.gpios.chip_en) ||
+	    !gpio_is_valid(wilc->power.gpios.reset)) {
+		/* In case SDIO power sequence driver is used to power this
+		 * device then the powering sequence is handled by the bus
+		 * via pm_runtime_* functions. */
+		return;
+	}
+
+	if (on) {
+		gpio_direction_output(wilc->power.gpios.chip_en, 1);
+		mdelay(5);
+		gpio_direction_output(wilc->power.gpios.reset, 1);
+	} else {
+		gpio_direction_output(wilc->power.gpios.chip_en, 0);
+		gpio_direction_output(wilc->power.gpios.reset, 0);
+	}
+}
diff --git a/drivers/net/wireless/microchip/wilc1000/sdio.c b/drivers/net/wireless/microchip/wilc1000/sdio.c
index e14b9fc..db6eb4b 100644
--- a/drivers/net/wireless/microchip/wilc1000/sdio.c
+++ b/drivers/net/wireless/microchip/wilc1000/sdio.c
@@ -8,13 +8,30 @@
 #include <linux/mmc/sdio_func.h>
 #include <linux/mmc/sdio_ids.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/mmc/sdio.h>
 #include <linux/of_irq.h>
 
 #include "netdev.h"
 #include "cfg80211.h"
 
-#define SDIO_MODALIAS "wilc1000_sdio"
+enum sdio_host_lock {
+	WILC_SDIO_HOST_NO_TAKEN = 0,
+	WILC_SDIO_HOST_IRQ_TAKEN = 1,
+	WILC_SDIO_HOST_DIS_TAKEN = 2,
+};
+
+static enum sdio_host_lock	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+static wait_queue_head_t sdio_intr_waitqueue;
+
+#define SDIO_MODALIAS "wilc_sdio"
+
+#if KERNEL_VERSION(5, 8, 0) >= LINUX_VERSION_CODE
+#define SDIO_VENDOR_ID_MICROCHIP_WILC 0x0296
+#define SDIO_DEVICE_ID_MICROCHIP_WILC1000 0x5347
+#endif
 
 static const struct sdio_device_id wilc_sdio_ids[] = {
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MICROCHIP_WILC, SDIO_DEVICE_ID_MICROCHIP_WILC1000) },
@@ -26,7 +43,8 @@ static const struct sdio_device_id wilc_sdio_ids[] = {
 struct wilc_sdio {
 	bool irq_gpio;
 	u32 block_size;
-	int has_thrpt_enh3;
+	bool is_init;
+	struct wilc *wl;
 };
 
 struct sdio_cmd52 {
@@ -52,9 +70,14 @@ static const struct wilc_hif_func wilc_hif_sdio;
 
 static void wilc_sdio_interrupt(struct sdio_func *func)
 {
+	if (sdio_intr_lock == WILC_SDIO_HOST_DIS_TAKEN)
+		return;
+	sdio_intr_lock = WILC_SDIO_HOST_IRQ_TAKEN;
 	sdio_release_host(func);
 	wilc_handle_isr(sdio_get_drvdata(func));
 	sdio_claim_host(func);
+	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+	wake_up_interruptible(&sdio_intr_waitqueue);
 }
 
 static int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)
@@ -120,43 +143,81 @@ static int wilc_sdio_probe(struct sdio_func *func,
 			   const struct sdio_device_id *id)
 {
 	struct wilc *wilc;
-	int ret;
+	int ret, io_type;
+	static bool init_power;
 	struct wilc_sdio *sdio_priv;
+	struct device_node *np;
+	int irq_num;
 
 	sdio_priv = kzalloc(sizeof(*sdio_priv), GFP_KERNEL);
 	if (!sdio_priv)
 		return -ENOMEM;
 
-	ret = wilc_cfg80211_init(&wilc, &func->dev, WILC_HIF_SDIO,
-				 &wilc_hif_sdio);
+	if (IS_ENABLED(CONFIG_WILC_HW_OOB_INTR))
+		io_type = WILC_HIF_SDIO_GPIO_IRQ;
+	else
+		io_type = WILC_HIF_SDIO;
+	dev_dbg(&func->dev, "Initializing netdev\n");
+	ret = wilc_cfg80211_init(&wilc, &func->dev, io_type, &wilc_hif_sdio);
 	if (ret) {
-		kfree(sdio_priv);
-		return ret;
+		dev_err(&func->dev, "Couldn't initialize netdev\n");
+		goto free;
 	}
-
-	if (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {
-		struct device_node *np = func->card->dev.of_node;
-		int irq_num = of_irq_get(np, 0);
-
-		if (irq_num > 0) {
-			wilc->dev_irq_num = irq_num;
-			sdio_priv->irq_gpio = true;
-		}
-	}
-
 	sdio_set_drvdata(func, wilc);
 	wilc->bus_data = sdio_priv;
 	wilc->dev = &func->dev;
+	wilc->dt_dev = &func->card->dev;
+	sdio_priv->wl = wilc;
+
+	irq_num = of_irq_get(func->card->dev.of_node, 0);
+	if (irq_num > 0)
+		wilc->dev_irq_num = irq_num;
 
 	wilc->rtc_clk = devm_clk_get(&func->card->dev, "rtc");
 	if (PTR_ERR_OR_ZERO(wilc->rtc_clk) == -EPROBE_DEFER) {
-		kfree(sdio_priv);
-		return -EPROBE_DEFER;
-	} else if (!IS_ERR(wilc->rtc_clk))
+		ret = -EPROBE_DEFER;
+		goto dispose_irq;
+	} else if (!IS_ERR(wilc->rtc_clk)) {
 		clk_prepare_enable(wilc->rtc_clk);
+	}
+
+	/*
+	 * Some WILC SDIO setups needs a SD power sequence driver to be able
+	 * to power the WILC devices before reaching this function. For those
+	 * devices the power sequence driver already provides reset-gpios
+	 * and chip_en-gpios.
+	 */
+	np = of_parse_phandle(func->card->host->parent->of_node, "mmc-pwrseq",
+			      0);
+	if (np && of_device_is_available(np)) {
+		init_power = 1;
+		of_node_put(np);
+	} else {
+		ret = wilc_of_parse_power_pins(wilc);
+		if (ret)
+			goto disable_rtc_clk;
+	}
+
+	if (!init_power) {
+		wilc_wlan_power(wilc, false);
+		init_power = 1;
+		wilc_wlan_power(wilc, true);
+	}
+
+	wilc_bt_init(wilc);
 
 	dev_info(&func->dev, "Driver Initializing success\n");
 	return 0;
+
+disable_rtc_clk:
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
+dispose_irq:
+	irq_dispose_mapping(wilc->dev_irq_num);
+	wilc_netdev_cleanup(wilc);
+free:
+	kfree(sdio_priv);
+	return ret;
 }
 
 static void wilc_sdio_remove(struct sdio_func *func)
@@ -167,6 +228,7 @@ static void wilc_sdio_remove(struct sdio_func *func)
 		clk_disable_unprepare(wilc->rtc_clk);
 
 	wilc_netdev_cleanup(wilc);
+	wilc_bt_deinit();
 }
 
 static int wilc_sdio_reset(struct wilc *wilc)
@@ -175,6 +237,8 @@ static int wilc_sdio_reset(struct wilc *wilc)
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 
+	dev_info(&func->dev, "De Init SDIO\n");
+
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
@@ -188,29 +252,42 @@ static int wilc_sdio_reset(struct wilc *wilc)
 	return 0;
 }
 
+static bool wilc_sdio_is_init(struct wilc *wilc)
+{
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	return sdio_priv->is_init;
+}
+
+static int wilc_sdio_clear_init(struct wilc *wilc)
+{
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	sdio_priv->is_init = false;
+
+	return 0;
+}
+
 static int wilc_sdio_suspend(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 	int ret;
 
-	dev_info(dev, "sdio suspend\n");
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio suspend\n");
+	mutex_lock(&wilc->hif_cs);
 
-	if (!IS_ERR(wilc->rtc_clk))
-		clk_disable_unprepare(wilc->rtc_clk);
+	chip_wakeup(wilc, DEV_WIFI);
 
-	if (wilc->suspend_event) {
-		host_sleep_notify(wilc);
-		chip_allow_sleep(wilc);
-	}
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_sleep_notify(wilc, DEV_WIFI);
+	chip_allow_sleep(wilc, DEV_WIFI);
+
+	mutex_lock(&wilc->hif_cs);
 
 	ret = wilc_sdio_reset(wilc);
-	if (ret) {
-		dev_err(&func->dev, "Fail reset sdio\n");
-		return ret;
-	}
-	sdio_claim_host(func);
 
 	return 0;
 }
@@ -220,6 +297,8 @@ static int wilc_sdio_enable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret = 0;
 
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_claim_irq(func, wilc_sdio_interrupt);
 	sdio_release_host(func);
@@ -236,11 +315,19 @@ static void wilc_sdio_disable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret;
 
+	dev_info(&func->dev, "%s\n", __func__);
+
+	if (sdio_intr_lock  == WILC_SDIO_HOST_IRQ_TAKEN)
+		wait_event_interruptible(sdio_intr_waitqueue,
+					 sdio_intr_lock == WILC_SDIO_HOST_NO_TAKEN);
+	sdio_intr_lock  = WILC_SDIO_HOST_DIS_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_release_irq(func);
 	if (ret < 0)
 		dev_err(&func->dev, "can't release sdio_irq, err(%d)\n", ret);
 	sdio_release_host(func);
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
 }
 
 /********************************************
@@ -346,7 +433,7 @@ static int wilc_sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		ret = wilc_sdio_cmd52(wilc, &cmd);
 		if (ret)
 			dev_err(&func->dev,
-				"Failed cmd 52, read reg (%08x) ...\n", addr);
+				"Failed cmd 52, write reg (%08x) ...\n", addr);
 	} else {
 		struct sdio_cmd53 cmd;
 
@@ -576,6 +663,14 @@ static int wilc_sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 
 static int wilc_sdio_deinit(struct wilc *wilc)
 {
+	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
+	struct wilc_sdio *sdio_priv = wilc->bus_data;
+
+	sdio_priv->is_init = false;
+
+	pm_runtime_put_sync_autosuspend(mmc_dev(func->card->host));
+	wilc_wlan_power(wilc, false);
+
 	return 0;
 }
 
@@ -587,18 +682,31 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	int loop, ret;
 	u32 chipid;
 
+	dev_info(&func->dev, "SDIO speed: %d\n",
+		func->card->host->ios.clock);
+
+	/* Patch for sdio interrupt latency issue */
+	ret = pm_runtime_get_sync(mmc_dev(func->card->host));
+	if (ret < 0) {
+		pm_runtime_put_noidle(mmc_dev(func->card->host));
+		return ret;
+	}
+
+	init_waitqueue_head(&sdio_intr_waitqueue);
+	sdio_priv->irq_gpio = (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ);
+
 	/**
 	 *      function 0 csa enable
 	 **/
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 1;
-	cmd.address = SDIO_FBR_BASE(func->num);
+	cmd.address = SDIO_FBR_BASE(1);
 	cmd.data = SDIO_FBR_ENABLE_CSA;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, enable csa...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -607,7 +715,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_set_block_size(wilc, 0, WILC_SDIO_BLOCK_SIZE);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set func 0 block size...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 	sdio_priv->block_size = WILC_SDIO_BLOCK_SIZE;
 
@@ -623,7 +731,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	if (ret) {
 		dev_err(&func->dev,
 			"Fail cmd 52, set IOE register...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -640,7 +748,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 		if (ret) {
 			dev_err(&func->dev,
 				"Fail cmd 52, get IOR register...\n");
-			return ret;
+			goto pm_runtime_put;
 		}
 		if (cmd.data == WILC_SDIO_CCCR_IO_EN_FUNC1)
 			break;
@@ -648,7 +756,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 
 	if (loop <= 0) {
 		dev_err(&func->dev, "Fail func 1 is not ready...\n");
-		return -EINVAL;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -657,7 +765,7 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_set_block_size(wilc, 1, WILC_SDIO_BLOCK_SIZE);
 	if (ret) {
 		dev_err(&func->dev, "Fail set func 1 block size...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 
 	/**
@@ -671,31 +779,32 @@ static int wilc_sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set IEN register...\n");
-		return ret;
+		goto pm_runtime_put;
 	}
 
 	/**
 	 *      make sure can read back chip id correctly
 	 **/
 	if (!resume) {
-		int rev;
-
-		ret = wilc_sdio_read_reg(wilc, WILC_CHIPID, &chipid);
-		if (ret) {
-			dev_err(&func->dev, "Fail cmd read chip id...\n");
-			return ret;
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&func->dev, "Unsupported chipid: %x\n", chipid);
+			goto pm_runtime_put;
 		}
-		dev_err(&func->dev, "chipid (%08x)\n", chipid);
-		rev = FIELD_GET(WILC_CHIP_REV_FIELD, chipid);
-		if (rev > FIELD_GET(WILC_CHIP_REV_FIELD, WILC_1000_BASE_ID_2A))
-			sdio_priv->has_thrpt_enh3 = 1;
-		else
-			sdio_priv->has_thrpt_enh3 = 0;
-		dev_info(&func->dev, "has_thrpt_enh3 = %d...\n",
-			 sdio_priv->has_thrpt_enh3);
+		dev_info(&func->dev, "chipid %08x\n", chipid);
 	}
 
+	sdio_priv->is_init = true;
+
 	return 0;
+
+pm_runtime_put:
+	pm_runtime_put_sync_autosuspend(mmc_dev(func->card->host));
+	return ret;
 }
 
 static int wilc_sdio_read_size(struct wilc *wilc, u32 *size)
@@ -728,33 +837,46 @@ static int wilc_sdio_read_int(struct wilc *wilc, u32 *int_status)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 tmp;
-	u8 irq_flags;
 	struct sdio_cmd52 cmd;
+	u32 irq_flags;
 
-	wilc_sdio_read_size(wilc, &tmp);
+	if (sdio_priv->irq_gpio) {
+		wilc_sdio_read_size(wilc, &tmp);
 
-	/**
-	 *      Read IRQ flags
-	 **/
-	if (!sdio_priv->irq_gpio) {
+		cmd.read_write = 0;
+		cmd.function = 0;
+		cmd.raw = 0;
+		cmd.data = 0;
+		if (wilc->chip == WILC_1000) {
+			cmd.address = WILC1000_SDIO_IRQ_FLAG_REG;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x1f;
+		} else {
+			cmd.address = WILC3000_SDIO_IRQ_FLAG_REG;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x0f;
+		}
+		tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
+
+		*int_status = tmp;
+	} else {
+		wilc_sdio_read_size(wilc, &tmp);
+		cmd.read_write = 0;
 		cmd.function = 1;
 		cmd.address = WILC_SDIO_EXT_IRQ_FLAG_REG;
-	} else {
-		cmd.function = 0;
-		cmd.address = WILC_SDIO_IRQ_FLAG_REG;
-	}
-	cmd.raw = 0;
-	cmd.read_write = 0;
-	cmd.data = 0;
-	wilc_sdio_cmd52(wilc, &cmd);
-	irq_flags = cmd.data;
-	tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
+		cmd.data = 0;
+		wilc_sdio_cmd52(wilc, &cmd);
 
-	if (FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags))
-		dev_err(&func->dev, "Unexpected interrupt (1) int=%lx\n",
-			FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags));
+		irq_flags = cmd.data;
+		tmp |= FIELD_PREP(IRG_FLAGS_MASK, cmd.data);
+
+		if (FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags)) {
+			dev_err(&func->dev, "Unexpected interrupt (1) int=%lx\n",
+				FIELD_GET(UNHANDLED_IRQ_MASK, irq_flags));
+		}
 
-	*int_status = tmp;
+		*int_status = tmp;
+	}
 
 	return 0;
 }
@@ -764,11 +886,9 @@ static int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	int ret;
-	int vmm_ctl;
-
-	if (sdio_priv->has_thrpt_enh3) {
-		u32 reg = 0;
+	u32 reg = 0;
 
+	if (wilc->chip == WILC_1000) {
 		if (sdio_priv->irq_gpio)
 			reg = val & (BIT(MAX_NUM_INT) - 1);
 
@@ -787,87 +907,68 @@ static int wilc_sdio_clear_int_ext(struct wilc *wilc, u32 val)
 			cmd.read_write = 1;
 			cmd.function = 0;
 			cmd.raw = 0;
-			cmd.address = WILC_SDIO_IRQ_CLEAR_FLAG_REG;
+			cmd.address = WILC1000_SDIO_IRQ_CLEAR_FLAG_REG;
 			cmd.data = reg;
 
 			ret = wilc_sdio_cmd52(wilc, &cmd);
 			if (ret) {
 				dev_err(&func->dev,
-					"Failed cmd52, set (%02x) data (%d) ...\n",
-					cmd.address, __LINE__);
+					"Failed cmd52, set 0xf8 data (%d) ...\n",
+					__LINE__);
 				return ret;
 			}
 		}
-		return 0;
-	}
-	if (sdio_priv->irq_gpio) {
-		/* has_thrpt_enh2 uses register 0xf8 to clear interrupts. */
-		/*
-		 * Cannot clear multiple interrupts.
-		 * Must clear each interrupt individually.
-		 */
-		u32 flags;
-		int i;
-
-		flags = val & (BIT(MAX_NUM_INT) - 1);
-		for (i = 0; i < NUM_INT_EXT && flags; i++) {
-			if (flags & BIT(i)) {
+	} else {
+		if (sdio_priv->irq_gpio) {
+			reg = val & (BIT(MAX_NUM_INT) - 1);
+			if (reg) {
 				struct sdio_cmd52 cmd;
 
 				cmd.read_write = 1;
 				cmd.function = 0;
 				cmd.raw = 0;
-				cmd.address = WILC_SDIO_IRQ_CLEAR_FLAG_REG;
-				cmd.data = BIT(i);
+				cmd.address = WILC3000_SDIO_IRQ_CLEAR_FLAG_REG;
+				cmd.data = reg;
 
 				ret = wilc_sdio_cmd52(wilc, &cmd);
 				if (ret) {
 					dev_err(&func->dev,
-						"Failed cmd52, set (%02x) data (%d) ...\n",
-						cmd.address, __LINE__);
+						"Failed cmd52, set 0xfe data (%d) ...\n",
+						__LINE__);
 					return ret;
 				}
-				flags &= ~BIT(i);
 			}
 		}
+		reg = 0;
+		/* select VMM table 0 */
+		if (val & SEL_VMM_TBL0)
+			reg |= BIT(0);
+		/* select VMM table 1 */
+		if (val & SEL_VMM_TBL1)
+			reg |= BIT(1);
+		/* enable VMM */
+		if (val & EN_VMM)
+			reg |= BIT(2);
 
-		for (i = NUM_INT_EXT; i < MAX_NUM_INT && flags; i++) {
-			if (flags & BIT(i)) {
+		if (reg) {
+			struct sdio_cmd52 cmd;
+
+			cmd.read_write = 1;
+			cmd.function = 0;
+			cmd.raw = 0;
+			cmd.address = WILC3000_SDIO_VMM_TBL_CTRL_REG;
+			cmd.data = reg;
+
+			ret = wilc_sdio_cmd52(wilc, &cmd);
+			if (ret) {
 				dev_err(&func->dev,
-					"Unexpected interrupt cleared %d...\n",
-					i);
-				flags &= ~BIT(i);
+					"Failed cmd52, set 0xf6 data (%d) ...\n",
+					__LINE__);
+				return ret;
 			}
 		}
 	}
 
-	vmm_ctl = 0;
-	/* select VMM table 0 */
-	if (val & SEL_VMM_TBL0)
-		vmm_ctl |= BIT(0);
-	/* select VMM table 1 */
-	if (val & SEL_VMM_TBL1)
-		vmm_ctl |= BIT(1);
-	/* enable VMM */
-	if (val & EN_VMM)
-		vmm_ctl |= BIT(2);
-
-	if (vmm_ctl) {
-		struct sdio_cmd52 cmd;
-
-		cmd.read_write = 1;
-		cmd.function = 0;
-		cmd.raw = 0;
-		cmd.address = WILC_SDIO_VMM_TBL_CTRL_REG;
-		cmd.data = vmm_ctl;
-		ret = wilc_sdio_cmd52(wilc, &cmd);
-		if (ret) {
-			dev_err(&func->dev,
-				"Failed cmd52, set (%02x) data (%d) ...\n",
-				cmd.address, __LINE__);
-			return ret;
-		}
-	}
 	return 0;
 }
 
@@ -876,30 +977,32 @@ static int wilc_sdio_sync_ext(struct wilc *wilc, int nint)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	struct wilc_sdio *sdio_priv = wilc->bus_data;
 	u32 reg;
+	int ret, i;
 
 	if (nint > MAX_NUM_INT) {
-		dev_err(&func->dev, "Too many interrupts (%d)...\n", nint);
+		dev_err(&func->dev, "Too many interrupts %d\n", nint);
 		return -EINVAL;
 	}
 
-	/**
-	 *      Disable power sequencer
-	 **/
-	if (wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {
-		dev_err(&func->dev, "Failed read misc reg...\n");
-		return -EINVAL;
-	}
-
-	reg &= ~BIT(8);
-	if (wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {
-		dev_err(&func->dev, "Failed write misc reg...\n");
-		return -EINVAL;
+/* WILC3000 only. Was removed in WILC1000 on revision 6200.
+ * Might be related to suspend/resume
+ */
+	if (wilc->chip == WILC_3000) {
+		/**
+		 *      Disable power sequencer
+		 **/
+		if (wilc_sdio_read_reg(wilc, WILC_MISC, &reg)) {
+			dev_err(&func->dev, "Failed read misc reg\n");
+			return -EINVAL;
+		}
+		reg &= ~BIT(8);
+		if (wilc_sdio_write_reg(wilc, WILC_MISC, reg)) {
+			dev_err(&func->dev, "Failed write misc reg\n");
+			return -EINVAL;
+		}
 	}
 
 	if (sdio_priv->irq_gpio) {
-		u32 reg;
-		int ret, i;
-
 		/**
 		 *      interrupt pin mux select
 		 **/
@@ -975,6 +1078,9 @@ static const struct wilc_hif_func wilc_hif_sdio = {
 	.hif_sync_ext = wilc_sdio_sync_ext,
 	.enable_interrupt = wilc_sdio_enable_interrupt,
 	.disable_interrupt = wilc_sdio_disable_interrupt,
+	.hif_reset = wilc_sdio_reset,
+	.hif_is_init = wilc_sdio_is_init,
+	.hif_clear_init = wilc_sdio_clear_init,
 };
 
 static int wilc_sdio_resume(struct device *dev)
@@ -982,22 +1088,29 @@ static int wilc_sdio_resume(struct device *dev)
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 
-	dev_info(dev, "sdio resume\n");
-	sdio_release_host(func);
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio resume\n");
+	chip_wakeup(wilc, DEV_WIFI);
 	wilc_sdio_init(wilc, true);
 
-	if (wilc->suspend_event)
-		host_wakeup_notify(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, DEV_WIFI);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, DEV_WIFI);
 
-	chip_allow_sleep(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
 
 	return 0;
 }
 
 static const struct of_device_id wilc_of_match[] = {
 	{ .compatible = "microchip,wilc1000", },
-	{ /* sentinel */ }
+	{ .compatible = "microchip,wilc3000", },
+	{ /* sentinel */}
 };
 MODULE_DEVICE_TABLE(of, wilc_of_match);
 
@@ -1020,3 +1133,4 @@ module_driver(wilc_sdio_driver,
 	      sdio_register_driver,
 	      sdio_unregister_driver);
 MODULE_LICENSE("GPL");
+MODULE_VERSION("15.6");
diff --git a/drivers/net/wireless/microchip/wilc1000/spi.c b/drivers/net/wireless/microchip/wilc1000/spi.c
index a18dac0..bbe837a 100644
--- a/drivers/net/wireless/microchip/wilc1000/spi.c
+++ b/drivers/net/wireless/microchip/wilc1000/spi.c
@@ -6,17 +6,50 @@
 
 #include <linux/clk.h>
 #include <linux/spi/spi.h>
+#include <linux/module.h>
 #include <linux/crc7.h>
+#include <linux/crc-itu-t.h>
 
 #include "netdev.h"
 #include "cfg80211.h"
 
+static bool enable_crc7;	/* protect SPI commands with CRC7 */
+module_param(enable_crc7, bool, 0644);
+MODULE_PARM_DESC(enable_crc7,
+		 "Enable CRC7 checksum to protect command transfers\n"
+		 "\t\t\tagainst corruption during the SPI transfer.\n"
+		 "\t\t\tCommand transfers are short and the CPU-cycle cost\n"
+		 "\t\t\tof enabling this is small.");
+
+static bool enable_crc16;	/* protect SPI data with CRC16 */
+module_param(enable_crc16, bool, 0644);
+MODULE_PARM_DESC(enable_crc16,
+		 "Enable CRC16 checksum to protect data transfers\n"
+		 "\t\t\tagainst corruption during the SPI transfer.\n"
+		 "\t\t\tData transfers can be large and the CPU-cycle cost\n"
+		 "\t\t\tof enabling this may be substantial.");
+
+/*
+ * For CMD_SINGLE_READ and CMD_INTERNAL_READ, WILC may insert one or
+ * more zero bytes between the command response and the DATA Start tag
+ * (0xf3).  This behavior appears to be undocumented in "ATWILC1000
+ * USER GUIDE" (https://tinyurl.com/4hhshdts) but we have observed 1-4
+ * zero bytes when the SPI bus operates at 48MHz and none when it
+ * operates at 1MHz.
+ */
+#define WILC_SPI_RSP_HDR_EXTRA_DATA	3
+
 struct wilc_spi {
-	int crc_off;
+	bool probing_crc;	/* true if we're probing chip's CRC config */
+	bool crc7_enabled;	/* true if crc7 is currently enabled */
+	bool crc16_enabled;	/* true if crc16 is currently enabled */
+	bool is_init;
 };
 
 static const struct wilc_hif_func wilc_hif_spi;
 
+static int wilc_spi_reset(struct wilc *wilc);
+
 /********************************************
  *
  *      Spi protocol Function
@@ -35,12 +68,39 @@ static const struct wilc_hif_func wilc_hif_spi;
 #define CMD_SINGLE_READ				0xca
 #define CMD_RESET				0xcf
 
-#define DATA_PKT_SZ_256				256
-#define DATA_PKT_SZ_512				512
-#define DATA_PKT_SZ_1K				1024
-#define DATA_PKT_SZ_4K				(4 * 1024)
-#define DATA_PKT_SZ_8K				(8 * 1024)
-#define DATA_PKT_SZ				DATA_PKT_SZ_8K
+#define SPI_RESP_RETRY_COUNT			(10)
+#define SPI_RETRY_COUNT				(10)
+#define SPI_ENABLE_VMM_RETRY_LIMIT		2
+
+/* SPI response fields (section 11.1.2 in ATWILC1000 User Guide): */
+#define RSP_START_FIELD				GENMASK(7, 4)
+#define RSP_TYPE_FIELD				GENMASK(3, 0)
+
+/* SPI response values for the response fields: */
+#define RSP_START_TAG				0xc
+#define RSP_TYPE_FIRST_PACKET			0x1
+#define RSP_TYPE_INNER_PACKET			0x2
+#define RSP_TYPE_LAST_PACKET			0x3
+#define RSP_STATE_NO_ERROR			0x00
+
+#define PROTOCOL_REG_PKT_SZ_MASK		GENMASK(6, 4)
+#define PROTOCOL_REG_CRC16_MASK			GENMASK(3, 3)
+#define PROTOCOL_REG_CRC7_MASK			GENMASK(2, 2)
+
+/*
+ * The SPI data packet size may be any integer power of two in the
+ * range from 256 to 8192 bytes.
+ */
+#define DATA_PKT_LOG_SZ_MIN			8	/* 256 B */
+#define DATA_PKT_LOG_SZ_MAX			13	/* 8 KiB */
+
+/*
+ * Select the data packet size (log2 of number of bytes): Use the
+ * maximum data packet size.  We only retransmit complete packets, so
+ * there is no benefit from using smaller data packets.
+ */
+#define DATA_PKT_LOG_SZ				DATA_PKT_LOG_SZ_MAX
+#define DATA_PKT_SZ				(1 << DATA_PKT_LOG_SZ)
 
 #define USE_SPI_DMA				0
 
@@ -78,47 +138,77 @@ struct wilc_spi_cmd {
 } __packed;
 
 struct wilc_spi_read_rsp_data {
-	u8 rsp_cmd_type;
-	u8 status;
-	u8 resp_header;
-	u8 resp_data[4];
+	u8 header;
+	u8 data[4];
 	u8 crc[];
 } __packed;
 
 struct wilc_spi_rsp_data {
 	u8 rsp_cmd_type;
 	u8 status;
+	u8 data[];
+} __packed;
+
+struct wilc_spi_special_cmd_rsp {
+	u8 skip_byte;
+	u8 rsp_cmd_type;
+	u8 status;
 } __packed;
 
 static int wilc_bus_probe(struct spi_device *spi)
 {
 	int ret;
+	static bool init_power;
 	struct wilc *wilc;
+	struct device *dev = &spi->dev;
 	struct wilc_spi *spi_priv;
 
+	dev_info(&spi->dev, "spiModalias: %s, spiMax-Speed: %d\n",
+			spi->modalias, spi->max_speed_hz);
+
 	spi_priv = kzalloc(sizeof(*spi_priv), GFP_KERNEL);
 	if (!spi_priv)
 		return -ENOMEM;
 
-	ret = wilc_cfg80211_init(&wilc, &spi->dev, WILC_HIF_SPI, &wilc_hif_spi);
-	if (ret) {
-		kfree(spi_priv);
-		return ret;
-	}
+	ret = wilc_cfg80211_init(&wilc, dev, WILC_HIF_SPI, &wilc_hif_spi);
+	if (ret)
+		goto free;
 
 	spi_set_drvdata(spi, wilc);
 	wilc->dev = &spi->dev;
 	wilc->bus_data = spi_priv;
+	wilc->dt_dev = &spi->dev;
 	wilc->dev_irq_num = spi->irq;
 
-	wilc->rtc_clk = devm_clk_get(&spi->dev, "rtc_clk");
-	if (PTR_ERR_OR_ZERO(wilc->rtc_clk) == -EPROBE_DEFER) {
-		kfree(spi_priv);
-		return -EPROBE_DEFER;
-	} else if (!IS_ERR(wilc->rtc_clk))
+	wilc->rtc_clk = devm_clk_get(&spi->dev, "rtc");
+	if (PTR_ERR_OR_ZERO(wilc->rtc_clk) == -EPROBE_DEFER)
+		goto netdev_cleanup;
+	else if (!IS_ERR(wilc->rtc_clk))
 		clk_prepare_enable(wilc->rtc_clk);
 
+	ret = wilc_of_parse_power_pins(wilc);
+	if (ret)
+		goto disable_rtc_clk;
+
+	if (!init_power) {
+		wilc_wlan_power(wilc, false);
+		init_power = 1;
+		wilc_wlan_power(wilc, true);
+	}
+
+	wilc_bt_init(wilc);
+
+	dev_info(dev, "WILC SPI probe success\n");
 	return 0;
+
+disable_rtc_clk:
+	if (!IS_ERR(wilc->rtc_clk))
+		clk_disable_unprepare(wilc->rtc_clk);
+netdev_cleanup:
+	wilc_netdev_cleanup(wilc);
+free:
+	kfree(spi_priv);
+	return ret;
 }
 
 static int wilc_bus_remove(struct spi_device *spi)
@@ -129,25 +219,78 @@ static int wilc_bus_remove(struct spi_device *spi)
 		clk_disable_unprepare(wilc->rtc_clk);
 
 	wilc_netdev_cleanup(wilc);
+	wilc_bt_deinit();
+	return 0;
+}
+
+static int wilc_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n << SUSPEND >>\n\n");
+	mutex_lock(&wilc->hif_cs);
+	chip_wakeup(wilc, DEV_WIFI);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	/* notify the chip that host will sleep */
+	host_sleep_notify(wilc, DEV_WIFI);
+	chip_allow_sleep(wilc, DEV_WIFI);
+	mutex_lock(&wilc->hif_cs);
+
+	return 0;
+}
+
+static int wilc_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n  <<RESUME>>\n\n");
+
+	/* wake the chip to compelete the re-initialization */
+	chip_wakeup(wilc, DEV_WIFI);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, DEV_WIFI);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, DEV_WIFI);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
 	return 0;
 }
 
 static const struct of_device_id wilc_of_match[] = {
 	{ .compatible = "microchip,wilc1000", },
+	{ .compatible = "microchip,wilc3000", },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, wilc_of_match);
+static const struct dev_pm_ops wilc_spi_pm_ops = {
+	.suspend = wilc_spi_suspend,
+	.resume = wilc_spi_resume,
+};
 
 static struct spi_driver wilc_spi_driver = {
 	.driver = {
 		.name = MODALIAS,
 		.of_match_table = wilc_of_match,
+		.pm = &wilc_spi_pm_ops,
 	},
 	.probe =  wilc_bus_probe,
 	.remove = wilc_bus_remove,
 };
 module_spi_driver(wilc_spi_driver);
 MODULE_LICENSE("GPL");
+MODULE_VERSION("15.6");
 
 static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
 {
@@ -159,10 +302,14 @@ static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
 		struct spi_transfer tr = {
 			.tx_buf = b,
 			.len = len,
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
 			.delay = {
-				.value = 0,
-				.unit = SPI_DELAY_UNIT_USECS
+			.value = 0,
+			.unit = SPI_DELAY_UNIT_USECS
 			},
+#else
+			.delay_usecs = 0,
+#endif
 		};
 		char *r_buffer = kzalloc(len, GFP_KERNEL);
 
@@ -203,11 +350,14 @@ static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen)
 		struct spi_transfer tr = {
 			.rx_buf = rb,
 			.len = rlen,
-			.delay = {
-				.value = 0,
-				.unit = SPI_DELAY_UNIT_USECS
-			},
-
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+						.delay = {
+						.value = 0,
+						.unit = SPI_DELAY_UNIT_USECS
+						},
+#else
+			.delay_usecs = 0,
+#endif
 		};
 		char *t_buffer = kzalloc(rlen, GFP_KERNEL);
 
@@ -248,11 +398,14 @@ static int wilc_spi_tx_rx(struct wilc *wilc, u8 *wb, u8 *rb, u32 rlen)
 			.tx_buf = wb,
 			.len = rlen,
 			.bits_per_word = 8,
-			.delay = {
-				.value = 0,
-				.unit = SPI_DELAY_UNIT_USECS
-			},
-
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+						.delay = {
+						.value = 0,
+						.unit = SPI_DELAY_UNIT_USECS
+						},
+#else
+			.delay_usecs = 0,
+#endif
 		};
 
 		memset(&msg, 0, sizeof(msg));
@@ -280,7 +433,8 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 	struct wilc_spi *spi_priv = wilc->bus_data;
 	int ix, nbytes;
 	int result = 0;
-	u8 cmd, order, crc[2] = {0};
+	u8 cmd, order, crc[2];
+	u16 crc_calc;
 
 	/*
 	 * Data
@@ -322,9 +476,12 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 		}
 
 		/*
-		 * Write Crc
+		 * Write CRC
 		 */
-		if (!spi_priv->crc_off) {
+		if (spi_priv->crc16_enabled) {
+			crc_calc = crc_itu_t(0xffff, &b[ix], nbytes);
+			crc[0] = crc_calc >> 8;
+			crc[1] = crc_calc;
 			if (wilc_spi_tx(wilc, crc, 2)) {
 				dev_err(&spi->dev, "Failed data block crc write, bus error...\n");
 				result = -EINVAL;
@@ -358,10 +515,11 @@ static int wilc_spi_single_read(struct wilc *wilc, u8 cmd, u32 adr, void *b,
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	struct wilc_spi *spi_priv = wilc->bus_data;
 	u8 wb[32], rb[32];
-	int cmd_len, resp_len;
-	u8 crc[2];
+	int cmd_len, resp_len, i;
+	u16 crc_calc, crc_recv;
 	struct wilc_spi_cmd *c;
-	struct wilc_spi_read_rsp_data *r;
+	struct wilc_spi_rsp_data *r;
+	struct wilc_spi_read_rsp_data *r_data;
 
 	memset(wb, 0x0, sizeof(wb));
 	memset(rb, 0x0, sizeof(rb));
@@ -383,8 +541,9 @@ static int wilc_spi_single_read(struct wilc *wilc, u8 cmd, u32 adr, void *b,
 	}
 
 	cmd_len = offsetof(struct wilc_spi_cmd, u.simple_cmd.crc);
-	resp_len = sizeof(*r);
-	if (!spi_priv->crc_off) {
+	resp_len = sizeof(*r) + sizeof(*r_data) + WILC_SPI_RSP_HDR_EXTRA_DATA;
+
+	if (spi_priv->crc7_enabled) {
 		c->u.simple_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
 		cmd_len += 1;
 		resp_len += 2;
@@ -402,31 +561,49 @@ static int wilc_spi_single_read(struct wilc *wilc, u8 cmd, u32 adr, void *b,
 		return -EINVAL;
 	}
 
-	r = (struct wilc_spi_read_rsp_data *)&rb[cmd_len];
-	if (r->rsp_cmd_type != cmd) {
-		dev_err(&spi->dev,
-			"Failed cmd response, cmd (%02x), resp (%02x)\n",
-			cmd, r->rsp_cmd_type);
+	r = (struct wilc_spi_rsp_data *)&rb[cmd_len];
+	/*
+	 * Clockless registers operations might return unexptected responses,
+	 * even if successful.
+	 */
+	if (r->rsp_cmd_type != cmd && !clockless) {
+		if (!spi_priv->probing_crc)
+			dev_err(&spi->dev,
+				"Failed cmd response, cmd (%02x), resp (%02x)\n",
+				cmd, r->rsp_cmd_type);
 		return -EINVAL;
 	}
 
-	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS) {
+	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS && !clockless) {
 		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
 			r->status);
 		return -EINVAL;
 	}
 
-	if (WILC_GET_RESP_HDR_START(r->resp_header) != 0xf) {
-		dev_err(&spi->dev, "Error, data read response (%02x)\n",
-			r->resp_header);
+	for (i = 0; i < SPI_RESP_RETRY_COUNT; ++i)
+		if (WILC_GET_RESP_HDR_START(r->data[i]) == 0xf)
+			break;
+
+	if (i >= SPI_RESP_RETRY_COUNT) {
+		dev_err(&spi->dev, "Error, data start missing\n");
 		return -EINVAL;
 	}
 
-	if (b)
-		memcpy(b, r->resp_data, 4);
+	r_data = (struct wilc_spi_read_rsp_data *)&r->data[i];
 
-	if (!spi_priv->crc_off)
-		memcpy(crc, r->crc, 2);
+	if (b)
+		memcpy(b, r_data->data, 4);
+
+	if (!clockless && spi_priv->crc16_enabled) {
+		crc_recv = (r_data->crc[0] << 8) | r_data->crc[1];
+		crc_calc = crc_itu_t(0xffff, r_data->data, 4);
+		if (crc_recv != crc_calc) {
+			dev_err(&spi->dev, "%s: bad CRC 0x%04x "
+				"(calculated 0x%04x)\n", __func__,
+				crc_recv, crc_calc);
+			return -EINVAL;
+		}
+	}
 
 	return 0;
 }
@@ -453,7 +630,7 @@ static int wilc_spi_write_cmd(struct wilc *wilc, u8 cmd, u32 adr, u32 data,
 		c->u.internal_w_cmd.addr[1] = adr;
 		c->u.internal_w_cmd.data = cpu_to_be32(data);
 		cmd_len = offsetof(struct wilc_spi_cmd, u.internal_w_cmd.crc);
-		if (!spi_priv->crc_off)
+		if (spi_priv->crc7_enabled)
 			c->u.internal_w_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
 	} else if (cmd == CMD_SINGLE_WRITE) {
 		c->u.w_cmd.addr[0] = adr >> 16;
@@ -461,14 +638,14 @@ static int wilc_spi_write_cmd(struct wilc *wilc, u8 cmd, u32 adr, u32 data,
 		c->u.w_cmd.addr[2] = adr;
 		c->u.w_cmd.data = cpu_to_be32(data);
 		cmd_len = offsetof(struct wilc_spi_cmd, u.w_cmd.crc);
-		if (!spi_priv->crc_off)
+		if (spi_priv->crc7_enabled)
 			c->u.w_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
 	} else {
 		dev_err(&spi->dev, "write cmd [%x] not supported\n", cmd);
 		return -EINVAL;
 	}
 
-	if (!spi_priv->crc_off)
+	if (spi_priv->crc7_enabled)
 		cmd_len += 1;
 
 	resp_len = sizeof(*r);
@@ -486,14 +663,18 @@ static int wilc_spi_write_cmd(struct wilc *wilc, u8 cmd, u32 adr, u32 data,
 	}
 
 	r = (struct wilc_spi_rsp_data *)&rb[cmd_len];
-	if (r->rsp_cmd_type != cmd) {
+	/*
+	 * Clockless registers operations might return unexptected responses,
+	 * even if successful.
+	 */
+	if (r->rsp_cmd_type != cmd && !clockless) {
 		dev_err(&spi->dev,
 			"Failed cmd response, cmd (%02x), resp (%02x)\n",
 			cmd, r->rsp_cmd_type);
 		return -EINVAL;
 	}
 
-	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS) {
+	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS && !clockless) {
 		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
 			r->status);
 		return -EINVAL;
@@ -506,6 +687,7 @@ static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	struct wilc_spi *spi_priv = wilc->bus_data;
+	u16 crc_recv, crc_calc;
 	u8 wb[32], rb[32];
 	int cmd_len, resp_len;
 	int retry, ix = 0;
@@ -524,7 +706,7 @@ static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
 		c->u.dma_cmd.size[0] = sz >> 8;
 		c->u.dma_cmd.size[1] = sz;
 		cmd_len = offsetof(struct wilc_spi_cmd, u.dma_cmd.crc);
-		if (!spi_priv->crc_off)
+		if (spi_priv->crc7_enabled)
 			c->u.dma_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
 	} else if (cmd == CMD_DMA_EXT_WRITE || cmd == CMD_DMA_EXT_READ) {
 		c->u.dma_cmd_ext.addr[0] = adr >> 16;
@@ -534,14 +716,14 @@ static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
 		c->u.dma_cmd_ext.size[1] = sz >> 8;
 		c->u.dma_cmd_ext.size[2] = sz;
 		cmd_len = offsetof(struct wilc_spi_cmd, u.dma_cmd_ext.crc);
-		if (!spi_priv->crc_off)
+		if (spi_priv->crc7_enabled)
 			c->u.dma_cmd_ext.crc[0] = wilc_get_crc7(wb, cmd_len);
 	} else {
 		dev_err(&spi->dev, "dma read write cmd [%x] not supported\n",
 			cmd);
 		return -EINVAL;
 	}
-	if (!spi_priv->crc_off)
+	if (spi_priv->crc7_enabled)
 		cmd_len += 1;
 
 	resp_len = sizeof(*r);
@@ -586,7 +768,7 @@ static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
 		/*
 		 * Data Response header
 		 */
-		retry = 100;
+		retry = SPI_RESP_RETRY_COUNT;
 		do {
 			if (wilc_spi_rx(wilc, &rsp, 1)) {
 				dev_err(&spi->dev,
@@ -607,12 +789,22 @@ static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
 		}
 
 		/*
-		 * Read Crc
+		 * Read CRC
 		 */
-		if (!spi_priv->crc_off && wilc_spi_rx(wilc, crc, 2)) {
-			dev_err(&spi->dev,
-				"Failed block crc read, bus err\n");
-			return -EINVAL;
+		if (spi_priv->crc16_enabled) {
+			if (wilc_spi_rx(wilc, crc, 2)) {
+				dev_err(&spi->dev,
+					"Failed block CRC read, bus err\n");
+				return -EINVAL;
+			}
+			crc_recv = (crc[0] << 8) | crc[1];
+			crc_calc = crc_itu_t(0xffff, &b[ix], nbytes);
+			if (crc_recv != crc_calc) {
+				dev_err(&spi->dev, "%s: bad CRC 0x%04x "
+					"(calculated 0x%04x)\n", __func__,
+					crc_recv, crc_calc);
+				return -EINVAL;
+			}
 		}
 
 		ix += nbytes;
@@ -621,75 +813,186 @@ static int wilc_spi_dma_rw(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz)
 	return 0;
 }
 
+static int wilc_spi_special_cmd(struct wilc *wilc, u8 cmd)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	u8 wb[32], rb[32];
+	int cmd_len, resp_len = 0;
+	struct wilc_spi_cmd *c;
+	struct wilc_spi_special_cmd_rsp *r;
+
+	if (cmd != CMD_TERMINATE && cmd != CMD_REPEAT && cmd != CMD_RESET)
+		return -EINVAL;
+
+	memset(wb, 0x0, sizeof(wb));
+	memset(rb, 0x0, sizeof(rb));
+	c = (struct wilc_spi_cmd *)wb;
+	c->cmd_type = cmd;
+
+	if (cmd == CMD_RESET)
+		memset(c->u.simple_cmd.addr, 0xFF, 3);
+
+	cmd_len = offsetof(struct wilc_spi_cmd, u.simple_cmd.crc);
+	resp_len = sizeof(*r);
+
+	if (spi_priv->crc7_enabled) {
+		c->u.simple_cmd.crc[0] = wilc_get_crc7(wb, cmd_len);
+		cmd_len += 1;
+	}
+	if (cmd_len + resp_len > ARRAY_SIZE(wb)) {
+		dev_err(&spi->dev, "spi buffer size too small (%d) (%d) (%zu)\n",
+			cmd_len, resp_len, ARRAY_SIZE(wb));
+		return -EINVAL;
+	}
+
+	if (wilc_spi_tx_rx(wilc, wb, rb, cmd_len + resp_len)) {
+		dev_err(&spi->dev, "Failed cmd write, bus error...\n");
+		return -EINVAL;
+	}
+
+	r = (struct wilc_spi_special_cmd_rsp *)&rb[cmd_len];
+	if (r->rsp_cmd_type != cmd) {
+		if (!spi_priv->probing_crc)
+			dev_err(&spi->dev,
+				"Failed cmd response, cmd (%02x), resp (%02x)\n",
+				cmd, r->rsp_cmd_type);
+		return -EINVAL;
+	}
+
+	if (r->status != WILC_SPI_COMMAND_STAT_SUCCESS) {
+		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
+			r->status);
+		return -EINVAL;
+	}
+	return 0;
+}
+
 static int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
 	int result;
 	u8 cmd = CMD_SINGLE_READ;
 	u8 clockless = 0;
 
-	if (addr < WILC_SPI_CLOCKLESS_ADDR_LIMIT) {
+retry:
+	if (addr <= WILC_SPI_CLOCKLESS_ADDR_LIMIT) {
 		/* Clockless register */
 		cmd = CMD_INTERNAL_READ;
 		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_READ;
+		clockless = 0;
 	}
 
 	result = wilc_spi_single_read(wilc, cmd, addr, data, clockless);
 	if (result) {
 		dev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);
-		return result;
+		goto fail;
 	}
 
 	le32_to_cpus(data);
 
-	return 0;
+fail:
+	if (result && !clockless) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x\n", retry, addr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
 	if (size <= 4)
 		return -EINVAL;
 
+retry:
 	result = wilc_spi_dma_rw(wilc, CMD_DMA_EXT_READ, addr, buf, size);
 	if (result) {
 		dev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);
-		return result;
+		goto fail;
 	}
 
-	return 0;
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x %d\n", retry, addr,
+			 size);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
+retry:
 	result = wilc_spi_write_cmd(wilc, CMD_INTERNAL_WRITE, adr, dat, 0);
 	if (result) {
 		dev_err(&spi->dev, "Failed internal write cmd...\n");
-		return result;
+		goto fail;
 	}
 
-	return 0;
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n", retry, adr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
+retry:
 	result = wilc_spi_single_read(wilc, CMD_INTERNAL_READ, adr, data, 0);
 	if (result) {
-		dev_err(&spi->dev, "Failed internal read cmd...\n");
-		return result;
+		if (!spi_priv->probing_crc)
+			dev_err(&spi->dev, "Failed internal read cmd...\n");
+		goto fail;
 	}
 
 	le32_to_cpus(data);
 
-	return 0;
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		/* ignore while probing with CRC enable and disabled */
+		if (!spi_priv->probing_crc)
+			dev_err(&spi->dev, "Reset and retry %d %x\n", retry, adr);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 /********************************************
@@ -701,22 +1004,84 @@ static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
 static int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
 	int result;
 	u8 cmd = CMD_SINGLE_WRITE;
 	u8 clockless = 0;
 
-	if (addr < WILC_SPI_CLOCKLESS_ADDR_LIMIT) {
+retry:
+	if (addr <= WILC_SPI_CLOCKLESS_ADDR_LIMIT) {
 		/* Clockless register */
 		cmd = CMD_INTERNAL_WRITE;
 		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_WRITE;
+		clockless = 0;
 	}
 
 	result = wilc_spi_write_cmd(wilc, cmd, addr, data, clockless);
 	if (result) {
 		dev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);
+		goto fail;
+	}
+
+fail:
+	if (result && !clockless) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n", retry, addr, data);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
+}
+
+static int spi_data_rsp(struct wilc *wilc, u8 cmd)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result, i;
+	u8 rsp[4];
+
+	/*
+	 * The response to data packets is two bytes long.  For
+	 * efficiency's sake, wilc_spi_write() wisely ignores the
+	 * responses for all packets but the final one.  The downside
+	 * of that optimization is that when the final data packet is
+	 * short, we may receive (part of) the response to the
+	 * second-to-last packet before the one for the final packet.
+	 * To handle this, we always read 4 bytes and then search for
+	 * the last byte that contains the "Response Start" code (0xc
+	 * in the top 4 bits).  We then know that this byte is the
+	 * first response byte of the final data packet.
+	 */
+	result = wilc_spi_rx(wilc, rsp, sizeof(rsp));
+	if (result) {
+		dev_err(&spi->dev, "Failed bus error...\n");
 		return result;
 	}
 
+	for (i = sizeof(rsp) - 2; i >= 0; --i)
+		if (FIELD_GET(RSP_START_FIELD, rsp[i]) == RSP_START_TAG)
+			break;
+
+	if (i < 0) {
+		dev_err(&spi->dev,
+			"Data packet response missing (%02x %02x %02x %02x)\n",
+			rsp[0], rsp[1], rsp[2], rsp[3]);
+		return -1;
+	}
+
+	/* rsp[i] is the last response start byte */
+
+	if (FIELD_GET(RSP_TYPE_FIELD, rsp[i]) != RSP_TYPE_LAST_PACKET
+	    || rsp[i + 1] != RSP_STATE_NO_ERROR) {
+		dev_err(&spi->dev, "Data response error (%02x %02x)\n",
+			rsp[i], rsp[i + 1]);
+		return -1;
+	}
 	return 0;
 }
 
@@ -724,6 +1089,7 @@ static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
 	/*
 	 * has to be greated than 4
@@ -731,11 +1097,12 @@ static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 	if (size <= 4)
 		return -EINVAL;
 
+retry:
 	result = wilc_spi_dma_rw(wilc, CMD_DMA_EXT_WRITE, addr, NULL, size);
 	if (result) {
 		dev_err(&spi->dev,
 			"Failed cmd, write block (%08x)...\n", addr);
-		return result;
+		goto fail;
 	}
 
 	/*
@@ -744,10 +1111,29 @@ static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 	result = spi_data_write(wilc, buf, size);
 	if (result) {
 		dev_err(&spi->dev, "Failed block data write...\n");
-		return result;
+		goto fail;
+	}
+	/*
+	 * Data response
+	 */
+	result = spi_data_rsp(wilc, CMD_DMA_EXT_WRITE);
+	if (result) {
+		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
 	}
 
-	return 0;
+fail:
+	if (result) {
+		usleep_range(1000, 1100);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n", retry, addr, size);
+		usleep_range(1000, 1100);
+		retry--;
+		if (retry)
+			goto retry;
+	}
+	return result;
 }
 
 /********************************************
@@ -756,11 +1142,42 @@ static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
  *
  ********************************************/
 
+static int wilc_spi_reset(struct wilc *wilc)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	struct wilc_spi *spi_priv = wilc->bus_data;
+	int result;
+
+	result = wilc_spi_special_cmd(wilc, CMD_RESET);
+	if (result && !spi_priv->probing_crc)
+		dev_err(&spi->dev, "Failed cmd reset\n");
+
+	return result;
+}
+
+static bool wilc_spi_is_init(struct wilc *wilc)
+{
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	return spi_priv->is_init;
+}
+
 static int wilc_spi_deinit(struct wilc *wilc)
 {
-	/*
-	 * TODO:
-	 */
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	spi_priv->is_init = false;
+	wilc_wlan_power(wilc, false);
+
+	return 0;
+}
+
+static int wilc_spi_clear_init(struct wilc *wilc)
+{
+	struct wilc_spi *spi_priv = wilc->bus_data;
+
+	spi_priv->is_init = false;
+
 	return 0;
 }
 
@@ -770,10 +1187,9 @@ static int wilc_spi_init(struct wilc *wilc, bool resume)
 	struct wilc_spi *spi_priv = wilc->bus_data;
 	u32 reg;
 	u32 chipid;
-	static int isinit;
-	int ret;
+	int ret, i;
 
-	if (isinit) {
+	if (spi_priv->is_init) {
 		ret = wilc_spi_read_reg(wilc, WILC_CHIPID, &chipid);
 		if (ret)
 			dev_err(&spi->dev, "Fail cmd read chip id...\n");
@@ -786,42 +1202,54 @@ static int wilc_spi_init(struct wilc *wilc, bool resume)
 	 */
 
 	/*
-	 * TODO: We can remove the CRC trials if there is a definite
-	 * way to reset
+	 * Infer the CRC settings that are currently in effect.  This
+	 * is necessary because we can't be sure that the chip has
+	 * been RESET (e.g, after module unload and reload).
 	 */
-	/* the SPI to it's initial value. */
-	ret = spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);
-	if (ret) {
-		/*
-		 * Read failed. Try with CRC off. This might happen when module
-		 * is removed but chip isn't reset
-		 */
-		spi_priv->crc_off = 1;
-		dev_err(&spi->dev,
-			"Failed read with CRC on, retrying with CRC off\n");
+	spi_priv->probing_crc = true;
+	spi_priv->crc7_enabled = enable_crc7;
+	spi_priv->crc16_enabled = false; /* don't check CRC16 during probing */
+	for (i = 0; i < 2; ++i) {
 		ret = spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);
-		if (ret) {
-			/*
-			 * Read failed with both CRC on and off,
-			 * something went bad
-			 */
-			dev_err(&spi->dev, "Failed internal read protocol\n");
-			return ret;
-		}
+		if (ret == 0)
+			break;
+		spi_priv->crc7_enabled = !enable_crc7;
 	}
-	if (spi_priv->crc_off == 0) {
-		reg &= ~0xc; /* disable crc checking */
-		reg &= ~0x70;
-		reg |= (0x5 << 4);
-		ret = spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg);
-		if (ret) {
-			dev_err(&spi->dev,
-				"[wilc spi %d]: Failed internal write reg\n",
-				__LINE__);
-			return ret;
-		}
-		spi_priv->crc_off = 1;
+	if (ret) {
+		dev_err(&spi->dev, "Failed with CRC7 on and off.\n");
+		return ret;
+	}
+
+	/* set up the desired CRC configuration: */
+	reg &= ~(PROTOCOL_REG_CRC7_MASK | PROTOCOL_REG_CRC16_MASK);
+	if (enable_crc7)
+		reg |= PROTOCOL_REG_CRC7_MASK;
+	if (enable_crc16)
+		reg |= PROTOCOL_REG_CRC16_MASK;
+
+	/* set up the data packet size: */
+	BUILD_BUG_ON(DATA_PKT_LOG_SZ < DATA_PKT_LOG_SZ_MIN
+		     || DATA_PKT_LOG_SZ > DATA_PKT_LOG_SZ_MAX);
+	reg &= ~PROTOCOL_REG_PKT_SZ_MASK;
+	reg |= FIELD_PREP(PROTOCOL_REG_PKT_SZ_MASK,
+			  DATA_PKT_LOG_SZ - DATA_PKT_LOG_SZ_MIN);
+
+	/* establish the new setup: */
+	ret = spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg);
+	if (ret) {
+		dev_err(&spi->dev,
+			"[wilc spi %d]: Failed internal write reg\n",
+			__LINE__);
+		return ret;
 	}
+	/* update our state to match new protocol settings: */
+	spi_priv->crc7_enabled = enable_crc7;
+	spi_priv->crc16_enabled = enable_crc16;
+
+	/* re-read to make sure new settings are in effect: */
+	spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg);
+
+	spi_priv->probing_crc = false;
 
 	/*
 	 * make sure can read back chip id correctly
@@ -832,8 +1260,20 @@ static int wilc_spi_init(struct wilc *wilc, bool resume)
 		return ret;
 	}
 
-	isinit = 1;
+	if (!resume) {
+		chipid = wilc_get_chipid(wilc, true);
+		if (is_wilc3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if (is_wilc1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&spi->dev, "Unsupported chipid: %x\n", chipid);
+			return -EINVAL;
+		}
+		dev_dbg(&spi->dev, "chipid %08x\n", chipid);
+	}
 
+	spi_priv->is_init = true;
 	return 0;
 }
 
@@ -856,8 +1296,26 @@ static int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)
 
 static int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)
 {
-	return spi_internal_write(wilc, WILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,
-				  val);
+	int ret;
+	int retry = SPI_ENABLE_VMM_RETRY_LIMIT;
+	u32 check;
+
+	while (retry) {
+		ret = spi_internal_write(wilc,
+					 WILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,
+					 val);
+		if (ret)
+			break;
+
+		ret = spi_internal_read(wilc,
+					WILC_SPI_INT_CLEAR - WILC_SPI_REG_BASE,
+					&check);
+		if (ret || ((check & EN_VMM) == (val & EN_VMM)))
+			break;
+
+		retry--;
+	}
+	return ret;
 }
 
 static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
@@ -918,7 +1376,7 @@ static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 		for (i = 0; (i < 3) && (nint > 0); i++, nint--)
 			reg |= BIT(i);
 
-		ret = wilc_spi_read_reg(wilc, WILC_INTR2_ENABLE, &reg);
+		ret = wilc_spi_write_reg(wilc, WILC_INTR2_ENABLE, reg);
 		if (ret) {
 			dev_err(&spi->dev, "Failed write reg (%08x)...\n",
 				WILC_INTR2_ENABLE);
@@ -943,4 +1401,7 @@ static const struct wilc_hif_func wilc_hif_spi = {
 	.hif_block_tx_ext = wilc_spi_write,
 	.hif_block_rx_ext = wilc_spi_read,
 	.hif_sync_ext = wilc_spi_sync_ext,
+	.hif_reset = wilc_spi_reset,
+	.hif_is_init = wilc_spi_is_init,
+	.hif_clear_init = wilc_spi_clear_init,
 };
diff --git a/drivers/net/wireless/microchip/wilc1000/sysfs.c b/drivers/net/wireless/microchip/wilc1000/sysfs.c
new file mode 100644
index 00000000..785ef1a
--- /dev/null
+++ b/drivers/net/wireless/microchip/wilc1000/sysfs.c
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
+ * All rights reserved.
+ */
+
+#include <linux/kobject.h>
+#include "cfg80211.h"
+
+static struct kobject *wilc_kobj;
+static int device_created;
+static struct wilc *wl;
+
+static ssize_t wilc_sysfs_show(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
+{
+	int attr_val = -1;
+
+	if (strcmp(attr->attr.name, "p2p_mode") == 0)
+		attr_val = wl->attr_sysfs.p2p_mode;
+	if (strcmp(attr->attr.name, "ant_swtch_mode") == 0)
+		attr_val = wl->attr_sysfs.ant_swtch_mode;
+	else if (strcmp(attr->attr.name, "antenna1") == 0)
+		attr_val = wl->attr_sysfs.antenna1;
+	else if (strcmp(attr->attr.name, "antenna2") == 0)
+		attr_val = wl->attr_sysfs.antenna2;
+
+	return sprintf(buf, "%d\n", attr_val);
+}
+
+static ssize_t wilc_sysfs_store(struct kobject *kobj,
+				struct kobj_attribute *attr, const char *buf,
+				size_t count)
+{
+	int attr_val;
+
+	if (kstrtoint(buf, 10, &attr_val))
+		pr_err("Failed to convert p2p_mode string");
+	if (strcmp(attr->attr.name, "p2p_mode") == 0) {
+		wl->attr_sysfs.p2p_mode = (attr_val ? 1 : 0);
+	} else if (strcmp(attr->attr.name, "ant_swtch_mode") == 0) {
+		if (attr_val > ANT_SWTCH_DUAL_GPIO_CTRL)
+			pr_err("Valid antenna switch modes:\n1-Single Antenna, 2-Dual Antenna\n");
+		else
+			wl->attr_sysfs.ant_swtch_mode = attr_val;
+	} else if (strcmp(attr->attr.name, "antenna1") == 0) {
+		wl->attr_sysfs.antenna1 = attr_val;
+	} else if (strcmp(attr->attr.name, "antenna2") == 0) {
+		wl->attr_sysfs.antenna2 = attr_val;
+	}
+
+	return count;
+}
+
+static struct kobj_attribute p2p_mode_attr =
+	__ATTR(p2p_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_mode_attr =
+	__ATTR(ant_swtch_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna1_attr =
+	__ATTR(antenna1, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna2_attr =
+	__ATTR(antenna2, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct attribute *wilc_attrs[] = {
+	&p2p_mode_attr.attr,
+	&ant_swtch_mode_attr.attr,
+	&ant_swtch_antenna1_attr.attr,
+	&ant_swtch_antenna2_attr.attr,
+	NULL
+};
+
+static struct attribute_group attr_group = {
+	.attrs = wilc_attrs,
+};
+
+void wilc_sysfs_init(struct wilc *wilc)
+{
+	int retval;
+
+	if (device_created)
+		return;
+
+	wilc_kobj = kobject_create_and_add("wilc", NULL);
+	if (!wilc_kobj) {
+		retval = -ENOMEM;
+		return;
+	}
+
+	retval = sysfs_create_group(wilc_kobj, &attr_group);
+	device_created = 1;
+	wl = wilc;
+	/* By default p2p mode is Group Owner */
+	wl->attr_sysfs.p2p_mode = WILC_P2P_ROLE_GO;
+	wl->attr_sysfs.ant_swtch_mode = ANT_SWTCH_INVALID_GPIO_CTRL;
+	wl->attr_sysfs.antenna1 = 0xFF;
+	wl->attr_sysfs.antenna2 = 0xFF;
+}
+
+void wilc_sysfs_exit(void)
+{
+	device_created = 0;
+	sysfs_remove_group(wilc_kobj, &attr_group);
+	kobject_put(wilc_kobj);
+}
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan.c b/drivers/net/wireless/microchip/wilc1000/wlan.c
index 6a82fb2..3ed49e6 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan.c
+++ b/drivers/net/wireless/microchip/wilc1000/wlan.c
@@ -6,55 +6,59 @@
 
 #include <linux/if_ether.h>
 #include <linux/ip.h>
+#include <net/dsfield.h>
 #include "cfg80211.h"
 #include "wlan_cfg.h"
 
-static inline bool is_wilc1000(u32 id)
-{
-	return (id & (~WILC_CHIP_REV_FIELD)) == WILC_1000_BASE_ID;
-}
+#define WAKE_UP_TRIAL_RETRY		10000
+
+#if KERNEL_VERSION(3, 12, 21) > LINUX_VERSION_CODE
+#define list_next_entry(pos, member) \
+	list_entry((pos)->member.next, typeof(*(pos)), member)
+#endif
 
-static inline void acquire_bus(struct wilc *wilc, enum bus_acquire acquire)
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source)
 {
 	mutex_lock(&wilc->hif_cs);
 	if (acquire == WILC_BUS_ACQUIRE_AND_WAKEUP)
-		chip_wakeup(wilc);
+		chip_wakeup(wilc, source);
 }
 
-static inline void release_bus(struct wilc *wilc, enum bus_release release)
+void release_bus(struct wilc *wilc, enum bus_release release, int source)
 {
 	if (release == WILC_BUS_RELEASE_ALLOW_SLEEP)
-		chip_allow_sleep(wilc);
+		chip_allow_sleep(wilc, source);
 	mutex_unlock(&wilc->hif_cs);
 }
 
-static void wilc_wlan_txq_remove(struct wilc *wilc, struct txq_entry_t *tqe)
+static void wilc_wlan_txq_remove(struct wilc *wilc, u8 q_num,
+				 struct txq_entry_t *tqe)
 {
 	list_del(&tqe->list);
 	wilc->txq_entries -= 1;
+	wilc->txq[q_num].count--;
 }
 
 static struct txq_entry_t *
-wilc_wlan_txq_remove_from_head(struct net_device *dev)
+wilc_wlan_txq_remove_from_head(struct wilc *wilc, u8 q_num)
 {
 	struct txq_entry_t *tqe = NULL;
 	unsigned long flags;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc = vif->wilc;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	if (!list_empty(&wilc->txq_head.list)) {
-		tqe = list_first_entry(&wilc->txq_head.list, struct txq_entry_t,
-				       list);
+	if (!list_empty(&wilc->txq[q_num].txq_head.list)) {
+		tqe = list_first_entry(&wilc->txq[q_num].txq_head.list,
+				       struct txq_entry_t, list);
 		list_del(&tqe->list);
 		wilc->txq_entries -= 1;
+		wilc->txq[q_num].count--;
 	}
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 	return tqe;
 }
 
-static void wilc_wlan_txq_add_to_tail(struct net_device *dev,
+static void wilc_wlan_txq_add_to_tail(struct net_device *dev, u8 q_num,
 				      struct txq_entry_t *tqe)
 {
 	unsigned long flags;
@@ -63,15 +67,19 @@ static void wilc_wlan_txq_add_to_tail(struct net_device *dev,
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	list_add_tail(&tqe->list, &wilc->txq_head.list);
+	list_add_tail(&tqe->list, &wilc->txq[q_num].txq_head.list);
 	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake the txq_handling\n");
 	complete(&wilc->txq_event);
 }
 
-static void wilc_wlan_txq_add_to_head(struct wilc_vif *vif,
+static void wilc_wlan_txq_add_to_head(struct wilc_vif *vif, u8 q_num,
 				      struct txq_entry_t *tqe)
 {
 	unsigned long flags;
@@ -81,12 +89,16 @@ static void wilc_wlan_txq_add_to_head(struct wilc_vif *vif,
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	list_add(&tqe->list, &wilc->txq_head.list);
+	list_add(&tqe->list, &wilc->txq[q_num].txq_head.list);
 	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 	mutex_unlock(&wilc->txq_add_to_head_cs);
 	complete(&wilc->txq_event);
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake up the txq_handler\n");
 }
 
 #define NOT_TCP_ACK			(-1)
@@ -102,6 +114,8 @@ static inline void add_tcp_session(struct wilc_vif *vif, u32 src_prt,
 		f->ack_session_info[f->tcp_session].src_port = src_prt;
 		f->ack_session_info[f->tcp_session].dst_port = dst_prt;
 		f->tcp_session++;
+		PRINT_INFO(vif->ndev, TCP_ENH, "TCP Session %d to Ack %d\n",
+			   f->tcp_session, seq);
 	}
 }
 
@@ -210,9 +224,11 @@ static void wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
 		if (f->pending_acks[i].ack_num < bigger_ack_num) {
 			struct txq_entry_t *tqe;
 
+			PRINT_INFO(vif->ndev, TCP_ENH, "DROP ACK: %u\n",
+				   f->pending_acks[i].ack_num);
 			tqe = f->pending_acks[i].txqe;
 			if (tqe) {
-				wilc_wlan_txq_remove(wilc, tqe);
+				wilc_wlan_txq_remove(wilc, tqe->q_num, tqe);
 				tqe->status = 1;
 				if (tqe->tx_complete_func)
 					tqe->tx_complete_func(tqe->priv,
@@ -233,12 +249,35 @@ static void wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
 	while (dropped > 0) {
-		wait_for_completion_timeout(&wilc->txq_event,
-					    msecs_to_jiffies(1));
+		if (!wait_for_completion_timeout(&wilc->txq_event,
+						 msecs_to_jiffies(1)))
+			PRINT_ER(vif->ndev, "completion timedout\n");
 		dropped--;
 	}
 }
 
+static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+{
+	struct net_device *mon_netdev = NULL;
+	struct wilc_vif *vif;
+	struct ieee80211_hdr *h = (struct ieee80211_hdr *)mac_header;
+
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list) {
+		if (vif->iftype == WILC_STATION_MODE)
+			if (ether_addr_equal_unaligned(h->addr2, vif->bssid))
+				return vif->ndev;
+		if (vif->iftype == WILC_AP_MODE)
+			if (ether_addr_equal_unaligned(h->addr1, vif->bssid))
+				return vif->ndev;
+		if (vif->iftype == WILC_MONITOR_MODE)
+			mon_netdev = vif->ndev;
+	}
+
+	if (!mon_netdev)
+		pr_warn("%s Invalid handle\n", __func__);
+	return mon_netdev;
+}
+
 void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value)
 {
 	vif->ack_filter.enabled = value;
@@ -250,58 +289,238 @@ static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
 	struct txq_entry_t *tqe;
 	struct wilc *wilc = vif->wilc;
 
-	netdev_dbg(vif->ndev, "Adding config packet ...\n");
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding config packet ...\n");
 	if (wilc->quit) {
 		netdev_dbg(vif->ndev, "Return due to clear function\n");
 		complete(&wilc->cfg_event);
 		return 0;
 	}
 
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-	if (!tqe)
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not initialized\n");
+		complete(&wilc->cfg_event);
 		return 0;
+	}
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
+	if (!tqe) {
+		complete(&wilc->cfg_event);
+		return 0;
+	}
 
 	tqe->type = WILC_CFG_PKT;
 	tqe->buffer = buffer;
 	tqe->buffer_size = buffer_size;
 	tqe->tx_complete_func = NULL;
 	tqe->priv = NULL;
+	tqe->q_num = AC_VO_Q;
 	tqe->ack_idx = NOT_TCP_ACK;
 	tqe->vif = vif;
 
-	wilc_wlan_txq_add_to_head(vif, tqe);
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Adding the config packet at the Queue tail\n");
+
+	wilc_wlan_txq_add_to_head(vif, AC_VO_Q, tqe);
+
+	return 1;
+}
+
+static bool is_ac_q_limit(struct wilc *wl, u8 q_num)
+{
+	u8 factors[NQUEUES] = {1, 1, 1, 1};
+	u16 i;
+	unsigned long flags;
+	struct wilc_tx_queue_status *q = &wl->tx_q_limit;
+	u8 end_index;
+	u8 q_limit;
+	bool ret = false;
+
+	spin_lock_irqsave(&wl->txq_spinlock, flags);
+	if (!q->initialized) {
+		for (i = 0; i < AC_BUFFER_SIZE; i++)
+			q->buffer[i] = i % NQUEUES;
+
+		for (i = 0; i < NQUEUES; i++) {
+			q->cnt[i] = AC_BUFFER_SIZE * factors[i] / NQUEUES;
+			q->sum += q->cnt[i];
+		}
+		q->end_index = AC_BUFFER_SIZE - 1;
+		q->initialized = 1;
+	}
+
+	end_index = q->end_index;
+	q->cnt[q->buffer[end_index]] -= factors[q->buffer[end_index]];
+	q->cnt[q_num] += factors[q_num];
+	q->sum += (factors[q_num] - factors[q->buffer[end_index]]);
+
+	q->buffer[end_index] = q_num;
+	if (end_index > 0)
+		q->end_index--;
+	else
+		q->end_index = AC_BUFFER_SIZE - 1;
+
+	if (!q->sum)
+		q_limit = 1;
+	else
+		q_limit = (q->cnt[q_num] * FLOW_CONTROL_UPPER_THRESHOLD / q->sum) + 1;
+
+	if (wl->txq[q_num].count <= q_limit)
+		ret = true;
+
+	spin_unlock_irqrestore(&wl->txq_spinlock, flags);
+
+	return ret;
+}
+
+static inline u8 ac_classify(struct wilc *wilc, struct sk_buff *skb)
+{
+	u8 q_num = AC_BE_Q;
+	u8 dscp;
+
+	switch (skb->protocol) {
+	case htons(ETH_P_IP):
+		dscp = ipv4_get_dsfield(ip_hdr(skb)) & 0xfc;
+		break;
+	case htons(ETH_P_IPV6):
+		dscp = ipv6_get_dsfield(ipv6_hdr(skb)) & 0xfc;
+		break;
+	default:
+		return q_num;
+	}
+
+	switch (dscp) {
+	case 0x08:
+	case 0x20:
+	case 0x40:
+		q_num = AC_BK_Q;
+		break;
+	case 0x80:
+	case 0xA0:
+	case 0x28:
+		q_num = AC_VI_Q;
+		break;
+	case 0xC0:
+	case 0xD0:
+	case 0xE0:
+	case 0x88:
+	case 0xB8:
+		q_num = AC_VO_Q;
+		break;
+	}
+
+	return q_num;
+}
+
+static inline int ac_balance(struct wilc *wl, u8 *ratio)
+{
+	u8 i, max_count = 0;
+
+	if (!ratio)
+		return -EINVAL;
+
+	for (i = 0; i < NQUEUES; i++)
+		if (wl->txq[i].fw.count > max_count)
+			max_count = wl->txq[i].fw.count;
+
+	for (i = 0; i < NQUEUES; i++)
+		ratio[i] = max_count - wl->txq[i].fw.count;
+
+	return 0;
+}
+
+static inline void ac_update_fw_ac_pkt_info(struct wilc *wl, u32 reg)
+{
+	wl->txq[AC_BK_Q].fw.count = FIELD_GET(BK_AC_COUNT_FIELD, reg);
+	wl->txq[AC_BE_Q].fw.count = FIELD_GET(BE_AC_COUNT_FIELD, reg);
+	wl->txq[AC_VI_Q].fw.count = FIELD_GET(VI_AC_COUNT_FIELD, reg);
+	wl->txq[AC_VO_Q].fw.count = FIELD_GET(VO_AC_COUNT_FIELD, reg);
+
+	wl->txq[AC_BK_Q].fw.acm = FIELD_GET(BK_AC_ACM_STAT_FIELD, reg);
+	wl->txq[AC_BE_Q].fw.acm = FIELD_GET(BE_AC_ACM_STAT_FIELD, reg);
+	wl->txq[AC_VI_Q].fw.acm = FIELD_GET(VI_AC_ACM_STAT_FIELD, reg);
+	wl->txq[AC_VO_Q].fw.acm = FIELD_GET(VO_AC_ACM_STAT_FIELD, reg);
+}
+
+static inline u8 ac_change(struct wilc *wilc, u8 *ac)
+{
+	do {
+		if (wilc->txq[*ac].fw.acm == 0)
+			return 0;
+		(*ac)++;
+	} while (*ac < NQUEUES);
 
 	return 1;
 }
 
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+int wilc_wlan_txq_add_net_pkt(struct net_device *dev,
+			      struct tx_complete_data *tx_data, u8 *buffer,
 			      u32 buffer_size,
 			      void (*tx_complete_fn)(void *, int))
 {
 	struct txq_entry_t *tqe;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc;
+	u8 q_num;
+
+	if (!vif) {
+		pr_info("%s vif is NULL\n", __func__);
+		return -1;
+	}
 
 	wilc = vif->wilc;
 
-	if (wilc->quit)
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "drv is quitting, return from net_pkt\n");
+		tx_complete_fn(tx_data, 0);
+		return 0;
+	}
+
+	if (!wilc->initialized) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "not_init, return from net_pkt\n");
+		tx_complete_fn(tx_data, 0);
 		return 0;
+	}
 
 	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
 
-	if (!tqe)
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "malloc failed, return from net_pkt\n");
+		tx_complete_fn(tx_data, 0);
 		return 0;
+	}
 	tqe->type = WILC_NET_PKT;
 	tqe->buffer = buffer;
 	tqe->buffer_size = buffer_size;
 	tqe->tx_complete_func = tx_complete_fn;
-	tqe->priv = priv;
+	tqe->priv = tx_data;
 	tqe->vif = vif;
 
-	tqe->ack_idx = NOT_TCP_ACK;
-	if (vif->ack_filter.enabled)
-		tcp_process(dev, tqe);
-	wilc_wlan_txq_add_to_tail(dev, tqe);
+	q_num = ac_classify(wilc, tx_data->skb);
+	tqe->q_num = q_num;
+	if (ac_change(wilc, &q_num)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "No suitable non-ACM queue\n");
+		tx_complete_fn(tx_data, 0);
+		kfree(tqe);
+		return 0;
+	}
+
+	if (is_ac_q_limit(wilc, q_num)) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "Adding mgmt packet at the Queue tail\n");
+		tqe->ack_idx = NOT_TCP_ACK;
+		if (vif->ack_filter.enabled)
+			tcp_process(dev, tqe);
+		wilc_wlan_txq_add_to_tail(dev, q_num, tqe);
+	} else {
+		tqe->status = 0;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv, tqe->status);
+		kfree(tqe);
+	}
+
 	return wilc->txq_entries;
 }
 
@@ -315,34 +534,48 @@ int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 
 	wilc = vif->wilc;
 
-	if (wilc->quit)
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "drv is quitting\n");
+		tx_complete_fn(priv, 0);
 		return 0;
+	}
 
+	if (!wilc->initialized) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not_init\n");
+		tx_complete_fn(priv, 0);
+		return 0;
+	}
 	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
 
-	if (!tqe)
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Queue malloc failed\n");
+		tx_complete_fn(priv, 0);
 		return 0;
+	}
 	tqe->type = WILC_MGMT_PKT;
 	tqe->buffer = buffer;
 	tqe->buffer_size = buffer_size;
 	tqe->tx_complete_func = tx_complete_fn;
 	tqe->priv = priv;
+	tqe->q_num = AC_BE_Q;
 	tqe->ack_idx = NOT_TCP_ACK;
 	tqe->vif = vif;
-	wilc_wlan_txq_add_to_tail(dev, tqe);
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding Mgmt packet to Queue tail\n");
+	wilc_wlan_txq_add_to_tail(dev, AC_VO_Q, tqe);
 	return 1;
 }
 
-static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc)
+static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc, u8 q_num)
 {
 	struct txq_entry_t *tqe = NULL;
 	unsigned long flags;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	if (!list_empty(&wilc->txq_head.list))
-		tqe = list_first_entry(&wilc->txq_head.list, struct txq_entry_t,
-				       list);
+	if (!list_empty(&wilc->txq[q_num].txq_head.list))
+		tqe = list_first_entry(&wilc->txq[q_num].txq_head.list,
+				       struct txq_entry_t, list);
 
 	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
 
@@ -350,13 +583,14 @@ static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc)
 }
 
 static struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,
-						  struct txq_entry_t *tqe)
+						  struct txq_entry_t *tqe,
+						  u8 q_num)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&wilc->txq_spinlock, flags);
 
-	if (!list_is_last(&tqe->list, &wilc->txq_head.list))
+	if (!list_is_last(&tqe->list, &wilc->txq[q_num].txq_head.list))
 		tqe = list_next_entry(tqe, list);
 	else
 		tqe = NULL;
@@ -389,163 +623,405 @@ static struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)
 	return rqe;
 }
 
-void chip_allow_sleep(struct wilc *wilc)
+static int chip_allow_sleep_wilc1000(struct wilc *wilc, int source)
 {
 	u32 reg = 0;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+	u32 wakeup_reg, wakeup_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	u32 trials = 100;
+	int ret;
 
-	wilc->hif_func->hif_read_reg(wilc, WILC_SDIO_WAKEUP_REG, &reg);
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC1000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC1000_SDIO_WAKEUP_BIT;
+		from_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SDIO_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SDIO_FW_TO_HOST_BIT;
+	} else {
+		wakeup_reg = WILC1000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC1000_SPI_WAKEUP_BIT;
+		from_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SPI_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SPI_FW_TO_HOST_BIT;
+	}
+
+	while (--trials) {
+		ret = hif_func->hif_read_reg(wilc, to_host_from_fw_reg, &reg);
+		if (ret)
+			return ret;
+		if ((reg & to_host_from_fw_bit) == 0)
+			break;
+	}
 
-	wilc->hif_func->hif_write_reg(wilc, WILC_SDIO_WAKEUP_REG,
-				      reg & ~WILC_SDIO_WAKEUP_BIT);
-	wilc->hif_func->hif_write_reg(wilc, WILC_SDIO_HOST_TO_FW_REG, 0);
+	/* Clear bit 1 */
+	ret = hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
+	if (ret)
+		return ret;
+	if (reg & wakeup_bit) {
+		reg &= ~wakeup_bit;
+		ret = hif_func->hif_write_reg(wilc, wakeup_reg, reg);
+		if (ret)
+			return ret;
+	}
+
+	ret = hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
+	if (ret)
+		return ret;
+	if (reg & from_host_to_fw_bit) {
+		reg &= ~from_host_to_fw_bit;
+		ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(chip_allow_sleep);
 
-void chip_wakeup(struct wilc *wilc)
+static int chip_allow_sleep_wilc3000(struct wilc *wilc, int source)
 {
-	u32 reg, clk_status_reg;
-	const struct wilc_hif_func *h = wilc->hif_func;
+	u32 reg = 0;
+	int ret;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
 
-	if (wilc->io_type == WILC_HIF_SPI) {
-		do {
-			h->hif_read_reg(wilc, WILC_SPI_WAKEUP_REG, &reg);
-			h->hif_write_reg(wilc, WILC_SPI_WAKEUP_REG,
-					 reg | WILC_SPI_WAKEUP_BIT);
-			h->hif_write_reg(wilc, WILC_SPI_WAKEUP_REG,
-					 reg & ~WILC_SPI_WAKEUP_BIT);
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		ret = hif_func->hif_read_reg(wilc, WILC3000_SDIO_WAKEUP_REG,
+					     &reg);
+		if (ret)
+			return ret;
+		ret = hif_func->hif_write_reg(wilc, WILC3000_SDIO_WAKEUP_REG,
+					      reg & ~WILC3000_SDIO_WAKEUP_BIT);
+		if (ret)
+			return ret;
+	} else {
+		ret = hif_func->hif_read_reg(wilc, WILC3000_SPI_WAKEUP_REG,
+					     &reg);
+		if (ret)
+			return ret;
+		ret = hif_func->hif_write_reg(wilc, WILC3000_SPI_WAKEUP_REG,
+					      reg & ~WILC3000_SPI_WAKEUP_BIT);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
 
-			do {
-				usleep_range(2000, 2500);
-				wilc_get_chipid(wilc, true);
-			} while (wilc_get_chipid(wilc, true) == 0);
-		} while (wilc_get_chipid(wilc, true) == 0);
-	} else if (wilc->io_type == WILC_HIF_SDIO) {
-		h->hif_write_reg(wilc, WILC_SDIO_HOST_TO_FW_REG,
-				 WILC_SDIO_HOST_TO_FW_BIT);
-		usleep_range(200, 400);
-		h->hif_read_reg(wilc, WILC_SDIO_WAKEUP_REG, &reg);
-		do {
-			h->hif_write_reg(wilc, WILC_SDIO_WAKEUP_REG,
-					 reg | WILC_SDIO_WAKEUP_BIT);
-			h->hif_read_reg(wilc, WILC_SDIO_CLK_STATUS_REG,
-					&clk_status_reg);
-
-			while (!(clk_status_reg & WILC_SDIO_CLK_STATUS_BIT)) {
-				usleep_range(2000, 2500);
-
-				h->hif_read_reg(wilc, WILC_SDIO_CLK_STATUS_REG,
-						&clk_status_reg);
-			}
-			if (!(clk_status_reg & WILC_SDIO_CLK_STATUS_BIT)) {
-				h->hif_write_reg(wilc, WILC_SDIO_WAKEUP_REG,
-						 reg & ~WILC_SDIO_WAKEUP_BIT);
-			}
-		} while (!(clk_status_reg & WILC_SDIO_CLK_STATUS_BIT));
+void chip_allow_sleep(struct wilc *wilc, int source)
+{
+	int ret = 0;
+
+	if (((source == DEV_WIFI) && (wilc->keep_awake[DEV_BT] == true)) ||
+	    ((source == DEV_BT) && (wilc->keep_awake[DEV_WIFI] == true)))
+		pr_warn("Another device is preventing allow sleep operation. request source is %s\n",
+			(source == DEV_WIFI ? "Wifi" : "BT"));
+	else
+		if (wilc->chip == WILC_1000)
+			ret = chip_allow_sleep_wilc1000(wilc, source);
+		else
+			ret = chip_allow_sleep_wilc3000(wilc, source);
+	if (!ret)
+		wilc->keep_awake[source] = false;
+}
+
+static void chip_wakeup_wilc1000(struct wilc *wilc, int source)
+{
+	u32 ret = 0;
+	u32 clk_status_val = 0, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC1000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC1000_SDIO_WAKEUP_BIT;
+		clk_status_reg = WILC1000_SDIO_CLK_STATUS_REG;
+		clk_status_bit = WILC1000_SDIO_CLK_STATUS_BIT;
+		from_host_to_fw_reg = WILC_SDIO_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SDIO_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SDIO_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SDIO_FW_TO_HOST_BIT;
+	} else {
+		wakeup_reg = WILC1000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC1000_SPI_WAKEUP_BIT;
+		clk_status_reg = WILC1000_SPI_CLK_STATUS_REG;
+		clk_status_bit = WILC1000_SPI_CLK_STATUS_BIT;
+		from_host_to_fw_reg = WILC_SPI_HOST_TO_FW_REG;
+		from_host_to_fw_bit = WILC_SPI_HOST_TO_FW_BIT;
+		to_host_from_fw_reg = WILC_SPI_FW_TO_HOST_REG;
+		to_host_from_fw_bit = WILC_SPI_FW_TO_HOST_BIT;
 	}
 
-	if (wilc->chip_ps_state == WILC_CHIP_SLEEPING_MANUAL) {
-		if (wilc_get_chipid(wilc, false) < WILC_1000_BASE_ID_2B) {
-			u32 val32;
+	/* indicate host wakeup */
+	ret = hif_func->hif_write_reg(wilc, from_host_to_fw_reg,
+				      from_host_to_fw_bit);
+	if (ret)
+		return;
 
-			h->hif_read_reg(wilc, WILC_REG_4_TO_1_RX, &val32);
-			val32 |= BIT(6);
-			h->hif_write_reg(wilc, WILC_REG_4_TO_1_RX, val32);
+	/* Set wake-up bit */
+	ret = hif_func->hif_write_reg(wilc, wakeup_reg,
+				      wakeup_bit);
+	if (ret)
+		return;
 
-			h->hif_read_reg(wilc, WILC_REG_4_TO_1_TX_BANK0, &val32);
-			val32 |= BIT(6);
-			h->hif_write_reg(wilc, WILC_REG_4_TO_1_TX_BANK0, val32);
+	while (trials < WAKE_UP_TRIAL_RETRY) {
+		ret = hif_func->hif_read_reg(wilc, clk_status_reg,
+					     &clk_status_val);
+		if (ret) {
+			pr_err("Bus error %d %x\n", ret, clk_status_val);
+			return;
 		}
+		if (clk_status_val & clk_status_bit)
+			break;
+
+		trials++;
 	}
-	wilc->chip_ps_state = WILC_CHIP_WAKEDUP;
+	if (trials >= WAKE_UP_TRIAL_RETRY) {
+		pr_err("Failed to wake-up the chip\n");
+		return;
+	}
+	/* Sometimes spi fail to read clock regs after reading
+	 * writing clockless registers
+	 */
+	if (wilc->io_type == WILC_HIF_SPI)
+		wilc->hif_func->hif_reset(wilc);
+}
+
+static void chip_wakeup_wilc3000(struct wilc *wilc, int source)
+{
+	u32 wakeup_reg_val, clk_status_reg_val, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	int wake_seq_trials = 5;
+	const struct wilc_hif_func *hif_func = wilc->hif_func;
+
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = WILC3000_SDIO_WAKEUP_REG;
+		wakeup_bit = WILC3000_SDIO_WAKEUP_BIT;
+		clk_status_reg = WILC3000_SDIO_CLK_STATUS_REG;
+		clk_status_bit = WILC3000_SDIO_CLK_STATUS_BIT;
+	} else {
+		wakeup_reg = WILC3000_SPI_WAKEUP_REG;
+		wakeup_bit = WILC3000_SPI_WAKEUP_BIT;
+		clk_status_reg = WILC3000_SPI_CLK_STATUS_REG;
+		clk_status_bit = WILC3000_SPI_CLK_STATUS_BIT;
+	}
+
+	hif_func->hif_read_reg(wilc, wakeup_reg, &wakeup_reg_val);
+	do {
+		hif_func->hif_write_reg(wilc, wakeup_reg, wakeup_reg_val |
+							  wakeup_bit);
+		/* Check the clock status */
+		hif_func->hif_read_reg(wilc, clk_status_reg,
+				       &clk_status_reg_val);
+
+		/*
+		 * in case of clocks off, wait 1ms, and check it again.
+		 * if still off, wait for another 1ms, for a total wait of 3ms.
+		 * If still off, redo the wake up sequence
+		 */
+		while ((clk_status_reg_val & clk_status_bit) == 0 &&
+		       (++trials % 4) != 0) {
+			/* Wait for the chip to stabilize*/
+			usleep_range(1000, 1100);
+
+			/*
+			 * Make sure chip is awake. This is an extra step that
+			 * can be removed later to avoid the bus access
+			 * overhead
+			 */
+			hif_func->hif_read_reg(wilc, clk_status_reg,
+					       &clk_status_reg_val);
+		}
+		/* in case of failure, Reset the wakeup bit to introduce a new
+		 * edge on the next loop
+		 */
+		if ((clk_status_reg_val & clk_status_bit) == 0) {
+			hif_func->hif_write_reg(wilc, wakeup_reg,
+						wakeup_reg_val & (~wakeup_bit));
+			/* added wait before wakeup sequence retry */
+			usleep_range(200, 300);
+		}
+	} while (((clk_status_reg_val & clk_status_bit) == 0)
+		 && (wake_seq_trials-- > 0));
+	if (!wake_seq_trials)
+		dev_err(wilc->dev, "clocks still OFF. Wake up failed\n");
+	wilc->keep_awake[source] = true;
+}
+
+void chip_wakeup(struct wilc *wilc, int source)
+{
+	if (wilc->chip == WILC_1000)
+		chip_wakeup_wilc1000(wilc, source);
+	else
+		chip_wakeup_wilc3000(wilc, source);
 }
-EXPORT_SYMBOL_GPL(chip_wakeup);
 
-void host_wakeup_notify(struct wilc *wilc)
+void host_wakeup_notify(struct wilc *wilc, int source)
 {
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_INTERRUPT_2, 1);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, WILC1000_CORTUS_INTERRUPT_2,
+					      1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, WILC3000_CORTUS_INTERRUPT_2,
+					      1);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
 }
-EXPORT_SYMBOL_GPL(host_wakeup_notify);
 
-void host_sleep_notify(struct wilc *wilc)
+void host_sleep_notify(struct wilc *wilc, int source)
 {
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_INTERRUPT_1, 1);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, WILC1000_CORTUS_INTERRUPT_1,
+					      1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, WILC3000_CORTUS_INTERRUPT_1,
+					      1);
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, source);
 }
-EXPORT_SYMBOL_GPL(host_sleep_notify);
 
 int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 {
 	int i, entries = 0;
+	u8 k, ac;
 	u32 sum;
 	u32 reg;
+	u8 ac_desired_ratio[NQUEUES] = {0, 0, 0, 0};
+	u8 ac_preserve_ratio[NQUEUES] = {1, 1, 1, 1};
+	u8 *num_pkts_to_add;
+	u8 vmm_entries_ac[WILC_VMM_TBL_SIZE];
 	u32 offset = 0;
+	bool max_size_over = 0, ac_exist = 0;
 	int vmm_sz = 0;
-	struct txq_entry_t *tqe;
+	struct txq_entry_t *tqe_q[NQUEUES];
 	int ret = 0;
 	int counter;
 	int timeout;
 	u32 vmm_table[WILC_VMM_TBL_SIZE];
+	u8 ac_pkt_num_to_chip[NQUEUES] = {0, 0, 0, 0};
 	const struct wilc_hif_func *func;
+	int srcu_idx;
 	u8 *txb = wilc->tx_buffer;
-	struct net_device *dev;
 	struct wilc_vif *vif;
 
+	if (!wilc->txq_entries) {
+		*txq_count = 0;
+		return 0;
+	}
+
 	if (wilc->quit)
 		goto out_update_cnt;
 
+	if (ac_balance(wilc, ac_desired_ratio))
+		return -EINVAL;
+
 	mutex_lock(&wilc->txq_add_to_head_cs);
-	tqe = wilc_wlan_txq_get_first(wilc);
-	if (!tqe)
-		goto out_unlock;
-	dev = tqe->vif->ndev;
-	wilc_wlan_txq_filter_dup_tcp_ack(dev);
-	i = 0;
-	sum = 0;
-	while (tqe && (i < (WILC_VMM_TBL_SIZE - 1))) {
-		if (tqe->type == WILC_CFG_PKT)
-			vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
-		else if (tqe->type == WILC_NET_PKT)
-			vmm_sz = ETH_ETHERNET_HDR_OFFSET;
-		else
-			vmm_sz = HOST_HDR_OFFSET;
 
-		vmm_sz += tqe->buffer_size;
-		vmm_sz = ALIGN(vmm_sz, 4);
+	srcu_idx = srcu_read_lock(&wilc->srcu);
+	list_for_each_entry_rcu(vif, &wilc->vif_list, list)
+		wilc_wlan_txq_filter_dup_tcp_ack(vif->ndev);
+	srcu_read_unlock(&wilc->srcu, srcu_idx);
 
-		if ((sum + vmm_sz) > WILC_TX_BUFF_SIZE)
-			break;
+	for (ac = 0; ac < NQUEUES; ac++)
+		tqe_q[ac] = wilc_wlan_txq_get_first(wilc, ac);
 
-		vmm_table[i] = vmm_sz / 4;
-		if (tqe->type == WILC_CFG_PKT)
-			vmm_table[i] |= BIT(10);
-		cpu_to_le32s(&vmm_table[i]);
+	i = 0;
+	sum = 0;
+	max_size_over = 0;
+	num_pkts_to_add = ac_desired_ratio;
+	do {
+		ac_exist = 0;
+		for (ac = 0; (ac < NQUEUES) && (!max_size_over); ac++) {
+			if (!tqe_q[ac])
+				continue;
+
+			vif = tqe_q[ac]->vif;
+			ac_exist = 1;
+			for (k = 0; (k < num_pkts_to_add[ac]) &&
+			     (!max_size_over) && tqe_q[ac]; k++) {
+				if (i >= (WILC_VMM_TBL_SIZE - 1)) {
+					max_size_over = 1;
+					break;
+				}
 
-		i++;
-		sum += vmm_sz;
-		tqe = wilc_wlan_txq_get_next(wilc, tqe);
-	}
+				if (tqe_q[ac]->type == WILC_CFG_PKT)
+					vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
+				else if (tqe_q[ac]->type == WILC_NET_PKT)
+					vmm_sz = ETH_ETHERNET_HDR_OFFSET;
+				else
+					vmm_sz = HOST_HDR_OFFSET;
+
+				vmm_sz += tqe_q[ac]->buffer_size;
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMM Size before alignment = %d\n",
+					   vmm_sz);
+				vmm_sz = ALIGN(vmm_sz, 4);
+
+				if ((sum + vmm_sz) > WILC_TX_BUFF_SIZE) {
+					max_size_over = 1;
+					break;
+				}
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMM Size AFTER alignment = %d\n",
+					   vmm_sz);
+				vmm_table[i] = vmm_sz / 4;
+				PRINT_INFO(vif->ndev, TX_DBG,
+					   "VMMTable entry size = %d\n",
+					   vmm_table[i]);
+				if (tqe_q[ac]->type == WILC_CFG_PKT) {
+					vmm_table[i] |= BIT(10);
+					PRINT_INFO(vif->ndev, TX_DBG,
+						   "VMMTable entry changed for CFG packet = %d\n",
+						   vmm_table[i]);
+				}
+				cpu_to_le32s(&vmm_table[i]);
+				vmm_entries_ac[i] = ac;
+
+				i++;
+				sum += vmm_sz;
+				PRINT_INFO(vif->ndev, TX_DBG, "sum = %d\n",
+					   sum);
+				tqe_q[ac] = wilc_wlan_txq_get_next(wilc,
+								   tqe_q[ac],
+								   ac);
+			}
+		}
+		num_pkts_to_add = ac_preserve_ratio;
+	} while (!max_size_over && ac_exist);
 
 	if (i == 0)
 		goto out_unlock;
 	vmm_table[i] = 0x0;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	counter = 0;
 	func = wilc->hif_func;
 	do {
 		ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
-		if (ret)
+		if (ret) {
+			PRINT_ER(vif->ndev,
+				 "fail read reg vmm_tbl_entry..\n");
 			break;
-
-		if ((reg & 0x1) == 0)
+		}
+		if ((reg & 0x1) == 0) {
+			ac_update_fw_ac_pkt_info(wilc, reg);
 			break;
+		}
 
 		counter++;
 		if (counter > 200) {
 			counter = 0;
+			PRINT_INFO(vif->ndev, TX_DBG,
+				   "Looping in tx ctrl , force quit\n");
 			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
 			break;
 		}
@@ -560,22 +1036,79 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 					 WILC_VMM_TBL_RX_SHADOW_BASE,
 					 (u8 *)vmm_table,
 					 ((i + 1) * 4));
-		if (ret)
+		if (ret) {
+			PRINT_ER(vif->ndev,
+				 "ERR block TX of VMM table.\n");
 			break;
+		}
 
-		ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x2);
-		if (ret)
-			break;
+		if (wilc->chip == WILC_1000) {
+			ret = wilc->hif_func->hif_write_reg(wilc,
+							    WILC_HOST_VMM_CTL,
+							    0x2);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					 "fail write reg host_vmm_ctl..\n");
+				break;
+			}
 
-		do {
-			ret = func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);
-			if (ret)
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_HOST_VMM_CTL,
+						      &reg);
+				if (ret)
+					break;
+				if (FIELD_GET(WILC_VMM_ENTRY_AVAILABLE, reg)) {
+					entries = FIELD_GET(WILC_VMM_ENTRY_COUNT,
+							    reg);
+					break;
+				}
+			} while (--timeout);
+		} else {
+			ret = func->hif_write_reg(wilc,
+					      WILC_HOST_VMM_CTL,
+					      0);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					 "fail write reg host_vmm_ctl..\n");
 				break;
-			if (FIELD_GET(WILC_VMM_ENTRY_AVAILABLE, reg)) {
-				entries = FIELD_GET(WILC_VMM_ENTRY_COUNT, reg);
+			}
+			/* interrupt firmware */
+			ret = func->hif_write_reg(wilc,
+					      WILC_INTERRUPT_CORTUS_0,
+					      1);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					 "fail write reg WILC_INTERRUPT_CORTUS_0..\n");
 				break;
 			}
-		} while (--timeout);
+
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_INTERRUPT_CORTUS_0,
+						      &reg);
+				if (ret) {
+					PRINT_ER(vif->ndev,
+						 "fail read reg WILC_INTERRUPT_CORTUS_0..\n");
+					break;
+				}
+				if (reg == 0) {
+					/* Get the entries */
+
+					ret = func->hif_read_reg(wilc,
+							      WILC_HOST_VMM_CTL,
+							      &reg);
+					if (ret) {
+						PRINT_ER(vif->ndev,
+							 "fail read reg host_vmm_ctl..\n");
+						break;
+					}
+					entries = FIELD_GET(WILC_VMM_ENTRY_COUNT,
+							    reg);
+					break;
+				}
+			} while (--timeout);
+		}
 		if (timeout <= 0) {
 			ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
 			break;
@@ -585,11 +1118,21 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 			break;
 
 		if (entries == 0) {
+			PRINT_INFO(vif->ndev, TX_DBG,
+				   "no buffer in the chip (reg: %08x), retry later [[ %d, %x ]]\n",
+				   reg, i, vmm_table[i - 1]);
 			ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
-			if (ret)
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					 "fail read reg WILC_HOST_TX_CTRL..\n");
 				break;
+			}
 			reg &= ~BIT(0);
 			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
+			if (ret) {
+				PRINT_ER(vif->ndev,
+					 "fail write reg WILC_HOST_TX_CTRL..\n");
+			}
 		}
 	} while (0);
 
@@ -597,31 +1140,31 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 		goto out_release_bus;
 
 	if (entries == 0) {
-		/*
-		 * No VMM space available in firmware so retry to transmit
-		 * the packet from tx queue.
+		/* No VMM entry space available in firmware so try again to
+		 * transmit the packet from tx queue
 		 */
 		ret = WILC_VMM_ENTRY_FULL_RETRY;
 		goto out_release_bus;
 	}
 
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
-
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+	schedule();
 	offset = 0;
 	i = 0;
 	do {
+		struct txq_entry_t *tqe;
 		u32 header, buffer_offset;
-		char *bssid;
 		u8 mgmt_ptk = 0;
 
-		tqe = wilc_wlan_txq_remove_from_head(dev);
-		if (!tqe)
+		if (vmm_table[i] == 0 || vmm_entries_ac[i] >= NQUEUES)
 			break;
 
-		vif = tqe->vif;
-		if (vmm_table[i] == 0)
+		tqe = wilc_wlan_txq_remove_from_head(wilc, vmm_entries_ac[i]);
+		if (!tqe)
 			break;
 
+		ac_pkt_num_to_chip[vmm_entries_ac[i]]++;
+		vif = tqe->vif;
 		le32_to_cpus(&vmm_table[i]);
 		vmm_sz = FIELD_GET(WILC_VMM_BUFFER_SIZE, vmm_table[i]);
 		vmm_sz *= 4;
@@ -639,8 +1182,11 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 		if (tqe->type == WILC_CFG_PKT) {
 			buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
 		} else if (tqe->type == WILC_NET_PKT) {
-			bssid = tqe->vif->bssid;
+			char *bssid = tqe->vif->bssid;
+			int prio = tqe->q_num;
+
 			buffer_offset = ETH_ETHERNET_HDR_OFFSET;
+			memcpy(&txb[offset + 4], &prio, sizeof(prio));
 			memcpy(&txb[offset + 8], bssid, 6);
 		} else {
 			buffer_offset = HOST_HDR_OFFSET;
@@ -658,20 +1204,30 @@ int wilc_wlan_handle_txq(struct wilc *wilc, u32 *txq_count)
 			vif->ack_filter.pending_acks[tqe->ack_idx].txqe = NULL;
 		kfree(tqe);
 	} while (--entries);
+	for (i = 0; i < NQUEUES; i++)
+		wilc->txq[i].fw.count += ac_pkt_num_to_chip[i];
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 
 	ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
-	if (ret)
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail start tx VMM ...\n");
 		goto out_release_bus;
+	}
 
 	ret = func->hif_block_tx_ext(wilc, 0, txb, offset);
+	if (ret)
+		PRINT_ER(vif->ndev, "fail block tx ext...\n");
+
+	if (!ret)
+		cfg_packet_timeout = 0;
 
 out_release_bus:
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 out_unlock:
 	mutex_unlock(&wilc->txq_add_to_head_cs);
+	schedule();
 
 out_update_cnt:
 	*txq_count = wilc->txq_entries;
@@ -695,31 +1251,51 @@ static void wilc_wlan_handle_rx_buff(struct wilc *wilc, u8 *buffer, int size)
 		tp_len = FIELD_GET(WILC_PKT_HDR_TOTAL_LEN_FIELD, header);
 		pkt_len = FIELD_GET(WILC_PKT_HDR_LEN_FIELD, header);
 
-		if (pkt_len == 0 || tp_len == 0)
+		if (pkt_len == 0 || tp_len == 0) {
+			pr_err("%s: Data corrupted %d, %d\n", __func__,
+			       pkt_len, tp_len);
 			break;
+		}
+
+		if (is_cfg_packet) {
+			struct wilc_cfg_rsp rsp;
 
-		if (pkt_offset & IS_MANAGMEMENT) {
+			buff_ptr += pkt_offset;
+
+			wilc_wlan_cfg_indicate_rx(wilc, buff_ptr, pkt_len,
+						  &rsp);
+			if (rsp.type == WILC_CFG_RSP) {
+				if (wilc->cfg_seq_no == rsp.seq_no)
+					complete(&wilc->cfg_event);
+			} else if (rsp.type == WILC_CFG_RSP_STATUS) {
+				wilc_mac_indicate(wilc);
+			}
+		} else if (pkt_offset & IS_MANAGMEMENT) {
 			buff_ptr += HOST_HDR_OFFSET;
-			wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len);
+
+			if (pkt_offset & IS_MON_PKT)
+				wilc_wfi_handle_monitor_rx(wilc, buff_ptr,
+							   pkt_len);
+			else
+				wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len,
+						 pkt_offset & IS_MGMT_AUTH_PKT);
 		} else {
-			if (!is_cfg_packet) {
-				wilc_frmw_to_host(wilc, buff_ptr, pkt_len,
-						  pkt_offset);
-			} else {
-				struct wilc_cfg_rsp rsp;
-
-				buff_ptr += pkt_offset;
-
-				wilc_wlan_cfg_indicate_rx(wilc, buff_ptr,
-							  pkt_len,
-							  &rsp);
-				if (rsp.type == WILC_CFG_RSP) {
-					if (wilc->cfg_seq_no == rsp.seq_no)
-						complete(&wilc->cfg_event);
-				} else if (rsp.type == WILC_CFG_RSP_STATUS) {
-					wilc_mac_indicate(wilc);
-				}
+			struct net_device *wilc_netdev;
+			struct wilc_vif *vif;
+			int srcu_idx;
+
+			srcu_idx = srcu_read_lock(&wilc->srcu);
+			wilc_netdev = get_if_handler(wilc, buff_ptr);
+			if (!wilc_netdev) {
+				pr_err("%s: wilc_netdev in wilc is NULL\n",
+				       __func__);
+				srcu_read_unlock(&wilc->srcu, srcu_idx);
+				return;
 			}
+			vif = netdev_priv(wilc_netdev);
+			wilc_frmw_to_host(vif, buff_ptr, pkt_len,
+					  pkt_offset, PKT_STATUS_NEW);
+			srcu_read_unlock(&wilc->srcu, srcu_idx);
 		}
 		offset += tp_len;
 	} while (offset < size);
@@ -742,8 +1318,11 @@ static void wilc_wlan_handle_rxq(struct wilc *wilc)
 
 		kfree(rqe);
 	}
-	if (wilc->quit)
+	if (wilc->quit) {
+		pr_info("%s Quitting. Exit handle RX queue\n",
+			__func__);
 		complete(&wilc->cfg_event);
+	}
 }
 
 static void wilc_unknown_isr_ext(struct wilc *wilc)
@@ -763,6 +1342,8 @@ static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
 	size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, int_status) << 2;
 
 	while (!size && retries < 10) {
+		pr_err("%s: RX Size equal zero Trying to read it again\n",
+		       __func__);
 		wilc->hif_func->hif_read_size(wilc, &size);
 		size = FIELD_GET(WILC_INTERRUPT_DATA_SIZE, size) << 2;
 		retries++;
@@ -778,8 +1359,10 @@ static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
 
 	wilc->hif_func->hif_clear_int_ext(wilc, DATA_INT_CLR | ENABLE_RX_VMM);
 	ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
-	if (ret)
+	if (ret) {
+		pr_err("%s: fail block rx\n", __func__);
 		return;
+	}
 
 	offset += size;
 	wilc->rx_buffer_offset = offset;
@@ -797,18 +1380,20 @@ void wilc_handle_isr(struct wilc *wilc)
 {
 	u32 int_status;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	wilc->hif_func->hif_read_int(wilc, &int_status);
 
 	if (int_status & DATA_INT_EXT)
 		wilc_wlan_handle_isr_ext(wilc, int_status);
 
-	if (!(int_status & (ALL_INT_EXT)))
+	if (!(int_status & (ALL_INT_EXT))) {
+		pr_warn("%s,>> UNKNOWN_INTERRUPT - 0x%08x\n", __func__,
+			int_status);
 		wilc_unknown_isr_ext(wilc);
+	}
 
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 }
-EXPORT_SYMBOL_GPL(wilc_handle_isr);
 
 int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size)
@@ -817,6 +1402,7 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 	u32 addr, size, size2, blksz;
 	u8 *dma_buffer;
 	int ret = 0;
+	u32 reg = 0;
 
 	blksz = BIT(12);
 
@@ -825,10 +1411,22 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 		return -EIO;
 
 	offset = 0;
+	pr_info("%s: Downloading firmware size = %d\n", __func__, buffer_size);
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	reg &= ~BIT(10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if (reg & BIT(10))
+		pr_err("%s: Failed to reset\n", __func__);
+
+	release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
 	do {
 		addr = get_unaligned_le32(&buffer[offset]);
 		size = get_unaligned_le32(&buffer[offset + 4]);
-		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 		offset += 8;
 		while (((int)size) && (offset < buffer_size)) {
 			if (size <= blksz)
@@ -846,55 +1444,56 @@ int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 			offset += size2;
 			size -= size2;
 		}
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
-		if (ret)
+		if (ret) {
+			pr_err("%s Bus error\n", __func__);
 			goto fail;
+		}
+		pr_info("%s Offset = %d\n", __func__, offset);
 	} while (offset < buffer_size);
 
 fail:
 
 	kfree(dma_buffer);
 
-	return ret;
+	return (ret < 0) ? ret : 0;
 }
 
 int wilc_wlan_start(struct wilc *wilc)
 {
 	u32 reg = 0;
 	int ret;
-	u32 chipid;
 
-	if (wilc->io_type == WILC_HIF_SDIO) {
-		reg = 0;
+	if (wilc->io_type == WILC_HIF_SDIO ||
+	    wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ)
 		reg |= BIT(3);
-	} else if (wilc->io_type == WILC_HIF_SPI) {
+	else if (wilc->io_type == WILC_HIF_SPI)
 		reg = 1;
-	}
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
+
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
 	if (ret) {
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+		pr_err("[wilc start]: fail write reg vmm_core_cfg...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 	reg = 0;
-	if (wilc->io_type == WILC_HIF_SDIO && wilc->dev_irq_num)
+	if (wilc->io_type == WILC_HIF_SDIO_GPIO_IRQ)
 		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
 
+	if (wilc->chip == WILC_3000)
+		reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
+
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
 	if (ret) {
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+		pr_err("[wilc start]: fail write WILC_GP_REG_1...\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 
 	wilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);
 
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID, &chipid);
-	if (ret) {
-		release_bus(wilc, WILC_BUS_RELEASE_ONLY);
-		return ret;
-	}
-
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
 	if ((reg & BIT(10)) == BIT(10)) {
 		reg &= ~BIT(10);
@@ -905,9 +1504,14 @@ int wilc_wlan_start(struct wilc *wilc)
 	reg |= BIT(10);
 	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
 	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
 
-	return ret;
+	if (!ret)
+		wilc->initialized = 1;
+	else
+		wilc->initialized = 0;
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+
+	return (ret < 0) ? ret : 0;
 }
 
 int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif)
@@ -915,39 +1519,58 @@ int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif)
 	u32 reg = 0;
 	int ret;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
+	/* Clear Wifi mode*/
+	ret = wilc->hif_func->hif_read_reg(wilc, GLOBAL_MODE_CONTROL, &reg);
+	if (ret) {
+		netdev_err(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return -EIO;
+	}
+
+	reg &= ~BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, GLOBAL_MODE_CONTROL, reg);
+	if (ret) {
+		netdev_err(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
+		return -EIO;
+	}
+
+	/* Configure the power sequencer to ignore WIFI sleep signal on making
+	 * chip sleep decision
+	 */
+	ret = wilc->hif_func->hif_read_reg(wilc, PWR_SEQ_MISC_CTRL, &reg);
 	if (ret) {
 		netdev_err(vif->ndev, "Error while reading reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
-					(reg | WILC_ABORT_REQ_BIT));
+	reg &= ~BIT(28);
+	ret = wilc->hif_func->hif_write_reg(wilc, PWR_SEQ_MISC_CTRL, reg);
 	if (ret) {
 		netdev_err(vif->ndev, "Error while writing reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_FW_HOST_COMM, &reg);
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
 	if (ret) {
 		netdev_err(vif->ndev, "Error while reading reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
-	reg = BIT(0);
 
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_FW_HOST_COMM, reg);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
+					(reg | WILC_ABORT_REQ_BIT));
 	if (ret) {
 		netdev_err(vif->ndev, "Error while writing reg\n");
-		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+		release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 		return ret;
 	}
 
-	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP);
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return 0;
 }
@@ -956,14 +1579,17 @@ void wilc_wlan_cleanup(struct net_device *dev)
 {
 	struct txq_entry_t *tqe;
 	struct rxq_entry_t *rqe;
+	u8 ac;
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 
 	wilc->quit = 1;
-	while ((tqe = wilc_wlan_txq_remove_from_head(dev))) {
-		if (tqe->tx_complete_func)
-			tqe->tx_complete_func(tqe->priv, 0);
-		kfree(tqe);
+	for (ac = 0; ac < NQUEUES; ac++) {
+		while ((tqe = wilc_wlan_txq_remove_from_head(wilc, ac))) {
+			if (tqe->tx_complete_func)
+				tqe->tx_complete_func(tqe->priv, 0);
+			kfree(tqe);
+		}
 	}
 
 	while ((rqe = wilc_wlan_rxq_remove(wilc)))
@@ -973,7 +1599,6 @@ void wilc_wlan_cleanup(struct net_device *dev)
 	wilc->rx_buffer = NULL;
 	kfree(wilc->tx_buffer);
 	wilc->tx_buffer = NULL;
-	wilc->hif_func->hif_deinit(NULL);
 }
 
 static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
@@ -1022,7 +1647,9 @@ int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
 		return ret_size;
 	}
 
-	netdev_dbg(vif->ndev, "%s: seqno[%d]\n", __func__, wilc->cfg_seq_no);
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "[WILC]PACKET Commit with sequence number%d\n",
+		   wilc->cfg_seq_no);
 
 	if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
 		ret_size = 0;
@@ -1077,6 +1704,7 @@ int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 	return ret_size;
 }
 
+unsigned int cfg_packet_timeout;
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count)
 {
@@ -1084,13 +1712,24 @@ int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 	int ret = 0;
 	u32 drv = wilc_get_vif_idx(vif);
 
+	if (wait_for_recovery) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is suspended\n");
+		while (wait_for_recovery)
+			msleep(300);
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is resumed\n");
+	}
+
 	if (mode == WILC_GET_CFG) {
 		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_get(vif, !i,
-					       wids[i].id,
-					       (i == count - 1),
-					       drv)) {
+			PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"Sending CFG packet [%d][%d]\n", !i,
+				(i == count - 1));
+			if (!wilc_wlan_cfg_get(vif, !i, wids[i].id,
+					       (i == count - 1), drv)) {
 				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Get Timed out\n");
 				break;
 			}
 		}
@@ -1102,18 +1741,19 @@ int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 		}
 	} else if (mode == WILC_SET_CFG) {
 		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_set(vif, !i,
-					       wids[i].id,
-					       wids[i].val,
+			PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+				   "Sending config SET PACKET WID:%x\n",
+				   wids[i].id);
+			if (!wilc_wlan_cfg_set(vif, !i, wids[i].id, wids[i].val,
 					       wids[i].size,
-					       (i == count - 1),
-					       drv)) {
+					       (i == count - 1), drv)) {
 				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Set Timed out\n");
 				break;
 			}
 		}
 	}
-
+	cfg_packet_timeout = (ret < 0) ? cfg_packet_timeout + 1 : 0;
 	return ret;
 }
 
@@ -1125,68 +1765,76 @@ static int init_chip(struct net_device *dev)
 	struct wilc_vif *vif = netdev_priv(dev);
 	struct wilc *wilc = vif->wilc;
 
-	acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY);
+	acquire_bus(wilc, WILC_BUS_ACQUIRE_AND_WAKEUP, DEV_WIFI);
 
 	chipid = wilc_get_chipid(wilc, true);
 
-	if ((chipid & 0xfff) != 0xa0) {
-		ret = wilc->hif_func->hif_read_reg(wilc,
-						   WILC_CORTUS_RESET_MUX_SEL,
-						   &reg);
-		if (ret) {
-			netdev_err(dev, "fail read reg 0x1118\n");
-			goto release;
-		}
-		reg |= BIT(0);
-		ret = wilc->hif_func->hif_write_reg(wilc,
-						    WILC_CORTUS_RESET_MUX_SEL,
-						    reg);
-		if (ret) {
-			netdev_err(dev, "fail write reg 0x1118\n");
-			goto release;
-		}
-		ret = wilc->hif_func->hif_write_reg(wilc,
-						    WILC_CORTUS_BOOT_REGISTER,
-						    WILC_CORTUS_BOOT_FROM_IRAM);
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_CORTUS_RESET_MUX_SEL,
+					   &reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail read reg 0x1118\n");
+		goto end;
+	}
+
+	reg |= BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_RESET_MUX_SEL,
+					    reg);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0x1118\n");
+		goto end;
+	}
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_CORTUS_BOOT_REGISTER,
+					    WILC_CORTUS_BOOT_FROM_IRAM);
+	if (ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0xc0000 ...\n");
+		goto end;
+	}
+
+	if (wilc->chip == WILC_3000) {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x207ac, &reg);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Bootrom sts = %x\n", reg);
+		ret = wilc->hif_func->hif_write_reg(wilc, 0x4f0000,
+						    0x71);
 		if (ret) {
-			netdev_err(dev, "fail write reg 0xc0000\n");
-			goto release;
+			PRINT_ER(vif->ndev, "fail write reg 0x4f0000 ...\n");
+			goto end;
 		}
 	}
 
-release:
-	release_bus(wilc, WILC_BUS_RELEASE_ONLY);
+end:
+	release_bus(wilc, WILC_BUS_RELEASE_ALLOW_SLEEP, DEV_WIFI);
 
 	return ret;
 }
 
 u32 wilc_get_chipid(struct wilc *wilc, bool update)
 {
-	static u32 chipid;
-	u32 tempchipid = 0;
-	u32 rfrevid = 0;
-
-	if (chipid == 0 || update) {
-		wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID, &tempchipid);
-		wilc->hif_func->hif_read_reg(wilc, WILC_RF_REVISION_ID,
-					     &rfrevid);
-		if (!is_wilc1000(tempchipid)) {
-			chipid = 0;
-			return chipid;
-		}
-		if (tempchipid == WILC_1000_BASE_ID_2A) { /* 0x1002A0 */
-			if (rfrevid != 0x1)
-				tempchipid = WILC_1000_BASE_ID_2A_REV1;
-		} else if (tempchipid == WILC_1000_BASE_ID_2B) { /* 0x1002B0 */
-			if (rfrevid == 0x4)
-				tempchipid = WILC_1000_BASE_ID_2B_REV1;
-			else if (rfrevid != 0x3)
-				tempchipid = WILC_1000_BASE_ID_2B_REV2;
-		}
+	int ret;
+	u32 chipid = 0;
 
-		chipid = tempchipid;
+	if (wilc->chipid == 0 || update) {
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC3000_CHIP_ID,
+						   &chipid);
+		if (ret)
+			pr_err("[wilc start]: fail read reg 0x3b0000\n");
+		if (!is_wilc3000(chipid)) {
+			wilc->hif_func->hif_read_reg(wilc, WILC_CHIPID,
+						     &chipid);
+			if (!is_wilc1000(chipid)) {
+				wilc->chipid = 0;
+				return wilc->chipid;
+			}
+			if (chipid < 0x1003a0) {
+				pr_err("WILC1002 isn't supported %x\n",
+				       wilc->chipid);
+				wilc->chipid = 0;
+				return wilc->chipid;
+			}
+		}
+		wilc->chipid = chipid;
 	}
-	return chipid;
+
+	return wilc->chipid;
 }
 
 int wilc_wlan_init(struct net_device *dev)
@@ -1199,9 +1847,16 @@ int wilc_wlan_init(struct net_device *dev)
 
 	wilc->quit = 0;
 
-	if (wilc->hif_func->hif_init(wilc, false)) {
-		ret = -EIO;
-		goto fail;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing WILC_Wlan\n");
+
+	if (!wilc->hif_func->hif_is_init(wilc)) {
+		acquire_bus(wilc, WILC_BUS_ACQUIRE_ONLY, DEV_WIFI);
+		ret = wilc->hif_func->hif_init(wilc, false);
+		if (ret) {
+			release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
+			goto fail;
+		}
+		release_bus(wilc, WILC_BUS_RELEASE_ONLY, DEV_WIFI);
 	}
 
 	if (!wilc->tx_buffer)
@@ -1209,21 +1864,22 @@ int wilc_wlan_init(struct net_device *dev)
 
 	if (!wilc->tx_buffer) {
 		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Tx Buffer");
 		goto fail;
 	}
 
 	if (!wilc->rx_buffer)
 		wilc->rx_buffer = kmalloc(WILC_RX_BUFF_SIZE, GFP_KERNEL);
-
+	PRINT_D(vif->ndev, TX_DBG, "g_wlan.rx_buffer =%p\n", wilc->rx_buffer);
 	if (!wilc->rx_buffer) {
 		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Rx Buffer");
 		goto fail;
 	}
 
-	if (init_chip(dev)) {
-		ret = -EIO;
+	ret = init_chip(dev);
+	if (ret)
 		goto fail;
-	}
 
 	return 0;
 
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan.h b/drivers/net/wireless/microchip/wilc1000/wlan.h
index 7689569..c6a1e11 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan.h
+++ b/drivers/net/wireless/microchip/wilc1000/wlan.h
@@ -8,7 +8,12 @@
 #define WILC_WLAN_H
 
 #include <linux/types.h>
+#include <linux/version.h>
+
+#if KERNEL_VERSION(4, 9, 0) <= LINUX_VERSION_CODE
 #include <linux/bitfield.h>
+#endif
+
 
 /********************************************
  *
@@ -38,6 +43,8 @@
 
 #define ETH_CONFIG_PKT_HDR_OFFSET	(ETH_ETHERNET_HDR_OFFSET + \
 					 ETH_CONFIG_PKT_HDR_LEN)
+#define PKT_STATUS_NEW          0
+#define PKT_STATUS_BUFFERED     1
 
 /********************************************
  *
@@ -45,7 +52,6 @@
  *
  ********************************************/
 #define WILC_PERIPH_REG_BASE		0x1000
-#define WILC_CHANGING_VIR_IF		0x108c
 #define WILC_CHIPID			WILC_PERIPH_REG_BASE
 #define WILC_GLB_RESET_0		(WILC_PERIPH_REG_BASE + 0x400)
 #define WILC_PIN_MUX_0			(WILC_PERIPH_REG_BASE + 0x408)
@@ -58,6 +64,14 @@
 #define WILC_HOST_TX_CTRL_1		(WILC_PERIPH_REG_BASE + 0x88)
 #define WILC_MISC			(WILC_PERIPH_REG_BASE + 0x428)
 #define WILC_INTR_REG_BASE		(WILC_PERIPH_REG_BASE + 0xa00)
+
+#define WILC_INTERRUPT_CORTUS_0		(WILC_PERIPH_REG_BASE + 0xa8)
+#define WILC1000_CORTUS_INTERRUPT_1	(WILC_INTERRUPT_CORTUS_0 + 0x4)
+#define WILC3000_CORTUS_INTERRUPT_1	(WILC_INTERRUPT_CORTUS_0 + 0x14)
+
+#define WILC1000_CORTUS_INTERRUPT_2	(WILC_INTERRUPT_CORTUS_0 + 0x8)
+#define WILC3000_CORTUS_INTERRUPT_2	(WILC_INTERRUPT_CORTUS_0 + 0x18)
+
 #define WILC_INTR_ENABLE		WILC_INTR_REG_BASE
 #define WILC_INTR2_ENABLE		(WILC_INTR_REG_BASE + 4)
 
@@ -66,8 +80,6 @@
 #define WILC_INTR_CLEAR			(WILC_INTR_REG_BASE + 0x30)
 #define WILC_INTR_STATUS		(WILC_INTR_REG_BASE + 0x40)
 
-#define WILC_RF_REVISION_ID		0x13f4
-
 #define WILC_VMM_TBL_SIZE		64
 #define WILC_VMM_TX_TBL_BASE		0x150400
 #define WILC_VMM_RX_TBL_BASE		0x150500
@@ -94,8 +106,25 @@
 #define WILC_SPI_INT_STATUS		(WILC_SPI_REG_BASE + 0x40)
 #define WILC_SPI_INT_CLEAR		(WILC_SPI_REG_BASE + 0x44)
 
-#define WILC_SPI_WAKEUP_REG		0x1
-#define WILC_SPI_WAKEUP_BIT		BIT(1)
+/* WILC1000 specific */
+#define WILC1000_SPI_WAKEUP_REG	0x1
+#define WILC1000_SPI_WAKEUP_BIT	BIT(1)
+
+#define WILC1000_SPI_CLK_STATUS_REG	0x0f
+#define WILC1000_SPI_CLK_STATUS_BIT	BIT(2)
+
+/* WILC3000 specific */
+#define WILC3000_SPI_WAKEUP_REG	0x1
+#define WILC3000_SPI_WAKEUP_BIT	BIT(1)
+
+#define WILC3000_SPI_CLK_STATUS_REG	0x13
+#define WILC3000_SPI_CLK_STATUS_BIT	BIT(2)
+
+#define WILC_SPI_HOST_TO_FW_REG		0x0b
+#define WILC_SPI_HOST_TO_FW_BIT		BIT(0)
+
+#define WILC_SPI_FW_TO_HOST_REG		0x10
+#define WILC_SPI_FW_TO_HOST_BIT		BIT(0)
 
 #define WILC_SPI_PROTOCOL_OFFSET	(WILC_SPI_PROTOCOL_CONFIG - \
 					 WILC_SPI_REG_BASE)
@@ -113,17 +142,31 @@
 #define WILC_SDIO_CCCR_ABORT_RESET	BIT(3)
 
 /* Vendor specific CCCR registers */
-#define WILC_SDIO_WAKEUP_REG		0xf0
-#define WILC_SDIO_WAKEUP_BIT		BIT(0)
+/* WILC1000 */
+#define WILC1000_SDIO_WAKEUP_REG	0xf0
+#define WILC1000_SDIO_WAKEUP_BIT	BIT(0)
+
+#define WILC1000_SDIO_CLK_STATUS_REG	0xf1
+#define WILC1000_SDIO_CLK_STATUS_BIT	BIT(0)
+
+#define WILC1000_SDIO_IRQ_FLAG_REG	0xf7
+#define WILC1000_SDIO_IRQ_CLEAR_FLAG_REG	0xf8
+
+/* WILC3000 specific */
+#define WILC3000_SDIO_WAKEUP_REG	0xf0
+#define WILC3000_SDIO_WAKEUP_BIT	BIT(0)
+
+#define WILC3000_SDIO_CLK_STATUS_REG	0xf0 /* clk & wakeup are on same reg*/
+#define WILC3000_SDIO_CLK_STATUS_BIT	BIT(4)
 
-#define WILC_SDIO_CLK_STATUS_REG	0xf1
-#define WILC_SDIO_CLK_STATUS_BIT	BIT(0)
+#define WILC3000_SDIO_IRQ_FLAG_REG	0xfe
+#define WILC3000_SDIO_IRQ_CLEAR_FLAG_REG	0xfe
+#define WILC3000_SDIO_VMM_TBL_CTRL_REG	0xf1
 
+/* Common vendor specific CCCR register */
 #define WILC_SDIO_INTERRUPT_DATA_SZ_REG	0xf2 /* Read size (2 bytes) */
 
 #define WILC_SDIO_VMM_TBL_CTRL_REG	0xf6
-#define WILC_SDIO_IRQ_FLAG_REG		0xf7
-#define WILC_SDIO_IRQ_CLEAR_FLAG_REG	0xf8
 
 #define WILC_SDIO_HOST_TO_FW_REG	0xfa
 #define WILC_SDIO_HOST_TO_FW_BIT	BIT(0)
@@ -144,23 +187,19 @@
 #define WILC_VMM_TBL_RX_SHADOW_BASE	WILC_AHB_SHARE_MEM_BASE
 #define WILC_VMM_TBL_RX_SHADOW_SIZE	256
 
-#define WILC_FW_HOST_COMM		0x13c0
 #define WILC_GP_REG_0			0x149c
 #define WILC_GP_REG_1			0x14a0
 
+#define GLOBAL_MODE_CONTROL		0x1614
+#define PWR_SEQ_MISC_CTRL		0x3008
+#define COE_AUTO_PS_ON_NULL_PKT		0x160468
+#define COE_AUTO_PS_OFF_NULL_PKT	0x16046C
+#define CCA_CTL_2 (0x160EF4)
+#define CCA_CTL_7 (0x160F08)
+
 #define WILC_HAVE_SDIO_IRQ_GPIO		BIT(0)
-#define WILC_HAVE_USE_PMU		BIT(1)
 #define WILC_HAVE_SLEEP_CLK_SRC_RTC	BIT(2)
 #define WILC_HAVE_SLEEP_CLK_SRC_XO	BIT(3)
-#define WILC_HAVE_EXT_PA_INV_TX_RX	BIT(4)
-#define WILC_HAVE_LEGACY_RF_SETTINGS	BIT(5)
-#define WILC_HAVE_XTAL_24		BIT(6)
-#define WILC_HAVE_DISABLE_WILC_UART	BIT(7)
-#define WILC_HAVE_USE_IRQ_AS_HOST_WAKE	BIT(8)
-
-#define WILC_CORTUS_INTERRUPT_BASE	0x10A8
-#define WILC_CORTUS_INTERRUPT_1		(WILC_CORTUS_INTERRUPT_BASE + 0x4)
-#define WILC_CORTUS_INTERRUPT_2		(WILC_CORTUS_INTERRUPT_BASE + 0x8)
 
 /* tx control register 1 to 4 for RX */
 #define WILC_REG_4_TO_1_RX		0x1e1c
@@ -170,19 +209,24 @@
 
 #define WILC_CORTUS_RESET_MUX_SEL	0x1118
 #define WILC_CORTUS_BOOT_REGISTER	0xc0000
+#define WILC3000_CHIP_ID		0x3b0000
 
 #define WILC_CORTUS_BOOT_FROM_IRAM	0x71
 
 #define WILC_1000_BASE_ID		0x100000
+#define WILC_3000_BASE_ID		0x300000
 
-#define WILC_1000_BASE_ID_2A		0x1002A0
-#define WILC_1000_BASE_ID_2A_REV1	(WILC_1000_BASE_ID_2A + 1)
+#define WILC_CHIP_REV_FIELD		GENMASK(11, 0)
 
-#define WILC_1000_BASE_ID_2B		0x1002B0
-#define WILC_1000_BASE_ID_2B_REV1	(WILC_1000_BASE_ID_2B + 1)
-#define WILC_1000_BASE_ID_2B_REV2	(WILC_1000_BASE_ID_2B + 2)
+static inline bool is_wilc1000(u32 id)
+{
+	return (id & (~WILC_CHIP_REV_FIELD)) == WILC_1000_BASE_ID;
+}
 
-#define WILC_CHIP_REV_FIELD		GENMASK(11, 0)
+static inline bool is_wilc3000(u32 id)
+{
+	return (id & (~WILC_CHIP_REV_FIELD)) == WILC_3000_BASE_ID;
+}
 
 /********************************************
  *
@@ -206,6 +250,20 @@
 #define WILC_TX_BUFF_SIZE	(64 * 1024)
 
 #define MODALIAS		"WILC_SPI"
+#define GPIO_NUM_CHIP_EN	94
+#define GPIO_NUM_RESET		60
+
+#define NQUEUES			4
+#define AC_BUFFER_SIZE		1000
+
+#define VO_AC_COUNT_FIELD		GENMASK(31, 25)
+#define VO_AC_ACM_STAT_FIELD		BIT(24)
+#define VI_AC_COUNT_FIELD		GENMASK(23, 17)
+#define VI_AC_ACM_STAT_FIELD		BIT(16)
+#define BE_AC_COUNT_FIELD		GENMASK(15, 9)
+#define BE_AC_ACM_STAT_FIELD		BIT(8)
+#define BK_AC_COUNT_FIELD		GENMASK(7, 3)
+#define BK_AC_ACM_STAT_FIELD		BIT(1)
 
 #define WILC_PKT_HDR_CONFIG_FIELD	BIT(31)
 #define WILC_PKT_HDR_OFFSET_FIELD	GENMASK(30, 22)
@@ -244,7 +302,6 @@
 #define INT_2			BIT(IRG_FLAGS_OFFSET + 2)
 #define INT_3			BIT(IRG_FLAGS_OFFSET + 3)
 #define INT_4			BIT(IRG_FLAGS_OFFSET + 4)
-#define INT_5			BIT(IRG_FLAGS_OFFSET + 5)
 #define MAX_NUM_INT		5
 #define IRG_FLAGS_MASK		GENMASK(IRG_FLAGS_OFFSET + MAX_NUM_INT, \
 					IRG_FLAGS_OFFSET)
@@ -282,11 +339,13 @@
 #define ENABLE_RX_VMM		(SEL_VMM_TBL1 | EN_VMM)
 #define ENABLE_TX_VMM		(SEL_VMM_TBL0 | EN_VMM)
 /* time for expiring the completion of cfg packets */
-#define WILC_CFG_PKTS_TIMEOUT	msecs_to_jiffies(2000)
+#define WILC_CFG_PKTS_TIMEOUT	msecs_to_jiffies(3000)
 
 #define IS_MANAGMEMENT		0x100
 #define IS_MANAGMEMENT_CALLBACK	0x080
 #define IS_MGMT_STATUS_SUCCES	0x040
+#define IS_MON_PKT		0x020
+#define IS_MGMT_AUTH_PKT	0x010
 
 #define WILC_WID_TYPE		GENMASK(15, 12)
 #define WILC_VMM_ENTRY_FULL_RETRY	1
@@ -295,10 +354,17 @@
  *      Tx/Rx Queue Structure
  *
  ********************************************/
+enum ip_pkt_priority {
+	AC_VO_Q = 0,
+	AC_VI_Q = 1,
+	AC_BE_Q = 2,
+	AC_BK_Q = 3
+};
 
 struct txq_entry_t {
 	struct list_head list;
 	int type;
+	u8 q_num;
 	int ack_idx;
 	u8 *buffer;
 	int buffer_size;
@@ -308,12 +374,28 @@ struct txq_entry_t {
 	void (*tx_complete_func)(void *priv, int status);
 };
 
+struct txq_fw_recv_queue_stat {
+	u8 acm;
+	u8 count;
+};
+
+struct txq_handle {
+	struct txq_entry_t txq_head;
+	u16 count;
+	struct txq_fw_recv_queue_stat fw;
+};
+
 struct rxq_entry_t {
 	struct list_head list;
 	u8 *buffer;
 	int buffer_size;
 };
 
+enum wilc_chip_type {
+	WILC_1000,
+	WILC_3000,
+};
+
 /********************************************
  *
  *      Host IF Structure
@@ -335,6 +417,9 @@ struct wilc_hif_func {
 	int (*hif_sync_ext)(struct wilc *wilc, int nint);
 	int (*enable_interrupt)(struct wilc *nic);
 	void (*disable_interrupt)(struct wilc *nic);
+	int (*hif_reset)(struct wilc *wilc);
+	bool (*hif_is_init)(struct wilc *wilc);
+	int (*hif_clear_init)(struct wilc *wilc);
 };
 
 #define WILC_MAX_CFG_FRAME_SIZE		1468
@@ -343,6 +428,7 @@ struct tx_complete_data {
 	int size;
 	void *buff;
 	struct sk_buff *skb;
+	struct wilc_vif *vif;
 };
 
 struct wilc_cfg_cmd_hdr {
@@ -362,14 +448,14 @@ struct wilc_cfg_rsp {
 	u8 seq_no;
 };
 
-struct wilc;
 struct wilc_vif;
 
 int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
 				u32 buffer_size);
 int wilc_wlan_start(struct wilc *wilc);
 int wilc_wlan_stop(struct wilc *wilc, struct wilc_vif *vif);
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+int wilc_wlan_txq_add_net_pkt(struct net_device *dev,
+			      struct tx_complete_data *tx_data, u8 *buffer,
 			      u32 buffer_size,
 			      void (*tx_complete_fn)(void *, int));
 int wilc_wlan_handle_txq(struct wilc *wl, u32 *txq_count);
@@ -382,16 +468,26 @@ int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			       u32 buffer_size, void (*func)(void *, int));
 void wilc_enable_tcp_ack_filter(struct wilc_vif *vif, bool value);
-int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc);
 netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
 
-void wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size);
-void host_wakeup_notify(struct wilc *wilc);
-void host_sleep_notify(struct wilc *wilc);
-void chip_allow_sleep(struct wilc *wilc);
-void chip_wakeup(struct wilc *wilc);
+bool wilc_wfi_p2p_rx(struct wilc_vif *vif, u8 *buff, u32 size);
+bool wilc_wfi_mgmt_frame_rx(struct wilc_vif *vif, u8 *buff, u32 size);
+void host_wakeup_notify(struct wilc *wilc, int source);
+void host_sleep_notify(struct wilc *wilc, int source);
+void chip_allow_sleep(struct wilc *wilc, int source);
+void chip_wakeup(struct wilc *wilc, int source);
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count);
+void wilc_bt_init(struct wilc *wilc);
+void wilc_bt_deinit(void);
+#if KERNEL_VERSION(4, 15, 0) <= LINUX_VERSION_CODE
+void eap_buff_timeout(struct timer_list *t);
+#else
+void eap_buff_timeout(unsigned long user);
+#endif
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source);
+void release_bus(struct wilc *wilc, enum bus_release release, int source);
 int wilc_wlan_init(struct net_device *dev);
 u32 wilc_get_chipid(struct wilc *wilc, bool update);
+void wilc_wfi_handle_monitor_rx(struct wilc *wilc, u8 *buff, u32 size);
 #endif
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c b/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c
index fe2a7ed8..7b7d7dc 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c
+++ b/drivers/net/wireless/microchip/wilc1000/wlan_cfg.c
@@ -3,13 +3,15 @@
  * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.
  * All rights reserved.
  */
-
-#include <linux/bitfield.h>
 #include "wlan_if.h"
 #include "wlan.h"
 #include "wlan_cfg.h"
 #include "netdev.h"
 
+#if KERNEL_VERSION(4, 9, 0) <= LINUX_VERSION_CODE
+#include <linux/bitfield.h>
+#endif
+
 enum cfg_cmd_type {
 	CFG_BYTE_CMD	= 0,
 	CFG_HWORD_CMD	= 1,
@@ -22,6 +24,8 @@ static const struct wilc_cfg_byte g_cfg_byte[] = {
 	{WID_STATUS, 0},
 	{WID_RSSI, 0},
 	{WID_LINKSPEED, 0},
+	{WID_TX_POWER, 0},
+	{WID_WOWLAN_TRIGGER, 0},
 	{WID_NIL, 0}
 };
 
@@ -45,6 +49,11 @@ static const struct wilc_cfg_str g_cfg_str[] = {
 	{WID_NIL, NULL}
 };
 
+static const struct wilc_cfg_bin g_cfg_bin[] = {
+	{WID_ANTENNA_SELECTION, NULL},
+	{WID_NIL, NULL}
+};
+
 #define WILC_RESP_MSG_TYPE_CONFIG_REPLY		'R'
 #define WILC_RESP_MSG_TYPE_STATUS_INFO		'I'
 #define WILC_RESP_MSG_TYPE_NETWORK_INFO		'N'
@@ -179,11 +188,45 @@ static void wilc_wlan_parse_response_frame(struct wilc *wl, u8 *info, int size)
 				i++;
 
 			if (cfg->s[i].id == wid)
-				memcpy(cfg->s[i].str, &info[2], info[2] + 2);
+				memcpy(cfg->s[i].str, &info[2],
+				       (2 + ((info[3] << 8) | info[2])));
 
-			len = 2 + info[2];
+			len = 2 + ((info[3] << 8) | info[2]);
 			break;
+		case WID_BIN_DATA:
+			while (cfg->bin[i].id != WID_NIL &&
+			       cfg->bin[i].id != wid)
+				i++;
 
+			if (cfg->bin[i].id == wid) {
+				u16 length = (info[3] << 8) | info[2];
+				u8 checksum = 0;
+				int j = 0;
+
+				/*
+				 * Compute the Checksum of received
+				 * data field
+				 */
+				for (j = 0; j < length; j++)
+					checksum += info[4 + j];
+				/*
+				 * Verify the checksum of received BIN
+				 * DATA
+				 */
+				if (checksum != info[4 + length]) {
+					pr_err("%s: Checksum Failed\n",
+					       __func__);
+					return;
+				}
+
+				memcpy(cfg->bin[i].bin, &info[2], length + 2);
+				/*
+				 * value length + data length +
+				 * checksum
+				 */
+				len = 2 + length + 1;
+			}
+			break;
 		default:
 			break;
 		}
@@ -248,6 +291,8 @@ int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
 	case CFG_BIN_CMD:
 		ret = wilc_wlan_cfg_set_bin(frame, offset, id, buf, size);
 		break;
+	default:
+		pr_err("%s illegal type[%d] wid[%d]\n", __func__, type, id);
 	}
 
 	return ret;
@@ -307,7 +352,23 @@ int wilc_wlan_cfg_get_val(struct wilc *wl, u16 wid, u8 *buffer,
 				ret = size;
 			}
 		}
+	} else if (type == CFG_BIN_CMD) { /* binary command */
+		while (cfg->bin[i].id != WID_NIL && cfg->bin[i].id != wid)
+			i++;
+
+		if (cfg->bin[i].id == wid) {
+			u32 size = cfg->bin[i].bin[0] |
+				(cfg->bin[i].bin[1] << 8);
+
+			if (buffer_size >= size) {
+				memcpy(buffer, &cfg->bin[i].bin[2], size);
+				ret = size;
+			}
+		}
+	} else {
+		pr_err("[CFG]: illegal type (%08x)\n", wid);
 	}
+
 	return ret;
 }
 
@@ -335,6 +396,7 @@ void wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 		rsp->type = WILC_CFG_RSP_STATUS;
 		rsp->seq_no = msg_id;
 		/* call host interface info parse as well */
+		pr_info("%s: Info message received\n", __func__);
 		wilc_gnrl_async_info_received(wilc, frame - 4, size + 4);
 		break;
 
@@ -343,10 +405,14 @@ void wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 		break;
 
 	case WILC_RESP_MSG_TYPE_SCAN_COMPLETE:
+		pr_info("%s: Scan Notification Received\n", __func__);
 		wilc_scan_complete_received(wilc, frame - 4, size + 4);
 		break;
 
 	default:
+		pr_err("%s: Receive unknown message %d-%d-%d-%d-%d-%d-%d-%d\n",
+		       __func__, frame[0], frame[1], frame[2], frame[3],
+		       frame[4], frame[5], frame[6], frame[7]);
 		rsp->seq_no = msg_id;
 		break;
 	}
@@ -355,6 +421,7 @@ void wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 int wilc_wlan_cfg_init(struct wilc *wl)
 {
 	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_bin_vals *bin_vals;
 	int i = 0;
 
 	wl->cfg.b = kmemdup(g_cfg_byte, sizeof(g_cfg_byte), GFP_KERNEL);
@@ -377,6 +444,15 @@ int wilc_wlan_cfg_init(struct wilc *wl)
 	if (!str_vals)
 		goto out_s;
 
+	wl->cfg.bin = kmemdup(g_cfg_bin, sizeof(g_cfg_bin), GFP_KERNEL);
+	if (!wl->cfg.bin)
+		goto out_str_val;
+
+	bin_vals = kzalloc(sizeof(*bin_vals), GFP_KERNEL);
+	if (!bin_vals)
+		goto out_bin;
+
+	/* store the string cfg parameters */
 	wl->cfg.str_vals = str_vals;
 	/* store the string cfg parameters */
 	wl->cfg.s[i].id = WID_FIRMWARE_VERSION;
@@ -390,8 +466,22 @@ int wilc_wlan_cfg_init(struct wilc *wl)
 	i++;
 	wl->cfg.s[i].id = WID_NIL;
 	wl->cfg.s[i].str = NULL;
+
+	/* store the bin parameters */
+	i = 0;
+	wl->cfg.bin[i].id = WID_ANTENNA_SELECTION;
+	wl->cfg.bin[i].bin = bin_vals->antenna_param;
+	i++;
+
+	wl->cfg.bin[i].id = WID_NIL;
+	wl->cfg.bin[i].bin = NULL;
+
 	return 0;
 
+out_bin:
+	kfree(wl->cfg.bin);
+out_str_val:
+	kfree(str_vals);
 out_s:
 	kfree(wl->cfg.s);
 out_w:
@@ -410,4 +500,6 @@ void wilc_wlan_cfg_deinit(struct wilc *wl)
 	kfree(wl->cfg.w);
 	kfree(wl->cfg.s);
 	kfree(wl->cfg.str_vals);
+	kfree(wl->cfg.bin);
+	kfree(wl->cfg.bin_vals);
 }
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan_cfg.h b/drivers/net/wireless/microchip/wilc1000/wlan_cfg.h
index 614c567..764c93c 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan_cfg.h
+++ b/drivers/net/wireless/microchip/wilc1000/wlan_cfg.h
@@ -27,18 +27,29 @@ struct wilc_cfg_str {
 	u8 *str;
 };
 
+struct wilc_cfg_bin {
+	u16 id;
+	u8 *bin;
+};
+
 struct wilc_cfg_str_vals {
 	u8 mac_address[7];
 	u8 firmware_version[129];
 	u8 assoc_rsp[256];
 };
 
+struct wilc_bin_vals {
+	u8 antenna_param[5];
+};
+
 struct wilc_cfg {
 	struct wilc_cfg_byte *b;
 	struct wilc_cfg_hword *hw;
 	struct wilc_cfg_word *w;
 	struct wilc_cfg_str *s;
 	struct wilc_cfg_str_vals *str_vals;
+	struct wilc_cfg_bin *bin;
+	struct wilc_bin_vals *bin_vals;
 };
 
 struct wilc;
diff --git a/drivers/net/wireless/microchip/wilc1000/wlan_if.h b/drivers/net/wireless/microchip/wilc1000/wlan_if.h
index f85fd57..1d633b7 100644
--- a/drivers/net/wireless/microchip/wilc1000/wlan_if.h
+++ b/drivers/net/wireless/microchip/wilc1000/wlan_if.h
@@ -8,6 +8,7 @@
 #define WILC_WLAN_IF_H
 
 #include <linux/netdevice.h>
+#include "debugfs.h"
 #include "fw.h"
 
 /********************************************
@@ -15,6 +16,7 @@
  *      Wlan Configuration ID
  *
  ********************************************/
+#define	FW_WILC3000_BLE		"mchp/wilc3000_ble_firmware.bin"
 
 enum bss_types {
 	WILC_FW_BSS_TYPE_INFRA = 0,
@@ -35,6 +37,10 @@ enum {
 	WILC_FW_PREAMBLE_AUTO = 2,	/* Auto Preamble Selection */
 };
 
+#define DEV_WIFI	0
+#define DEV_BT		1
+#define DEV_MAX		2
+
 enum {
 	WILC_FW_PASSIVE_SCAN = 0,
 	WILC_FW_ACTIVE_SCAN = 1,
@@ -48,12 +54,6 @@ enum {
 	WILC_FW_MAX_PSPOLL_PS = 4
 };
 
-enum chip_ps_states {
-	WILC_CHIP_WAKEDUP = 0,
-	WILC_CHIP_SLEEPING_AUTO = 1,
-	WILC_CHIP_SLEEPING_MANUAL = 2
-};
-
 enum bus_acquire {
 	WILC_BUS_ACQUIRE_ONLY = 0,
 	WILC_BUS_ACQUIRE_AND_WAKEUP = 1,
@@ -91,7 +91,16 @@ enum authtype {
 	WILC_FW_AUTH_OPEN_SYSTEM = 1,
 	WILC_FW_AUTH_SHARED_KEY = 2,
 	WILC_FW_AUTH_ANY = 3,
-	WILC_FW_AUTH_IEEE8021 = 5
+	WILC_FW_AUTH_IEEE8021 = 5,
+	WILC_FW_AUTH_SAE = 7,
+	WILC_FW_AUTH_IEE8021X_SHA256 = 9,
+	WILC_FW_AUTH_OPEN_SYSTEM_SHA256 = 13
+};
+
+enum mfptype {
+	WILC_FW_MFP_NONE = 0x0,
+	WILC_FW_MFP_OPTIONAL = 0x1,
+	WILC_FW_MFP_REQUIRED = 0x2
 };
 
 enum site_survey {
@@ -182,7 +191,8 @@ enum {
 
 enum {
 	WILC_FW_ACTION_FRM_IDX = 0,
-	WILC_FW_PROBE_REQ_IDX = 1
+	WILC_FW_PROBE_REQ_IDX = 1,
+	WILC_FW_AUTH_REQ_IDX = 2
 };
 
 enum wid_type {
@@ -194,6 +204,13 @@ enum wid_type {
 	WID_BIN			= 5,
 };
 
+enum {
+	ANTENNA1		= 0,
+	ANTENNA2		= 1,
+	DIVERSITY		= 2,
+	NUM_ANT_MODE
+};
+
 struct wid {
 	u16 id;
 	enum wid_type type;
@@ -662,6 +679,8 @@ enum {
 
 	WID_LOG_TERMINAL_SWITCH		= 0x00CD,
 	WID_TX_POWER			= 0x00CE,
+	WID_WOWLAN_TRIGGER		= 0X00CF,
+	WID_SET_MFP			= 0x00D0,
 	/*  EMAC Short WID list */
 	/*  RTS Threshold */
 	/*
@@ -751,6 +770,7 @@ enum {
 	WID_REMOVE_KEY			= 0x301E,
 	WID_ASSOC_REQ_INFO		= 0x301F,
 	WID_ASSOC_RES_INFO		= 0x3020,
+	WID_ADD_IGTK			= 0x3022,
 	WID_MANUFACTURER		= 0x3026, /* Added for CAPI tool */
 	WID_MODEL_NAME			= 0x3027, /* Added for CAPI tool */
 	WID_MODEL_NUM			= 0x3028, /* Added for CAPI tool */
@@ -795,6 +815,8 @@ enum {
 
 	WID_SETUP_MULTICAST_FILTER	= 0x408b,
 
+	WID_ANTENNA_SELECTION		= 0x408c,
+	WID_EXTERNAL_AUTH_PARAM	= 0x408d,
 	/* Miscellaneous WIDs */
 	WID_ALL				= 0x7FFE,
 	WID_MAX				= 0xFFFF
-- 
2.7.4

